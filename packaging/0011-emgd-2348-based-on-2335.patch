From daaf10390f62b0f5035d9cbf91179b6745f95795 Mon Sep 17 00:00:00 2001
From: Liu Xinyun <xinyun.liu@intel.com>
Date: Fri, 24 Feb 2012 13:55:56 +0800
Subject: [PATCH] emgd-2348

---
 .../staging/emgd/emgd/display/mode/cmn/igd_mode.c  |  112 ++-
 .../emgd/emgd/display/mode/cmn/micro_mode.c        |   12 +-
 .../emgd/emgd/display/mode/cmn/mode_dispatch.h     |    8 +-
 .../staging/emgd/emgd/display/mode/plb/mode_plb.c  |   18 +-
 .../staging/emgd/emgd/display/mode/tnc/mode_tnc.c  |   77 ++-
 .../staging/emgd/emgd/display/pi/cmn/displayid.c   |   53 +-
 drivers/staging/emgd/emgd/display/pi/cmn/pi.c      |   38 +-
 drivers/staging/emgd/emgd/drm/drm_emgd_private.h   |    5 +-
 drivers/staging/emgd/emgd/drm/emgd_drv.c           |   79 ++-
 drivers/staging/emgd/emgd/drm/emgd_drv.h           |    4 +-
 drivers/staging/emgd/emgd/drm/emgd_interface.c     |  216 ++++-
 drivers/staging/emgd/emgd/drm/user_config.c        |    4 +-
 drivers/staging/emgd/emgd/include/displayid.h      |   35 +-
 drivers/staging/emgd/emgd/include/msvdx.h          |   20 +-
 drivers/staging/emgd/emgd/include/plb/context.h    |   14 +-
 drivers/staging/emgd/emgd/pal/ch7036/Makefile.gnu  |    1 -
 drivers/staging/emgd/emgd/pal/ch7036/ch7036.c      |   26 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c |    4 -
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c   |    3 -
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c |    9 -
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c |    1 -
 drivers/staging/emgd/emgd/video/msvdx/msvdx.c      |   53 +-
 drivers/staging/emgd/emgd/video/msvdx/msvdx_init.c | 1109 ++++++++++++++++----
 drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.c  |  270 +++++-
 drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.h  |   23 +-
 drivers/staging/emgd/include/emgd_drm.h            |   11 +-
 drivers/staging/emgd/include/igd_init.h            |    5 +-
 drivers/staging/emgd/include/igd_mode.h            |   13 +-
 drivers/staging/emgd/include/igd_ovl.h             |    7 +-
 drivers/staging/emgd/include/igd_pd.h              |    7 +-
 drivers/staging/emgd/include/igd_version.h         |    6 +-
 .../services4/3rdparty/emgd_bufferclass/emgd_bc.c  |    2 +-
 .../3rdparty/emgd_bufferclass/emgd_bc_linux.c      |    4 +-
 .../emgd/pvr/services4/srvkm/common/deviceclass.c  |   19 +-
 34 files changed, 1917 insertions(+), 351 deletions(-)

diff --git a/drivers/staging/emgd/emgd/display/mode/cmn/igd_mode.c b/drivers/staging/emgd/emgd/display/mode/cmn/igd_mode.c
index 50c69cd..8457774 100755
--- a/drivers/staging/emgd/emgd/display/mode/cmn/igd_mode.c
+++ b/drivers/staging/emgd/emgd/display/mode/cmn/igd_mode.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_mode.c
- * $Revision: 1.34 $
+ * $Revision: 1.35 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -210,6 +210,7 @@ int mode_pwr(igd_context_t *context,
 	switch(powerstate) {
 	case IGD_POWERSTATE_D0:
 		mode_context->dispatch->program_cdvo();
+		toggle_vblank_interrupts(TRUE);
 		break;
 
 #if 0
@@ -255,6 +256,7 @@ int mode_pwr(igd_context_t *context,
 	case IGD_POWERSTATE_D1:
 	case IGD_POWERSTATE_D2:
 	case IGD_POWERSTATE_D3:
+		toggle_vblank_interrupts(FALSE);
 		mode_context->dispatch->reset_plane_pipe_ports(mode_context->context);
 		break;
 	default:
@@ -1784,6 +1786,8 @@ static void mode_shutdown(igd_context_t *context)
 
 	dsp_wait_rb(mode_context->context);
 
+	toggle_vblank_interrupts(FALSE);
+
 	/* Disable all VBlank interrupts: */
 	context->dispatch.disable_vblank_callback(ALL_PORT_CALLBACKS);
 
@@ -2228,3 +2232,109 @@ int igd_kms_match_mode(void *emgd_encoder,
 	EMGD_TRACE_EXIT;
 	return ret;
 }
+
+/*
+ * Name: toggle_vblank_interrupts
+ *
+ * Description:
+ * Requests/stops requesting for  vblank notification interrupts for ports
+ * where blit-batching has been enabled. Called from mode_init, mode_pwr and
+ * emgd_driver_pre_init to enable interrupts if needed, and from mode_pwr and
+ * mode_shutdown to disable the interrupts when shutting down the driver.
+ *
+ * @param status 0 to disable and 1 to enable interrupts
+ *
+ * @return None
+ */
+void toggle_vblank_interrupts(bool status) {
+
+	unsigned long toggle_for;
+	unsigned char * mmio;
+	int i;
+
+	mmio = EMGD_MMIO(mode_context->context->device_context.virt_mmadr);
+	for (i=0; i < IGD_MAX_PORTS; i++) {
+		if(mode_context->batch_blits[i]) {
+			toggle_for = 0;
+			if (i == IGD_PORT_TYPE_SDVOB - 1) {
+				toggle_for = VBINT_REQUEST(VBINT_FLIP, VBINT_PORT2);
+			} else if (i == IGD_PORT_TYPE_LVDS - 1) {
+				toggle_for = VBINT_REQUEST(VBINT_FLIP, VBINT_PORT4);
+			}
+
+			if (toggle_for) {
+
+				if (status) {
+					mode_context->dispatch->full->request_vblanks(toggle_for, mmio);
+				} else {
+					mode_context->dispatch->full->end_request(toggle_for, mmio);
+				}
+			}
+		}
+	}
+
+}
+
+/*
+ * Notifies the user-space of a VBlank event by adding an event to the event
+ * queue of the DRM master file-descriptor
+ */
+void notify_userspace_vblank(struct drm_device *dev, int port)
+{
+
+	drm_emgd_priv_t *devpriv = dev->dev_private;
+	struct drm_pending_vblank_event *e = NULL;
+	struct timeval now;
+	unsigned long flags = 0;
+
+
+	EMGD_TRACE_ENTER;
+
+	if (!(devpriv->drm_master_fd)) {
+		EMGD_DEBUG("DRM master file-descriptor not set - exiting");
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+	spin_lock_irqsave(&dev->event_lock,flags);
+
+	/* Check if there is space for new event object */
+	if (devpriv->drm_master_fd->event_space < sizeof(e->event)) {
+		spin_unlock_irqrestore(&dev->event_lock, flags);
+		EMGD_DEBUG("No space on file-descriptor event queue");
+		EMGD_TRACE_EXIT;
+		return;
+	}
+	devpriv->drm_master_fd->event_space -= sizeof(e->event);
+
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+
+	e = OS_ALLOC(sizeof(struct drm_pending_vblank_event));
+	if (e == NULL) {
+		spin_lock_irqsave(&dev->event_lock, flags);
+		devpriv->drm_master_fd->event_space += sizeof(e->event);
+		spin_unlock_irqrestore(&dev->event_lock, flags);
+		EMGD_TRACE_EXIT;
+		return;
+	}
+
+	/* Setup event struct */
+	OS_MEMSET(e, 0, sizeof(struct drm_pending_vblank_event));
+	e->event.base.type = DRM_EVENT_VBLANK;
+	e->event.base.length = sizeof(e->event);
+	e->event.user_data = port;
+	e->base.event = &e->event.base;
+	e->base.file_priv = devpriv->drm_master_fd;
+	e->base.destroy = (void (*)(struct drm_pending_event *))kfree;
+
+	do_gettimeofday(&now);
+	e->event.tv_sec = now.tv_sec;
+	e->event.tv_usec = now.tv_usec;
+
+	/* Add event to the event list */
+	list_add_tail(&e->base.link, &e->base.file_priv->event_list);
+	wake_up_interruptible(&e->base.file_priv->event_wait);
+
+	EMGD_TRACE_EXIT;
+
+}
diff --git a/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c b/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c
index 3621660..a6e20c0 100644
--- a/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c
+++ b/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: micro_mode.c
- * $Revision: 1.30 $
+ * $Revision: 1.31 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1612,6 +1612,8 @@ int mode_init(igd_context_t *context)
 {
 	igd_dispatch_t     *dispatch = &context->dispatch;
 	inter_module_dispatch_t *md;
+	int port_num;
+	int i;
 
 	EMGD_TRACE_ENTER;
 
@@ -1661,6 +1663,13 @@ int mode_init(igd_context_t *context)
 		context->mod_dispatch.init_params->disp_chicken_bits;
 #endif
 
+	for (i=0; i < IGD_MAX_PORTS; i++) {
+		port_num = context->mod_dispatch.init_params->display_params[i].port_number;
+		mode_context->batch_blits[port_num - 1] =
+			(context->mod_dispatch.init_params->display_params[i].flags
+			& IGD_DISPLAY_BATCH_BLITS);
+	}
+
 	/* Get mode's dispatch table */
 	mode_context->dispatch = (mode_dispatch_t *)
 		dispatch_acquire(context, mode_dispatch);
@@ -1736,6 +1745,7 @@ int mode_init(igd_context_t *context)
 		}
 	}
 
+	toggle_vblank_interrupts(TRUE);
 	/* Initialize the Display Configuration List */
 	/* FIXME: This should be done in dsp init */
 	dsp_dc_init(context);
diff --git a/drivers/staging/emgd/emgd/display/mode/cmn/mode_dispatch.h b/drivers/staging/emgd/emgd/display/mode/cmn/mode_dispatch.h
index 1dbbc6c..b2ae62e 100644
--- a/drivers/staging/emgd/emgd/display/mode/cmn/mode_dispatch.h
+++ b/drivers/staging/emgd/emgd/display/mode/cmn/mode_dispatch.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: mode_dispatch.h
- * $Revision: 1.16 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -240,6 +240,10 @@ typedef struct _mode_context {
 	unsigned long bunit_write_flush;
 	unsigned long disp_chicken_bits;
 
+	/* Flags specifying whether to notify user-space of a v-blank event.
+	 * This is used when synchronizing back-buffer blits */
+	bool batch_blits[IGD_MAX_PORTS];
+
 } mode_context_t;
 
 extern int full_mode_init(igd_context_t *context,
@@ -263,6 +267,8 @@ extern void swap_fb_cursor( void );
 extern int set_color_correct(igd_display_context_t *display,
 	const igd_range_attr_t *attr_to_set);
 
+extern void toggle_vblank_interrupts(bool status);
+
 extern mode_context_t mode_context[];
 
 /*
diff --git a/drivers/staging/emgd/emgd/display/mode/plb/mode_plb.c b/drivers/staging/emgd/emgd/display/mode/plb/mode_plb.c
index 95973e0..ac6ea5d 100644
--- a/drivers/staging/emgd/emgd/display/mode/plb/mode_plb.c
+++ b/drivers/staging/emgd/emgd/display/mode/plb/mode_plb.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: mode_plb.c
- * $Revision: 1.33 $
+ * $Revision: 1.34 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -93,7 +93,7 @@ int check_flip_pending_plb(unsigned char *mmio, unsigned long pipe_status_reg);
  */
 int wait_for_vblank_plb(unsigned char *mmio, unsigned long pipe_reg);
 
-
+void notify_userspace_vblank(struct drm_device *dev, int port);
 
 /*!
  *
@@ -1452,6 +1452,20 @@ static irqreturn_t interrupt_handler_plb(int irq, void* mmio)
 	}
 	spin_unlock_irqrestore(&vblank_lock_plb, lock_flags);
 
+
+	if (port4_interrupt) {
+		if (mode_context->batch_blits[IGD_PORT_TYPE_LVDS - 1]) {
+			notify_userspace_vblank(mode_context->context->drm_dev,
+				IGD_PORT_TYPE_LVDS);
+		}
+	}
+	else if (port2_interrupt) {
+		if (mode_context->batch_blits[IGD_PORT_TYPE_SDVOB - 1]) {
+			notify_userspace_vblank(mode_context->context->drm_dev,
+				IGD_PORT_TYPE_SDVOB);
+		}
+	}
+
 	/* Call any registered/enabled callbacks for this interrupt: */
 	cb = &interrupt_callbacks_plb[2];
 	if (port2_interrupt && cb->callback &&
diff --git a/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c b/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c
index 06e1903..4cc2d79 100644
--- a/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c
+++ b/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: mode_tnc.c
- * $Revision: 1.32 $
+ * $Revision: 1.33 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -100,6 +100,7 @@ int check_flip_pending_tnc(unsigned char *mmio, unsigned long pipe_status_reg);
 
 /* KMS callback from emgd_crtc.c */
 int crtc_pageflip_handler(struct drm_device *dev, int port);
+void notify_userspace_vblank(struct drm_device *dev, int port);
 
 /*!
  * @addtogroup display_group
@@ -1459,7 +1460,7 @@ static int get_port_info_tnc(void)
  */
 static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 {
-	unsigned long iir;
+	unsigned long iir, iir_dev3;
 	unsigned long lock_flags;
 	unsigned long tmp;
 	unsigned long port2_interrupt = 0;
@@ -1468,15 +1469,15 @@ static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 
 	EMGD_TRACE_ENTER;
 
-
 	iir = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
+	iir_dev3 = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IIR);
 
 
 	/* Detect whether a vblank interrupt occured, and if so, what type of
 	 * processing is needed (do the simple processing now):
 	 */
 	spin_lock_irqsave(&vblank_lock_tnc, lock_flags);
-	if ((port2_interrupt = iir & BIT5 /* Port 2/Pipe A/SDVO-B */) != 0) {
+	if ((port2_interrupt = iir_dev3 & BIT5 /* Port 2/Pipe A/SDVO-B */) != 0) {
 		if ((tmp = vblank_interrupt_state & VBLANK_INT4_PORT2) != 0) {
 			/* Record "answers" for all requestors: */
 			vblank_interrupt_state |= VBINT_ANSWER4_REQUEST(tmp);
@@ -1500,11 +1501,22 @@ static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 	if (port4_interrupt) {
 		crtc_pageflip_handler(mode_context->context->drm_dev,
 			IGD_PORT_TYPE_LVDS);
+
+		if (mode_context->batch_blits[IGD_PORT_TYPE_LVDS - 1]) {
+			notify_userspace_vblank(mode_context->context->drm_dev,
+				IGD_PORT_TYPE_LVDS);
+		}
 	} else if (port2_interrupt) {
 		crtc_pageflip_handler(mode_context->context->drm_dev,
 			IGD_PORT_TYPE_SDVOB);
+
+		if (mode_context->batch_blits[IGD_PORT_TYPE_SDVOB - 1]) {
+			notify_userspace_vblank(mode_context->context->drm_dev,
+				IGD_PORT_TYPE_SDVOB);
+		}
 	}
 
+
 	/* Notify KMS Hander:  The assignment of CRTC=0 for PIPE A and
 	 * CRTC=1 for PIPE B is not correct if somehow PIPE A is disabled.
 	 */
@@ -1544,6 +1556,14 @@ static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 			tmp = tmp & (~PIPESTAT_STS_BITS);
 			EMGD_WRITE32((tmp | VBLANK_STS), EMGD_MMIO(mmio) + PIPEB_STAT);
 			EMGD_READ32(EMGD_MMIO(mmio) + PIPEB_STAT);
+
+			tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT);
+			/* Clear bits that are written by a 1, so we don't clear them: */
+			tmp = tmp & (~PIPESTAT_STS_BITS);
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT,
+					(tmp | VBLANK_STS));
+			READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT);
+			tmp = READ_MMIO_REG_TNC(IGD_PORT_LVDS, PIPEB_STAT);
 		}
 		if (port4_interrupt) {
 			tmp = EMGD_READ32(EMGD_MMIO(mmio) + PIPEA_STAT);
@@ -1554,6 +1574,7 @@ static irqreturn_t interrupt_handler_tnc(int irq, void* mmio)
 
 		/* Clear the corresponding bits in the IIR register: */
 		EMGD_WRITE32((port2_interrupt | port4_interrupt), EMGD_MMIO(mmio)+IIR);
+		WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IIR, port2_interrupt);
 
 
 		EMGD_DEBUG("EXIT--IRQ_HANDLED");
@@ -1639,6 +1660,30 @@ int request_vblanks_tnc(unsigned long request_for, unsigned char *mmio)
 			/* 4. Set the Interrupt Enable Register bit for this pipe: */
 			tmp = EMGD_READ32(EMGD_MMIO(mmio) + IER);
 			EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IER);
+
+			/* NOW LET'S PROGRAM DEVICE 3 */
+
+			tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT);
+			/* Clear bits that are written by a 1, so we don't clear them: */
+			tmp = tmp & (~PIPESTAT_STS_BITS);
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT,
+					(tmp | VBLANK_STS_EN | VBLANK_STS));
+			READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT);
+
+			/* 2. Just in case, clear (by setting) the Interrupt Identity
+			 *    Register bit for this pipe:
+			 */
+			tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IIR);
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IIR, (tmp | BIT5));
+
+			/* 3. Clear the Interrupt Mask Register bit for this pipe: */
+			tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IMR);
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IMR, (tmp & (~BIT5)));
+
+			/* 4. Set the Interrupt Enable Register bit for this pipe: */
+			tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IER);
+			WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IER, (tmp | BIT5));
+
 		}
 		vblank_interrupt_state |= request_for;
 		vblank_interrupt_ref_cnt_port2++;
@@ -1756,6 +1801,30 @@ int end_request_tnc(unsigned long request_for, unsigned char *mmio)
 				*/
 				tmp = EMGD_READ32(EMGD_MMIO(mmio) + IIR);
 				EMGD_WRITE32((tmp | BIT5), EMGD_MMIO(mmio) + IIR);
+
+				/* NOW LET'S PROGRAM DEVICE 3 */
+
+				tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT);
+					/* Clear bits that are written by a 1, so we don't clear them: */
+				tmp = tmp & (~PIPESTAT_STS_BITS);
+				WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT,
+						((tmp & (~VBLANK_STS_EN)) | VBLANK_STS));
+				READ_MMIO_REG_TNC(IGD_PORT_SDVO, PIPEB_STAT);
+
+				/* 2. Clear the Interrupt Enable Register bit for this pipe: */
+				tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IER);
+				WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IER, (tmp & (~BIT5)));
+
+				/* 3. Set the Interrupt Mask Register bit for this pipe: */
+				tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IMR);
+				WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IMR, (tmp | BIT5));
+
+				/* 4. Just in case, clear (by setting) the Interrupt Identity
+				 *    Register bit for this pipe:
+				 */
+				tmp = READ_MMIO_REG_TNC(IGD_PORT_SDVO, IIR);
+				WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, IIR, (tmp | BIT5));
+
 			}
 		}
 	}
diff --git a/drivers/staging/emgd/emgd/display/pi/cmn/displayid.c b/drivers/staging/emgd/emgd/display/pi/cmn/displayid.c
index a2f4547..186ce7d 100644
--- a/drivers/staging/emgd/emgd/display/pi/cmn/displayid.c
+++ b/drivers/staging/emgd/emgd/display/pi/cmn/displayid.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: displayid.c
- * $Revision: 1.10 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -772,6 +772,55 @@ void displayid_enable_std_timings(pd_timing_t *tt1, unsigned char *db_data,
 	}
 }
 
+static void displayid_parse_orientation_info (unsigned char orientation_blob,
+	igd_DID_rotation_info_t * rotation_info) {
+
+	unsigned int def_orientation = DEFAULT_ORIENTATION(orientation_blob);
+	unsigned int zero_pixel = ZERO_PIXEL(orientation_blob);
+	unsigned int scan_dir = SCAN_DIRECTION(orientation_blob);
+
+	/* Start with no rotation */
+	rotation_info->rotation = 0;
+	rotation_info->flip = 0;
+
+
+	if (def_orientation >= DEF_ORIENTATION_UNKNOWN) {
+		/* Display ID blob is corrupted or unknown configuration set */
+		EMGD_DEBUG("DisplayID: Unknown default orientation value: %d",
+			def_orientation);
+		return;
+	}
+
+	if (scan_dir == SCAN_DIRECTION_LONG) {
+		if (def_orientation == DEF_ORIENTATION_PORTRAIT) {
+			rotation_info->flip =
+				(zero_pixel == ZP_UPPER_LEFT || zero_pixel == ZP_LOWER_RIGHT);
+			rotation_info->rotation += 90;
+		} else { /* Landscape */
+			rotation_info->flip =
+				(zero_pixel == ZP_UPPER_RIGHT || zero_pixel == ZP_LOWER_LEFT);
+		}
+
+	} else if (scan_dir == SCAN_DIRECTION_SHORT) {
+		if (def_orientation == DEF_ORIENTATION_PORTRAIT) {
+			rotation_info->flip =
+				(zero_pixel == ZP_UPPER_RIGHT || zero_pixel == ZP_LOWER_LEFT);
+		}
+		else { /* Landscape */
+			rotation_info->flip =
+				(zero_pixel == ZP_UPPER_LEFT || zero_pixel == ZP_LOWER_RIGHT);
+			rotation_info->rotation += 90;
+		}
+	} else { /* Unknown scan direction */
+		EMGD_DEBUG("DisplayID: Unknown scan direction value: %d", scan_dir);
+		return;
+	}
+
+	/* zero pixel is in the lower-half: need to rotate by 180 degs */
+	if (zero_pixel == ZP_LOWER_LEFT || zero_pixel == ZP_LOWER_RIGHT)
+		rotation_info->rotation += 180;
+}
+
 /*!
  * Function to parse DisplayID
  *
@@ -939,6 +988,8 @@ int displayid_parse(
 				did->attr_list[did->num_attrs].flags=PD_ATTR_FLAG_VALUE_CHANGED;
 				did->attr_list[did->num_attrs++].current_value =
 					(did->display_dev.display_color_depth+1)*3;
+				displayid_parse_orientation_info(did->display_dev.orientation,
+												&(did->rotation_info));
 				break;
 
 			case DATABLOCK_LVDS_INTERFACE:
diff --git a/drivers/staging/emgd/emgd/display/pi/cmn/pi.c b/drivers/staging/emgd/emgd/display/pi/cmn/pi.c
index 7b5abe8..8eca6c7 100755
--- a/drivers/staging/emgd/emgd/display/pi/cmn/pi.c
+++ b/drivers/staging/emgd/emgd/display/pi/cmn/pi.c
@@ -1,7 +1,7 @@
 ﻿/*
  *-----------------------------------------------------------------------------
  * Filename: pi.c
- * $Revision: 1.24 $
+ * $Revision: 1.25 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -194,6 +194,12 @@ int pi_full_init(igd_context_t *context)
 static int pi_get_config_info(igd_context_t *context,
 	igd_config_info_t *config_info)
 {
+
+	igd_display_port_t   *port = NULL;
+	igd_param_t          *init_params = NULL;
+	igd_display_params_t *display_params = NULL;
+	int                   i;
+
 	EMGD_TRACE_ENTER;
 
 	EMGD_ASSERT(context, "Null context", -IGD_ERROR_INVAL);
@@ -201,6 +207,36 @@ static int pi_get_config_info(igd_context_t *context,
 
 	config_info->num_act_dsp_ports = pi_context->num_pi_drivers;
 
+	init_params = pi_context->igd_context->mod_dispatch.init_params;
+
+	while ((port = pi_context->igd_context->mod_dispatch.
+		dsp_get_next_port(pi_context->igd_context, port, 0)) != NULL) {
+
+		/* Get the display params to check if the user enabled EDID */
+		for (i = 0; i < IGD_MAX_PORTS; i++) {
+			if (init_params->display_params[i].port_number == port->port_number) {
+				display_params = &init_params->display_params[i];
+				break;
+			}
+		}
+
+		/* If DID rotation info is available, pass it to user-space through the
+		 * config_info struct */
+		if ((!display_params || (display_params->flags & IGD_DISPLAY_READ_EDID))
+			&& (port->firmware_type == PI_FIRMWARE_DISPLAYID
+			&&	port->displayid != NULL)) {
+
+			config_info->displayid_rotation[port->port_number - 1].rotation =
+				port->displayid->rotation_info.rotation;
+			config_info->displayid_rotation[port->port_number - 1].flip =
+				port->displayid->rotation_info.flip;
+
+		} else {
+			config_info->displayid_rotation[port->port_number - 1].rotation = 0;
+			config_info->displayid_rotation[port->port_number - 1].flip = 0;
+		}
+	}
+
 	EMGD_TRACE_EXIT;
 	return 0;
 }
diff --git a/drivers/staging/emgd/emgd/drm/drm_emgd_private.h b/drivers/staging/emgd/emgd/drm/drm_emgd_private.h
index 109f790..cad47c3 100644
--- a/drivers/staging/emgd/emgd/drm/drm_emgd_private.h
+++ b/drivers/staging/emgd/emgd/drm/drm_emgd_private.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: drm_emgd_private.h
- * $Revision: 1.20 $
+ * $Revision: 1.21 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -161,6 +161,9 @@ typedef struct _drm_emgd_private {
 	struct drm_device *ddev;
 	bool               kms_enabled;
 	int qb_seamless; /* Store the state of seamless/quickboot */
+
+	/* The fd of the drm master - used to send vblank events to userspace */
+	struct drm_file   *drm_master_fd;
 } drm_emgd_priv_t;
 
 
diff --git a/drivers/staging/emgd/emgd/drm/emgd_drv.c b/drivers/staging/emgd/emgd/drm/emgd_drv.c
index b3eeb32..69dfcb1 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_drv.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_drv.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drv.c
- * $Revision: 1.142 $
+ * $Revision: 1.145 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -73,6 +73,7 @@ extern void emgd_set_real_dispatch(igd_dispatch_t *drm_dispatch);
 extern void emgd_modeset_init(struct drm_device *dev);
 extern void emgd_modeset_destroy(struct drm_device *dev);
 extern int  msvdx_pre_init_plb(struct drm_device *dev);
+extern int msvdx_shutdown_plb(igd_context_t *context);
 extern emgd_drm_config_t config_drm;
 extern int context_count;
 
@@ -378,6 +379,7 @@ static struct drm_ioctl_desc emgd_ioctl[] = {
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_GET_CHIPSET_INFO, emgd_get_chipset_info,
 		DRM_MASTER),
 	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_DIHCLONE_SET_SURFACE, emgd_dihclone_set_surface, DRM_MASTER),
+	EMGD_IOCTL_DEF(DRM_IOCTL_IGD_PREINIT_MMU, emgd_preinit_mmu, DRM_MASTER),
 
 	/*
 	 * For VIDEO (MSVDX/TOPAZ
@@ -698,7 +700,7 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 	unsigned char          *fb          = NULL;
 	int                     mode_flags = IGD_QUERY_LIVE_MODES;
 	unsigned long           temp_bg_color;
-
+	int temp_dc;
 	EMGD_TRACE_ENTER;
 
 
@@ -711,14 +713,12 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 		 *************************************/
 		if (-1 != drm_emgd_dc) {
 			/* Validate and potentially use the module parameter: */
-			EMGD_DEBUG("Value of module parameter \"dc\" = \"%d\"",
-				drm_emgd_dc);
-
-			if ((drm_emgd_dc == 1) || (drm_emgd_dc == 2) ||
-					(drm_emgd_dc == 8)) {
+			EMGD_DEBUG("Value of module parameter \"dc\" = \"%d\"", drm_emgd_dc);
+			if (IGD_DC_SINGLE(drm_emgd_dc) || IGD_DC_CLONE(drm_emgd_dc) ||
+				IGD_DC_VEXT(drm_emgd_dc) || IGD_DC_EXTENDED(drm_emgd_dc)) {
 				/* Use validated value to override compile-time value: */
 				config_drm.dc = drm_emgd_dc;
-			} else if (drm_emgd_dc == 4) {
+			} else if (IGD_DC_TWIN(drm_emgd_dc)) {
 				/* Use validated value to override compile-time value: */
 				EMGD_DEBUG("Module parameter \"dc\" contains unsupported value "
 						"%d.", drm_emgd_dc);
@@ -728,29 +728,28 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 			} else {
 				/* Use compile-time value: */
 				EMGD_ERROR("Module parameter \"dc\" contains invalid value "
-						"%d (must be 1, 2, or 8).", drm_emgd_dc);
+					"%d (must be 1, 2, 5 or 8).", drm_emgd_dc);
 				if (config_drm.dc == 4) {
 					EMGD_DEBUG("Compile-time setting for module parameter "
-						"\"dc\" contains unsupported value %d.",
-						config_drm.dc);
+						"\"dc\" contains unsupported value %d.", config_drm.dc);
 					EMGD_DEBUG("Overriding and making it 1 (single display).");
 
 					config_drm.dc = 1;
 				} else {
 					EMGD_ERROR("Will use compile-time setting %d instead "
-							"of invalid value %d.\n",
-							config_drm.dc, drm_emgd_dc);
+						"of invalid value %d.\n", config_drm.dc, drm_emgd_dc);
 				}
 				drm_emgd_dc = config_drm.dc;
 			}
 		} else {
 			/* Check and potentially use the compile-time value: */
-			if ((config_drm.dc == 1) || (config_drm.dc == 2) ||
-					(config_drm.dc == 8)) {
+			if (IGD_DC_SINGLE(config_drm.dc) || IGD_DC_CLONE(config_drm.dc) ||
+				IGD_DC_VEXT(config_drm.dc) ||
+				IGD_DC_EXTENDED(config_drm.dc)) {
 				/* Report the compile-time value: */
 				EMGD_DEBUG("Using compile-time setting for the module parameter"
 						" \"dc\" = \"%d\"", config_drm.dc);
-			} else if (config_drm.dc == 4) {
+			} else if (IGD_DC_TWIN(config_drm.dc)) {
 				EMGD_DEBUG("Compile-time setting for module parameter "
 						"\"dc\" contains unsupported value %d.", config_drm.dc);
 				EMGD_DEBUG("Overriding and making it 1 (single display).");
@@ -758,7 +757,8 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 			} else {
 				EMGD_DEBUG("Compile-time setting for module parameter "
 						"\"dc\" contains invalid value %d.", config_drm.dc);
-				EMGD_DEBUG("Must be 1, 2, or 8. Making it 1 (single display).");
+				EMGD_DEBUG("Must be 1, 2, 5 or 8.  Making it 1 (single"
+						" display).");
 				config_drm.dc = 1;
 			}
 			drm_emgd_dc = config_drm.dc;
@@ -851,11 +851,21 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 		priv->secondary_port_number = IGD_DC_SECONDARY(priv->dc);
 	} else {
 
+		/**************************************************************************
+		 * Special case handling: Since HAL doesn't know anything about Vertical
+		 * extended mode, if we are in Vertical Extended (5), send HAL asking for
+		 * (2)
+		 *************************************************************************/
+		temp_dc = drm_emgd_dc;
+		if(IGD_DC_VEXT(drm_emgd_dc)) {
+			temp_dc = IGD_DISPLAY_CONFIG_CLONE;
+		}
+
 		/*************************************
 		 * Query the DC list (use first one):
 		 *************************************/
 		EMGD_DEBUG("Calling query_dc()");
-		err = drm_HAL_dispatch->query_dc(drm_HAL_handle, drm_emgd_dc,
+		err = drm_HAL_dispatch->query_dc(drm_HAL_handle, temp_dc,
 				&desired_dc, IGD_QUERY_DC_INIT);
 		EMGD_DEBUG("query_dc() returned %d", err);
 		if (err) {
@@ -866,6 +876,10 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 		port_number = (*desired_dc & 0xf0) >> 4;
 		EMGD_DEBUG("Using DC 0x%lx with port number %d",
 				*desired_dc, port_number);
+		if(IGD_DC_VEXT(drm_emgd_dc)) {
+			drm_emgd_dc = (*desired_dc & ~IGD_DISPLAY_CONFIG_CLONE) |
+					IGD_DISPLAY_CONFIG_VEXT;
+		}
 
 		/*************************************
 		 * Query the mode list:
@@ -917,7 +931,15 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 		primary_fb_info   = kzalloc(sizeof(igd_framebuffer_info_t), GFP_KERNEL);
 		secondary_fb_info = kzalloc(sizeof(igd_framebuffer_info_t), GFP_KERNEL);
 		primary_fb_info->width = desired_mode->width;
-		primary_fb_info->height = desired_mode->height;
+
+		/*************************************
+		 * Special for Vertical Extended, double the height
+		 *************************************/
+		if(IGD_DC_VEXT(drm_emgd_dc)) {
+			primary_fb_info->height = desired_mode->height * 2;
+		} else {
+			primary_fb_info->height = desired_mode->height;
+		}
 		primary_fb_info->pixel_format = IGD_PF_ARGB32;
 		primary_fb_info->flags = 0;
 		primary_fb_info->allocated = 0;
@@ -947,6 +969,14 @@ void emgd_init_display(int merge_mod_params, drm_emgd_priv_t *priv)
 		priv->secondary_port_number = IGD_DC_SECONDARY(*desired_dc);
 
 		/*************************************
+		 * Special for Vertical Extended, pan the second display
+		 *************************************/
+		if(IGD_DC_VEXT(drm_emgd_dc)) {
+			drm_HAL_dispatch->pan_display(secondary, 0,
+					secondary_fb_info->height / 2);
+		}
+
+		/*************************************
 		 * Call get_display():
 		 *************************************/
 		EMGD_DEBUG("Calling get_display()");
@@ -1448,6 +1478,7 @@ int emgd_driver_unload(struct drm_device *dev)
 int emgd_driver_open(struct drm_device *dev, struct drm_file *priv)
 {
 	int ret = 0;
+	drm_emgd_priv_t *emgd_priv = dev->dev_private;
 
 	EMGD_TRACE_ENTER;
 
@@ -1464,6 +1495,12 @@ int emgd_driver_open(struct drm_device *dev, struct drm_file *priv)
 	 */
 	mutex_lock(&dev->struct_mutex);
 
+	/* The is_master flag is set after the call to this function, so there needs
+	 * to be manual check to determine the DRM master */
+	if(priv->is_master || (!priv->minor->master && !emgd_priv->drm_master_fd)) {
+		emgd_priv->drm_master_fd = priv;
+	}
+
 	ret = PVRSRVOpen(dev, priv);
 
 	mutex_unlock(&dev->struct_mutex);
@@ -1590,6 +1627,7 @@ void emgd_driver_lastclose(struct drm_device *dev)
 				EMGD_DEBUG("State of saved registers is X_SERVER_STATE_SAVED");
 				priv->saved_registers = CONSOLE_STATE_SAVED;
 			}
+			msvdx_shutdown_plb(drm_HAL_handle);
 			igd_driver_shutdown_hal(drm_HAL_handle);
 			igd_driver_shutdown(drm_HAL_handle);
 
@@ -1720,6 +1758,9 @@ void emgd_driver_preclose(struct drm_device *dev, struct drm_file *priv)
 		/* TODO - WRITE CODE THAT PUTS THE DISPLAY HW IN A KNOWN STATE/MODE */
 	}
 
+	if (emgd_priv->drm_master_fd == priv)
+		emgd_priv->drm_master_fd = NULL;
+
 	mutex_unlock(&dev->struct_mutex);
 	EMGD_TRACE_EXIT;
 
diff --git a/drivers/staging/emgd/emgd/drm/emgd_drv.h b/drivers/staging/emgd/emgd/drm/emgd_drv.h
index 79c64e3..c7e334a 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_drv.h
+++ b/drivers/staging/emgd/emgd/drm/emgd_drv.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drv.h
- * $Revision: 1.75 $
+ * $Revision: 1.76 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -188,6 +188,8 @@ int emgd_video_get_info(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_video_flush_tlb(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
+int emgd_preinit_mmu(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv);
 int emgd_get_golden_htotal(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 int emgd_control_plane_format(struct drm_device *dev, void *arg,
diff --git a/drivers/staging/emgd/emgd/drm/emgd_interface.c b/drivers/staging/emgd/emgd/drm/emgd_interface.c
index 825625a..d3857a7 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_interface.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_interface.c
@@ -1,6 +1,6 @@
 /*-----------------------------------------------------------------------------
  * Filename: emgd_interface.c
- * $Revision: 1.183 $
+ * $Revision: 1.186 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -241,9 +241,31 @@ int emgd_alter_displays(struct drm_device *dev, void *arg,
 {
 	emgd_drm_alter_displays_t *drm_data = arg;
 	drm_emgd_priv_t *priv = dev->dev_private;
+	int temp_dc = drm_data->dc;
 
 	EMGD_TRACE_ENTER;
 
+	/*
+	 * If we are in Vertical Extended mode and the caller's dc is also
+	 * Vertical Extended, then set it to Clone instead as our HAL doesn't
+	 * know anything about Vertical Extended mode.
+	 */
+	if(IGD_DC_VEXT(drm_data->dc)) {
+		temp_dc = (drm_data->dc & ~IGD_DISPLAY_CONFIG_MASK) |
+				IGD_DISPLAY_CONFIG_CLONE;
+		if (drm_data->primary_fb_info.height ==
+			drm_data->secondary_fb_info.height) {
+			if(drm_data->primary_pt_info.height ==
+					drm_data->primary_fb_info.height) {
+				drm_data->primary_fb_info.height *= 2;
+			}
+
+			if(drm_data->secondary_pt_info.height ==
+					drm_data->secondary_fb_info.height) {
+				drm_data->secondary_fb_info.height *= 2;
+			}
+		}
+	}
 
 	/* Call the HAL: */
 	drm_data->rtn = dispatch->alter_displays(handle,
@@ -257,10 +279,17 @@ int emgd_alter_displays(struct drm_device *dev, void *arg,
 		&(drm_data->secondary),
 		&(drm_data->secondary_pt_info),
 		&(drm_data->secondary_fb_info),
-		drm_data->dc,
+		temp_dc,
 		drm_data->flags);
 
 	if (!drm_data->rtn) {
+		/*
+		 * Special for Vertical Extended, pan the second display
+		 */
+		if(IGD_DC_VEXT(drm_emgd_dc) && IGD_DC_VEXT(drm_data->dc)) {
+			dispatch->pan_display(drm_data->secondary, 0,
+					drm_data->secondary_fb_info.height / 2);
+		}
 		/* Communicate the new info to the IMG 3rd-party display driver: */
 		priv->dc = drm_data->dc;
 		priv->primary = drm_data->primary;
@@ -708,7 +737,12 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 	 */
 	if(mode_context->seamless && !(IGD_DC_CLONE(dc) && port_num == priv->secondary_port_number)) {
 		if (priv->reinit_3dd) {
-			priv->dc = *(context->mod_dispatch.dsp_current_dc);
+			if(IGD_DC_VEXT(drm_emgd_dc)) {
+				priv->dc = drm_emgd_dc;
+			} else {
+				priv->dc = *(context->mod_dispatch.dsp_current_dc);
+			}
+			EMGD_DEBUG("priv->dc = 0x%lX", priv->dc);
 			priv->primary = drm_data->display_handle;
 			priv->secondary = NULL;
 			priv->primary_port_number = (priv->dc & 0xf0) >> 4;
@@ -1507,6 +1541,7 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 	igd_display_context_t *display;
 	igd_surface_t surf;
 	unsigned long dc ;
+	unsigned long x_offset, y_offset;
 
 	EMGD_TRACE_ENTER;
 
@@ -1541,38 +1576,53 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 
 	/*reverting back to DIH from fake clone */
 	if( drm_data->mode == DIH){
-		if(context->mod_dispatch.dih_clone_display == CLONE_PRIMARY) {
+		if (IGD_DC_VEXT(drm_emgd_dc)) {
+			/* Clone to VEXT */
+			x_offset = 0;
 
-			EMGD_DEBUG(" emgd_dihclone_set_surface: setting DIH1");
-			surf.offset = pipe1->plane->fb_info->fb_base_offset;
-			/* Call the HAL: */
-			drm_data->rtn = dispatch->set_surface(display,
-				IGD_PRIORITY_NORMAL,
-				IGD_BUFFER_DISPLAY,
-				&surf,
-				NULL,
-				0);
-
-			if(drm_data->rtn) {
-				EMGD_ERROR(" emgd_dihclone_set_surface1: failed");
-				return -IGD_ERROR_INVAL;
-			}
+			y_offset = 0;
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
+			/* Call pan display to revert Primary to VEXT */
+			drm_data->rtn = dispatch->pan_display(display, x_offset, y_offset);
+
+			y_offset = (pipe1->plane->fb_info->height / 2);
 			display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
-			surf.offset = pipe2->plane->fb_info->saved_offset;
-			/* Call the HAL: */
-			drm_data->rtn = dispatch->set_surface(display,
-					IGD_PRIORITY_NORMAL,
-					IGD_BUFFER_DISPLAY,
-					&surf,
-					NULL,
-					0);
-			if(drm_data->rtn) {
-				EMGD_ERROR(" emgd_dihclone_set_surface2: failed");
-				return -IGD_ERROR_INVAL;
-			}
+			/* Call pan_display to revert Secondary to VEXT */
+			drm_data->rtn = dispatch->pan_display(display, x_offset, y_offset);
+		}else {/* in DIH mode */
+
+			if(context->mod_dispatch.dih_clone_display == CLONE_PRIMARY) {
+
+				EMGD_DEBUG(" emgd_dihclone_set_surface: setting DIH1");
+				surf.offset = pipe1->plane->fb_info->fb_base_offset;
+				/* Call the HAL: */
+				drm_data->rtn = dispatch->set_surface(display,
+						IGD_PRIORITY_NORMAL,
+						IGD_BUFFER_DISPLAY,
+						&surf,
+						NULL,
+						0);
+
+				if(drm_data->rtn) {
+					EMGD_ERROR(" emgd_dihclone_set_surface1: failed");
+					return -IGD_ERROR_INVAL;
+				}
+				display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+				surf.offset = pipe2->plane->fb_info->saved_offset;
+				/* Call the HAL: */
+				drm_data->rtn = dispatch->set_surface(display,
+						IGD_PRIORITY_NORMAL,
+						IGD_BUFFER_DISPLAY,
+						&surf,
+						NULL,
+						0);
+				if(drm_data->rtn) {
+					EMGD_ERROR(" emgd_dihclone_set_surface2: failed");
+					return -IGD_ERROR_INVAL;
+				}
 
 
-		} else { // if secondary clone
+			} else { // if secondary clone
 
 				EMGD_DEBUG(" emgd_dihclone_set_surface: setting DIH2");
 				surf.offset = pipe1->plane->fb_info->saved_offset;
@@ -1589,15 +1639,84 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 				drm_data->rtn = dispatch->set_surface(display,
 						IGD_PRIORITY_NORMAL,
 						IGD_BUFFER_DISPLAY,
-				&surf,
-				NULL,
-				0);
+						&surf,
+						NULL,
+						0);
 
+			}
+		}
+		if (drm_data->rtn == 0) {
+			context->mod_dispatch.in_dih_clone_mode = false;
 		}
+	}
+	/* setting fake clone (dih clone) mode */
+	if (drm_data->mode == CLONE) {
+		if (IGD_DC_VEXT(drm_emgd_dc)) {
+			x_offset = 0;
 
-		context->mod_dispatch.in_dih_clone_mode = false;
-		return 0;
+			if( drm_data->dih_clone_display == CLONE_PRIMARY){
+				y_offset = 0;
+				display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+			} else {
+				y_offset = (pipe1->plane->fb_info->height / 2);
+				display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
+			}
 
+			/* Call Pan display to affect pt_info offsets */
+			drm_data->rtn = dispatch->pan_display(display, x_offset, y_offset);
+		} else { /* in DIH mode */
+
+			/*first save the display's original offset  */
+			surf.offset = pipe1->plane->fb_info->fb_base_offset;
+			drm_data->rtn = dispatch->set_surface(display,
+					IGD_PRIORITY_NORMAL,
+					IGD_BUFFER_SAVE,
+					&surf,
+					NULL,
+					0);
+
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+			surf.offset = pipe2->plane->fb_info->fb_base_offset;
+			drm_data->rtn = dispatch->set_surface(display,
+					IGD_PRIORITY_NORMAL,
+					IGD_BUFFER_SAVE,
+					&surf,
+					NULL,
+					0);
+
+
+			/* primary display */
+			if( drm_data->dih_clone_display == CLONE_PRIMARY){
+				surf.offset = pipe1->plane->fb_info->fb_base_offset;
+			} else {
+				surf.offset = pipe2->plane->fb_info->fb_base_offset;
+			}
+
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
+
+			/* Call the HAL: */
+			drm_data->rtn = dispatch->set_surface(display,
+					IGD_PRIORITY_NORMAL,
+					IGD_BUFFER_DISPLAY,
+					&surf,
+					NULL,
+					0);
+
+			/* secondary display */
+			display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
+
+			drm_data->rtn = dispatch->set_surface(display,
+					IGD_PRIORITY_NORMAL,
+					IGD_BUFFER_DISPLAY,
+					&surf,
+					NULL,
+					0);
+
+		}
+		if(drm_data->rtn == 0){
+			context->mod_dispatch.in_dih_clone_mode = true;
+			context->mod_dispatch.dih_clone_display = drm_data->dih_clone_display;
+		}
 	}
 
 
@@ -1860,6 +1979,14 @@ int emgd_driver_pre_init(struct drm_device *dev, void *arg,
 		mode_context->splash = x_params->qb_splash;
 		mode_context->first_alter = TRUE;
 
+		if (config_drm.init) {
+			for (i=0; i < IGD_MAX_PORTS; i++) {
+				mode_context->batch_blits[x_params->display_params[i].port_number - 1]
+					= x_params->display_params[i].flags & IGD_DISPLAY_BATCH_BLITS;
+			}
+			toggle_vblank_interrupts(TRUE);
+		}
+
 		/* In case the X server ran, exited, and is starting again, we may need
 		 * to put the X server's state back:
 		 */
@@ -2295,6 +2422,9 @@ int emgd_init_video(struct drm_device *dev, void *arg,
 	case CMD_VIDEO_INITIALIZE :
 		/* Call the HAL: */
 		switch (drm_data->engine) {
+		case PSB_ENGINE_COMPOSITOR_MMU:
+			drm_data->rtn = msvdx_init_compositor_mmu(drm_data->base0);
+			break;
 		case PSB_ENGINE_VIDEO:
 			drm_data->rtn = msvdx_init_plb(drm_data->base0, drm_data->base1,
 						       drm_data->fw_priv, drm_data->fw_size, 0);
@@ -2423,6 +2553,20 @@ int emgd_video_flush_tlb(struct drm_device *dev, void *arg,
 	return 0;
 }
 
+int emgd_preinit_mmu(struct drm_device *dev, void *arg,
+			struct drm_file *file_priv)
+{
+	emgd_drm_preinit_mmu_t *drm_data = arg;
+
+	EMGD_TRACE_ENTER;
+
+	drm_data->rtn = msvdx_preinit_mmu(drm_data->memcontext);
+
+	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
 int emgd_get_golden_htotal(struct drm_device *dev, void *arg,
 		struct drm_file *file_priv){
 
diff --git a/drivers/staging/emgd/emgd/drm/user_config.c b/drivers/staging/emgd/emgd/drm/user_config.c
index cea78e1..6729e7b 100644
--- a/drivers/staging/emgd/emgd/drm/user_config.c
+++ b/drivers/staging/emgd/emgd/drm/user_config.c
@@ -218,7 +218,7 @@ igd_param_t *config_params = {&config_params_config1};
  * for the EMGD kernel module.
  */
 emgd_drm_config_t config_drm = {
-	0,	/* Whether to initialize the display at EMGD module startup time
+	1,	/* Whether to initialize the display at EMGD module startup time
 		 * (corresponds to the "init" module parameter)
 		 */
 	1,	/* The display configuration to use if initializing the display
@@ -238,7 +238,7 @@ emgd_drm_config_t config_drm = {
 	60,	/* Display refresh rate to use if initializing the display
 		 * (corresponds to the "refresh" module parameter)
 		 */
-	0,  /* KMS */
+	1,  /* KMS */
 	0,	/* ovl_brightness */
 	0,	/* ovl_contrast */
 	0,	/* ovl_saturation */
diff --git a/drivers/staging/emgd/emgd/include/displayid.h b/drivers/staging/emgd/emgd/include/displayid.h
index effc4c9..82a995f 100644
--- a/drivers/staging/emgd/emgd/include/displayid.h
+++ b/drivers/staging/emgd/emgd/include/displayid.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: displayid.h
- * $Revision: 1.9 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -378,6 +378,24 @@ typedef struct _type_std {
 #define CP_DTCP              0x2
 #define CP_DPCP              0x3  /* Display port content protection */
 
+/* Display physical orientation information */
+#define DEFAULT_ORIENTATION(a) 		((a & 0xC0) >> 6)
+#define ZERO_PIXEL(a) 				((a & 0x0C) >> 2)
+#define SCAN_DIRECTION(a) 			(a & 0x03)
+
+#define SCAN_DIRECTION_LONG 		0x1 /* Display scan direction (2 bits) */
+#define SCAN_DIRECTION_SHORT 		0x2
+
+#define ZP_UPPER_LEFT 				0x0 /* Zero pixel position (2 bits) */
+#define ZP_UPPER_RIGHT 				0x1
+#define ZP_LOWER_LEFT 				0x2
+#define ZP_LOWER_RIGHT 				0x3
+
+#define DEF_ORIENTATION_LANDSCAPE 	0x0 /* Default orientation (2 bits) */
+#define DEF_ORIENTATION_PORTRAIT 	0x1
+#define DEF_ORIENTATION_UNKNOWN 	0x2
+
+
 typedef struct _display_device {
 	unsigned char  tag;                /* data block type */
 	unsigned char  revision:3;
@@ -619,13 +637,14 @@ typedef struct _displayid {
 	pd_attr_t       attr_list[DISPLAYID_MAX_ATTRS];
 
 #ifndef CONFIG_MICRO
-	productid_t      productid;          /* product id block */
-	color_char_t     color_char;         /* color characteristics block */
-	serial_number_t  serial_num;         /* serial number ASCII string */
-	general_string_t general_string;     /* general purpose ASCII string */
-	transfer_char_t  transfer_char;      /* transfer characteristics block */
-	stereo_intf_t    stereo_intf;        /* stereo display interface */
-	vendor_t         vendor;             /* vendor specific data */
+	productid_t      		productid;       /* product id block */
+	color_char_t     		color_char;      /* color characteristics block */
+	serial_number_t  		serial_num;      /* serial number ASCII string */
+	general_string_t 		general_string;  /* general purpose ASCII string */
+	transfer_char_t  		transfer_char;   /* transfer characteristics block */
+	stereo_intf_t    		stereo_intf;     /* stereo display interface */
+	vendor_t 				vendor;          /* vendor specific data */
+	igd_DID_rotation_info_t rotation_info;   /* display orientation data */
 #endif
 } displayid_t;
 
diff --git a/drivers/staging/emgd/emgd/include/msvdx.h b/drivers/staging/emgd/emgd/include/msvdx.h
index 9107644..19ec924 100644
--- a/drivers/staging/emgd/emgd/include/msvdx.h
+++ b/drivers/staging/emgd/emgd/include/msvdx.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.h
- * $Revision: 1.19 $
+ * $Revision: 1.20 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -51,14 +51,28 @@ extern unsigned long _msvdx_base;
 #define PSB_MSVDX_MTX_RAM_ACCESS_CONTROL          (MSVDX_BASE + 0x0108)
 #define PSB_MSVDX_MTX_RAM_ACCESS_STATUS           (MSVDX_BASE + 0x010c)
 #define PSB_MSVDX_MTX_SOFT_RESET                  (MSVDX_BASE + 0x0200)
+#define PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_TIMERDIV_OFFSET (MSVDX_BASE + 0x0208)
+
+#define PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAC      (MSVDX_BASE + 0x0340)
+#define PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAA      (MSVDX_BASE + 0x0344)
+#define PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAS0     (MSVDX_BASE + 0x0348)
+#define PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAT      (MSVDX_BASE + 0x0350)
+
+#define PSB_MSVDX_DMAC_SETUP                      (MSVDX_BASE + 0x0500)
+#define PSB_MSVDX_DMAC_COUNT                      (MSVDX_BASE + 0x0504)
+#define PSB_MSVDX_DMAC_PERIPH                     (MSVDX_BASE + 0x0508)
+#define PSB_MSVDX_DMAC_IRQ_STAT                   (MSVDX_BASE + 0x050c)
+#define PSB_MSVDX_DMAC_PERIPHERAL_ADDR            (MSVDX_BASE + 0x0514)
 /* MSVDX registers */
 #define PSB_MSVDX_CONTROL                         (MSVDX_BASE + 0x0600)
 #define PSB_MSVDX_INTERRUPT_STATUS                (MSVDX_BASE + 0x0608)
 #define PSB_MSVDX_INTERRUPT_CLEAR                 (MSVDX_BASE + 0x060c)
 #define PSB_MSVDX_HOST_INTERRUPT_ENABLE           (MSVDX_BASE + 0x0610)
 #define PSB_MSVDX_MAN_CLK_ENABLE                  (MSVDX_BASE + 0x0620)
+#define PSB_MSVDX_CORE_REV                        (MSVDX_BASE + 0x0640)
 #define PSB_MSVDX_MMU_CONTROL0                    (MSVDX_BASE + 0x0680)
 #define PSB_MSVDX_MMU_CONTROL1                    (MSVDX_BASE + 0x0684)
+#define PSB_MSVDX_MMU_BANK_INDEX                  (MSVDX_BASE + 0x0688)
 #define PSB_MSVDX_MMU_STATUS                      (MSVDX_BASE + 0x068c)
 #define PSB_MSVDX_MMU_DIR_LIST_BASE0              (MSVDX_BASE + 0x0694)
 #define PSB_MSVDX_MMU_DIR_LIST_BASE1              (MSVDX_BASE + 0x0698)
@@ -228,8 +242,10 @@ typedef struct msvdx_fw_ {
 
 int process_video_decode_plb(igd_context_t *context, unsigned long offset, void *virt_addr, unsigned long *fence_id);
 int msvdx_query_plb(igd_context_t *context, unsigned long *status);
+int msvdx_preinit_mmu(unsigned long hmemcxt);
 int msvdx_init_plb(unsigned long base0, unsigned long base1,
-		           void *msvdx_fw, unsigned long msvdx_fw_size, int reset_flag);
+           void *msvdx_fw, unsigned long msvdx_fw_size, int reset_flag);
+int msvdx_init_compositor_mmu(unsigned long mmu_base);
 int msvdx_uninit_plb(igd_context_t *context);
 int msvdx_close_context(igd_context_t *context);
 int msvdx_create_context(igd_context_t *context);
diff --git a/drivers/staging/emgd/emgd/include/plb/context.h b/drivers/staging/emgd/emgd/include/plb/context.h
index 01df47f..563c232 100644
--- a/drivers/staging/emgd/emgd/include/plb/context.h
+++ b/drivers/staging/emgd/emgd/include/plb/context.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: context.h
- * $Revision: 1.16 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -37,6 +37,7 @@
 #include <pci.h>
 #include <igd_render.h>
 #include <plb/sgx.h>
+#include <servicesint.h>
 /*
  * FIXME: Promote io_mapped/io_base to DI layer
  *
@@ -157,6 +158,8 @@ typedef struct _tnc_topaz_priv {
 	unsigned long wb_offset;
 } tnc_topaz_priv_t;
 
+struct msvdx_pvr_info;
+
 typedef struct _platform_context_plb {
 	int irq;
 	unsigned short did;
@@ -169,10 +172,19 @@ typedef struct _platform_context_plb {
 	os_pci_dev_t stgpiodev;
 	unsigned long rendec_base0;
 	unsigned long rendec_base1;
+	/*
+	 * Cached value of the SGX's PSB_CR_BIF_DIR_LIST_BASE1, which is
+	 * used to configure MSVDX MMU base 0.
+	 */
+	unsigned long psb_cr_bif_dir_list_base1;
 	int msvdx_needs_reset;
     spinlock_t msvdx_lock;
+    spinlock_t msvdx_init_plb;
+    unsigned long msvdx_status;
     int msvdx_busy;
     struct list_head msvdx_queue;
+	unsigned long msvdx_dash_access_ctrl;
+	struct msvdx_pvr_info *msvdx_pvr;
 	psb_sgx_priv_t sgx_priv_data;
 	tnc_topaz_priv_t tpz_private_data;
     unsigned long msvdx_fence;
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/Makefile.gnu b/drivers/staging/emgd/emgd/pal/ch7036/Makefile.gnu
index 83c4c89..3ea81d8 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/Makefile.gnu
+++ b/drivers/staging/emgd/emgd/pal/ch7036/Makefile.gnu
@@ -41,4 +41,3 @@ include ../Makefile.include
 # $Id: Makefile.gnu,v 1.1.2.1 2011/09/13 08:50:22 nanuar Exp $
 # $Source: /nfs/fm/proj/eia/cvsroot/koheo/linux.nonredistributable/ch7036/ch7036pd_src/Attic/Makefile.gnu,v $
 #----------------------------------------------------------------------------
-
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c
index b27825a..56a835b 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c
@@ -596,49 +596,49 @@ ch_bool DeviceRunning(DEV_CONTEXT* pDevContext)
        I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x0D);
 	   if((pPrefer_Info->eye_dri_pll_rlf >= 0) && (pPrefer_Info->eye_dri_pll_rlf <= 3))
- 	      reg = (reg & 0x9F) | (pPrefer_Info->eye_dri_pll_rlf << 5);
+	      reg = (reg & 0x9F) | (pPrefer_Info->eye_dri_pll_rlf << 5);
 	   I2CWrite(pDevContext,0x0D, reg);
 
 	   I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x0C);
 	   if((pPrefer_Info->eye_dri_pll_cp >= 0) && (pPrefer_Info->eye_dri_pll_cp <= 3))
- 	      reg = (reg & 0x3F) | (pPrefer_Info->eye_dri_pll_cp << 6);
+	      reg = (reg & 0x3F) | (pPrefer_Info->eye_dri_pll_cp << 6);
 	   I2CWrite(pDevContext,0x0C, reg);
 
 	   I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x0B);
 	   if((pPrefer_Info->eye_dri_damp >= 0) && (pPrefer_Info->eye_dri_damp <= 7))
- 	      reg = (reg & 0x1F) | (pPrefer_Info->eye_dri_damp << 5);
+	      reg = (reg & 0x1F) | (pPrefer_Info->eye_dri_damp << 5);
 	   I2CWrite(pDevContext,0x0B, reg);
 
        I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x0A);
 	   if((reg & 0x01)==0x00)
- 	      reg = (reg | 0x01);
+	      reg = (reg | 0x01);
 	   I2CWrite(pDevContext,0x0A, reg);
 
        I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x0A);
 	   if((pPrefer_Info->eye_dri_demp >= 0) && (pPrefer_Info->eye_dri_demp <= 15))
- 	      reg = (reg & 0xE1) | (pPrefer_Info->eye_dri_demp << 1);
+	      reg = (reg & 0xE1) | (pPrefer_Info->eye_dri_demp << 1);
 	   I2CWrite(pDevContext,0x0A, reg);
 
 	   I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x08);
 	   if((pPrefer_Info->eye_dacg >= 0) && (pPrefer_Info->eye_dacg <= 3))
- 	      reg = (reg & 0x3F) | (pPrefer_Info->eye_dacg << 6);
+	      reg = (reg & 0x3F) | (pPrefer_Info->eye_dacg << 6);
 	   I2CWrite(pDevContext,0x08, reg);
 
 	   I2CWrite(pDevContext,0x03, 0x01);
 	   reg = I2CRead(pDevContext,0x0F);
 	   if((pPrefer_Info->eye_rdac >= 0) && (pPrefer_Info->eye_rdac <= 7))
- 	      reg = (reg & 0xC7) | (pPrefer_Info->eye_rdac << 3);
+	      reg = (reg & 0xC7) | (pPrefer_Info->eye_rdac << 3);
 	   I2CWrite(pDevContext,0x0F, reg);
 
 	   I2CWrite(pDevContext,0x03, 0x04);
 	   reg = I2CRead(pDevContext,0x54);
 	   if((pPrefer_Info->eye_bgtrim >= 0) && (pPrefer_Info->eye_bgtrim <= 3))
- 	      reg = (reg & 0xF3) | (pPrefer_Info->eye_bgtrim << 2);
+	      reg = (reg & 0xF3) | (pPrefer_Info->eye_bgtrim << 2);
 	   I2CWrite(pDevContext,0x54, reg);
 
 
@@ -1145,7 +1145,7 @@ ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
 	else if((gcksel == 0x40)&&(tsten1 == 0x40)){
 	  for(pll1n1_div=1; pll1n1_div<=64; pll1n1_div<<=1)
 	  {
-	 	val_t = pInput_Info->rx_clk_khz / pll1n1_div;
+		val_t = pInput_Info->rx_clk_khz / pll1n1_div;
 	    if(val_t >= 2300 && val_t <= 4600)
 			break;
 	  }
@@ -1268,15 +1268,15 @@ ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
 		{
 			if((gcksel == 0x40)&&(tsten1 == 0x40)){
 				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
-	        	do_div(temp1 , pInput_Info->rx_clk_khz);
+			do_div(temp1 , pInput_Info->rx_clk_khz);
 				a1_reg = (uint32)temp1;
 			} else if((gcksel == 0x40)&&(tsten1 == 0x00)){
 				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
-	        	do_div(temp1 , (uint32)27000);
+			do_div(temp1 , (uint32)27000);
 				a1_reg = (uint32)temp1;
-	       	}else if((gcksel == 0x00)&&(tsten1 == 0x00)){
+		}else if((gcksel == 0x00)&&(tsten1 == 0x00)){
 				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
-	        	do_div(temp1 , (uint32)27000);
+			do_div(temp1 , (uint32)27000);
 				a1_reg = (uint32)temp1;
 			}
 		   iic_write_ex(A1, a1_reg);
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c
index ad4ba50..04ffa7f 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c
@@ -927,7 +927,3 @@ void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk)
 	}
 
 }
-
-
-
-
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c
index d439d66..94c708c 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c
@@ -497,6 +497,3 @@ void ch7036_dump( char *s, int size, unsigned char *regdata)
 
     return;
 }
-
-
-
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c
index 11cdcaa..b3e3331 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c
@@ -913,12 +913,3 @@ void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx, PREFER_INFO*
 
 
 }
-
-
-
-
-
-
-
-
-
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c
index 9e0a97a..e40fdc4 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c
@@ -1162,4 +1162,3 @@ int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
 
 	return PD_SUCCESS;
 }
-
diff --git a/drivers/staging/emgd/emgd/video/msvdx/msvdx.c b/drivers/staging/emgd/emgd/video/msvdx/msvdx.c
index 1300451..35a1300 100644
--- a/drivers/staging/emgd/emgd/video/msvdx/msvdx.c
+++ b/drivers/staging/emgd/emgd/video/msvdx/msvdx.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.c
- * $Revision: 1.25 $
+ * $Revision: 1.26 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -106,8 +106,7 @@ unsigned long save_msg_cnt;
  */
 unsigned long jiffies_at_last_dequeue = 0;
 
-int mtx_message_complete = 1;
-int msvdx_dequeue_send(igd_context_t *context) 
+int msvdx_dequeue_send(igd_context_t *context)
 {
     platform_context_plb_t *platform;
     struct msvdx_cmd_queue *msvdx_cmd = NULL;
@@ -179,13 +178,33 @@ int process_mtx_messages(igd_context_t *context,
 		unsigned long fence)
 {
 	unsigned char *mmio = context->device_context.virt_mmadr;
+	platform_context_plb_t *platform;
 	unsigned long submit_size;
 	unsigned long submit_id;
 	unsigned int msg;
 	unsigned long skipped_msg_cnt;
+    unsigned long msvdx_status;
 
 	EMGD_TRACE_ENTER;
 
+	platform = (platform_context_plb_t *)context->platform_context;
+
+    // message processing is about to start .. set the flag=bit 2
+    spin_lock(&platform->msvdx_init_plb);
+    platform->msvdx_status = platform->msvdx_status | 2;
+    msvdx_status = platform->msvdx_status;
+    spin_unlock(&platform->msvdx_init_plb);
+
+	if (msvdx_status & 1)
+	{
+	    // OOPS: reset/fw load in progress ... return from here
+        spin_lock(&platform->msvdx_init_plb);
+        platform->msvdx_status = platform->msvdx_status & ~2;  // unset message processing status.
+        spin_unlock(&platform->msvdx_init_plb);
+
+        return 0;
+    }
+
 	save_msg = mtx_msgs;
 	save_msg_cnt = mtx_msg_cnt;
 	skipped_msg_cnt = 0;
@@ -202,7 +221,7 @@ int process_mtx_messages(igd_context_t *context,
 		}
 
 		/* reuse the sgx phy PD */
-		mtx_msgs[1] = EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE1) | 1;
+		mtx_msgs[1] = platform->psb_cr_bif_dir_list_base1 | 1;
 
 		/*
 		 * If the send returns busy, then retry sending the message, otherwise
@@ -221,6 +240,11 @@ int process_mtx_messages(igd_context_t *context,
 		}
 	}
 
+    // We are done processing messages .. unset the flag
+	spin_lock(&platform->msvdx_init_plb);
+    platform->msvdx_status = platform->msvdx_status & ~2;
+    spin_unlock(&platform->msvdx_init_plb);
+
 	EMGD_TRACE_EXIT;
 	if (skipped_msg_cnt == mtx_msg_cnt) {
 		/* We failed to submit anything; the entire buffer was bad.
@@ -253,7 +277,6 @@ int send_to_mtx(igd_context_t *context, unsigned long *msg)
 	int padding_flag = 0;
 
 	EMGD_TRACE_ENTER;
-	mtx_message_complete = 0;
 
 	/* Enable all clocks before touching VEC local ram */
 	EMGD_WRITE32(PSB_CLK_ENABLE_ALL, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
@@ -448,13 +471,12 @@ void msvdx_mtx_interrupt_plb(igd_context_t *context)
 
 			EMGD_WRITE32(read_idx, mmio + PSB_MSVDX_COMMS_TO_HOST_RD_INDEX);
 
-			mtx_message_complete = 1;
 			/* Check message ID */
 			switch ((msg[0] & 0x0000ff00) >> 8) {
 			case IGD_MSGID_CMD_FAILED:
 				fence  = msg[1]; /* Fence value */
 				status = msg[2]; /* Failed IRQ Status */
-				printk(KERN_ERR "MSGID_CMD_FAILED, status = 0x%lx, "
+				printk(KERN_ERR "MSGID_CMD, status = 0x%lx, "
 					"fence = 0x%lx\n", status, fence);
 
 				/* This message from MTX is for informational purposes and
@@ -527,7 +549,7 @@ int msvdx_poll_mtx_irq(igd_context_t *context)
 	while (poll_cnt) {
 		status = EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
 		if (status & MSVDX_MMU_FAULT_IRQ_MASK) {
-			EMGD_ERROR("MMU FAULT Interrupt");
+			EMGD_DEBUG("MMU FAULT Interrupt");
 			/* Pause the MMU */
 			EMGD_WRITE32(MSVDX_MMU_CONTROL0_CR_MMU_PAUSE_MASK,
 					mmio + PSB_MSVDX_MMU_CONTROL0);
@@ -624,7 +646,7 @@ IMG_BOOL msvdx_mtx_isr(IMG_VOID *pvData)
     igd_context_t *context;
 	unsigned char *mmio;
 	platform_context_plb_t *platform;
-    unsigned long msvdx_stat;
+    unsigned long msvdx_stat,temp;
 
 	//EMGD_TRACE_ENTER;
     dev = (struct drm_device *)pvData;
@@ -638,7 +660,16 @@ IMG_BOOL msvdx_mtx_isr(IMG_VOID *pvData)
 	//printk(KERN_ALERT "MSVDX_IRQ\n");
 
 	if (msvdx_stat & MSVDX_MMU_FAULT_IRQ_MASK) {
-		printk(KERN_ERR "MMU FAULT Interrupt\n");
+		EMGD_DEBUG(KERN_ERR "MMU FAULT Interrupt\n");
+		EMGD_DEBUG(KERN_ERR "INTERRUPT_STATUS Register=0x%x\n",msvdx_stat);
+		temp = EMGD_READ32(mmio + PSB_MSVDX_MMU_DIR_LIST_BASE0);
+        EMGD_DEBUG(KERN_ERR "MMU_DIR_LIST_BASE0 = 0x%x\n", temp);
+		temp = EMGD_READ32(mmio + PSB_MSVDX_MMU_DIR_LIST_BASE1);
+		EMGD_DEBUG(KERN_ERR "MMU_DIR_LIST_BASE1 = 0x%x\n", temp);
+		temp = EMGD_READ32(mmio + PSB_MSVDX_MMU_DIR_LIST_BASE2);
+		EMGD_DEBUG(KERN_ERR "MMU_DIR_LIST_BASE2 = 0x%x\n", temp);
+		temp = EMGD_READ32(mmio + PSB_MSVDX_MMU_DIR_LIST_BASE3);
+		EMGD_DEBUG(KERN_ERR "MMU_DIR_LIST_BASE3 = 0x%x\n", temp);
 		/* Pause the MMU */
 		EMGD_WRITE32(MSVDX_MMU_CONTROL0_CR_MMU_PAUSE_MASK,
 				mmio + PSB_MSVDX_MMU_CONTROL0);
@@ -647,7 +678,7 @@ IMG_BOOL msvdx_mtx_isr(IMG_VOID *pvData)
 		EMGD_WRITE32(MSVDX_MMU_FAULT_IRQ_MASK,
 				mmio + PSB_MSVDX_INTERRUPT_CLEAR);
 
-		printk(KERN_INFO "FAULT ADDR=%x\n", EMGD_READ32(mmio + PSB_MSVDX_MMU_STATUS));
+		//printk(KERN_INFO "FAULT ADDR=%x\n", EMGD_READ32(mmio + PSB_MSVDX_MMU_STATUS));
 		platform->msvdx_needs_reset = 1;
 		DUMP_ALL_MESSAGES(context);
 		//return 0;
diff --git a/drivers/staging/emgd/emgd/video/msvdx/msvdx_init.c b/drivers/staging/emgd/emgd/video/msvdx/msvdx_init.c
index f01766f..5c03b3d 100644
--- a/drivers/staging/emgd/emgd/video/msvdx/msvdx_init.c
+++ b/drivers/staging/emgd/emgd/video/msvdx/msvdx_init.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_init.c
- * $Revision: 1.30 $
+ * $Revision: 1.31 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -64,11 +64,12 @@
 #include <drm/drm.h>
 #include <drm_emgd_private.h>
 #include <emgd_drm.h>
-
+#include <osfunc.h>  /* for OSFlushCPUCacheKM() */
+#include "msvdx_pvr.h"
 
 struct drm_device *gpDrmDevice = NULL;
 static int init_msvdx_first_time = 1;
-
+static unsigned long msvdx_compositor_mmu_base = 0;
 extern void send_to_mtx(igd_context_t *context, unsigned long *init_msg);
 extern int process_mtx_messages(igd_context_t *context,
 		unsigned long *mtx_msgs, unsigned long mtx_msg_cnt,
@@ -90,14 +91,648 @@ void msvdx_reset_plb(igd_context_t *context);
 static msvdx_fw_t *priv_fw = NULL;
 
 extern unsigned long jiffies_at_last_dequeue;
-extern int mtx_message_complete;
+static int msvdx_fw_dma_upload = 1;
+
+MODULE_PARM_DESC(msvdx_dma_upload, "MSVDX: upload firmware using DMA");
+module_param_named(msvdx_dma_upload, msvdx_fw_dma_upload, int, 0600);
+unsigned long LastClockState;
+
+///// HHP TODO: Move to separate .h file
+#define MSVDX_MTX_DEBUG      PSB_MSVDX_MTX_RAM_BANK
+
+#define MSVDX_MTX_DEBUG_MTX_DBG_IS_SLAVE_MASK            (0x00000004)
+#define MSVDX_MTX_DEBUG_MTX_DBG_IS_SLAVE_LSBMASK         (0x00000001)
+#define MSVDX_MTX_DEBUG_MTX_DBG_IS_SLAVE_SHIFT           (2)
+
+#define MSVDX_MTX_DEBUG_MTX_DBG_GPIO_IN_MASK             (0x00000003)
+#define MSVDX_MTX_DEBUG_MTX_DBG_GPIO_IN_LSBMASK          (0x00000003)
+#define MSVDX_MTX_DEBUG_MTX_DBG_GPIO_IN_SHIFT            (0)
+
+
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_BURSTSIZE_MASK        (0x07000000)
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_BURSTSIZE_SHIFT       (24)
+
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_RNW_MASK              (0x00020000)
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_RNW_SHIFT             (17)
+
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_ENABLE_MASK           (0x00010000)
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_ENABLE_SHIFT          (16)
+
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_LENGTH_MASK           (0x0000FFFF)
+#define MTX_CORE_CR_MTX_SYSC_CDMAC_LENGTH_SHIFT          (0)
+
+//#define MSVDX_CORE_CR_MSVDX_CONTROL_DMAC_CH0_SELECT_MASK   (0x00001000)
+//#define MSVDX_CORE_CR_MSVDX_CONTROL_DMAC_CH0_SELECT_SHIFT  (12)
+
+#define PSB_MSVDX_CONTROL_DMAC_CH0_SELECT_MASK           (0x00001000)
+#define PSB_MSVDX_CONTROL_DMAC_CH0_SELECT_SHIFT          (12)
+
+
+#define DMAC_DMAC_COUNT_BSWAP_LSBMASK                    (0x00000001)
+#define DMAC_DMAC_COUNT_BSWAP_SHIFT                      (30)
+
+#define DMAC_DMAC_COUNT_PW_LSBMASK                       (0x00000003)
+#define DMAC_DMAC_COUNT_PW_SHIFT                         (27)
+
+#define DMAC_DMAC_COUNT_DIR_LSBMASK                      (0x00000001)
+#define DMAC_DMAC_COUNT_DIR_SHIFT                        (26)
+
+#define DMAC_DMAC_COUNT_PI_LSBMASK                       (0x00000003)
+#define DMAC_DMAC_COUNT_PI_SHIFT                         (24)
+
+#define DMAC_DMAC_COUNT_EN_MASK                          (0x00010000)
+#define DMAC_DMAC_COUNT_EN_SHIFT                         (16)
+
+#define DMAC_DMAC_COUNT_CNT_LSBMASK                      (0x0000FFFF)
+#define DMAC_DMAC_COUNT_CNT_SHIFT                        (0)
+
+
+#define DMAC_DMAC_PERIPH_ACC_DEL_LSBMASK                 (0x00000007)
+#define DMAC_DMAC_PERIPH_ACC_DEL_SHIFT                   (29)
+
+#define DMAC_DMAC_PERIPH_INCR_LSBMASK                    (0x00000001)
+#define DMAC_DMAC_PERIPH_INCR_SHIFT                      (27)
+
+#define DMAC_DMAC_PERIPH_BURST_LSBMASK                   (0x00000007)
+#define DMAC_DMAC_PERIPH_BURST_SHIFT                     (24)
+
+#define DMAC_DMAC_PERIPHERAL_ADDR_ADDR_MASK              (0x007FFFFF)
+#define DMAC_DMAC_PERIPHERAL_ADDR_ADDR_LSBMASK           (0x007FFFFF)
+#define DMAC_DMAC_PERIPHERAL_ADDR_ADDR_SHIFT             (0)
+
+
+#define DMAC_DMAC_IRQ_STAT_TRANSFER_FIN_MASK             (0x00020000)
+
+/*watch dog for FE and BE*/
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_OFFSET		(MSVDX_BASE + 0x0064)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CNT_CTRL
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CNT_CTRL_MASK		(0x00060000)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CNT_CTRL_LSBMASK		(0x00000003)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CNT_CTRL_SHIFT		(17)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_CONTROL, FE_WDT_ENABLE
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ENABLE_MASK		(0x00010000)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ENABLE_LSBMASK		(0x00000001)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ENABLE_SHIFT		(16)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_CONTROL, FE_WDT_ACTION1
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ACTION1_MASK		(0x00003000)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ACTION1_LSBMASK		(0x00000003)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ACTION1_SHIFT		(12)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_CONTROL, FE_WDT_ACTION0
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ACTION0_MASK		(0x00000100)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ACTION0_LSBMASK		(0x00000001)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_ACTION0_SHIFT		(8)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CLEAR_SELECT
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CLEAR_SELECT_MASK		(0x00000030)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CLEAR_SELECT_LSBMASK		(0x00000003)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CLEAR_SELECT_SHIFT		(4)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CLKDIV_SELECT
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CLKDIV_SELECT_MASK		(0x00000007)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CLKDIV_SELECT_LSBMASK		(0x00000007)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_FE_WDT_CLKDIV_SELECT_SHIFT		(0)
+
+#define MSVDX_CORE_CR_FE_MSVDX_WDTIMER_OFFSET		(MSVDX_BASE + 0x0068)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDTIMER, FE_WDT_COUNTER
+#define MSVDX_CORE_CR_FE_MSVDX_WDTIMER_FE_WDT_COUNTER_MASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_FE_MSVDX_WDTIMER_FE_WDT_COUNTER_LSBMASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_FE_MSVDX_WDTIMER_FE_WDT_COUNTER_SHIFT		(0)
+
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_OFFSET		(MSVDX_BASE + 0x006C)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_COMPAREMATCH, FE_WDT_CM1
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_FE_WDT_CM1_MASK		(0xFFFF0000)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_FE_WDT_CM1_LSBMASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_FE_WDT_CM1_SHIFT		(16)
+
+// MSVDX_CORE, CR_FE_MSVDX_WDT_COMPAREMATCH, FE_WDT_CM0
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_FE_WDT_CM0_MASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_FE_WDT_CM0_LSBMASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_FE_WDT_CM0_SHIFT		(0)
+
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_OFFSET		(MSVDX_BASE + 0x0070)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CNT_CTRL
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CNT_CTRL_MASK		(0x001E0000)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CNT_CTRL_LSBMASK		(0x0000000F)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CNT_CTRL_SHIFT		(17)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDT_CONTROL, BE_WDT_ENABLE
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_ENABLE_MASK		(0x00010000)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_ENABLE_LSBMASK		(0x00000001)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_ENABLE_SHIFT		(16)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDT_CONTROL, BE_WDT_ACTION0
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_ACTION0_MASK		(0x00000100)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_ACTION0_LSBMASK		(0x00000001)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_ACTION0_SHIFT		(8)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CLEAR_SELECT
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CLEAR_SELECT_MASK		(0x000000F0)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CLEAR_SELECT_LSBMASK		(0x0000000F)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CLEAR_SELECT_SHIFT		(4)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CLKDIV_SELECT
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CLKDIV_SELECT_MASK		(0x00000007)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CLKDIV_SELECT_LSBMASK		(0x00000007)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_BE_WDT_CLKDIV_SELECT_SHIFT		(0)
+
+#define MSVDX_CORE_CR_BE_MSVDX_WDTIMER_OFFSET		(MSVDX_BASE + 0x0074)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDTIMER, BE_WDT_COUNTER
+#define MSVDX_CORE_CR_BE_MSVDX_WDTIMER_BE_WDT_COUNTER_MASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_BE_MSVDX_WDTIMER_BE_WDT_COUNTER_LSBMASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_BE_MSVDX_WDTIMER_BE_WDT_COUNTER_SHIFT		(0)
+
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_OFFSET		(MSVDX_BASE + 0x0078)
+
+// MSVDX_CORE, CR_BE_MSVDX_WDT_COMPAREMATCH, BE_WDT_CM0
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_BE_WDT_CM0_MASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_BE_WDT_CM0_LSBMASK		(0x0000FFFF)
+#define MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_BE_WDT_CM0_SHIFT		(0)
+/*watch dog end*/
+
+enum {
+	MSVDX_DMAC_BSWAP_NO_SWAP = 0x0, /* No byte swapping will be performed */
+	MSVDX_DMAC_BSWAP_REVERSE = 0x1, /* Byte order will be reversed */
+};
+
+enum {
+	MSVDX_DMAC_DIR_MEM_TO_PERIPH = 0x0, /* Data from memory to peripheral */
+	MSVDX_DMAC_DIR_PERIPH_TO_MEM = 0x1, /* Data from peripheral to memory */
+};
+
+enum {
+	MSVDX_DMAC_ACC_DEL_0    = 0x0, /* Access delay zero clock cycles */
+	MSVDX_DMAC_ACC_DEL_256  = 0x1, /* Access delay 256 clock cycles */
+	MSVDX_DMAC_ACC_DEL_512  = 0x2, /* Access delay 512 clock cycles */
+	MSVDX_DMAC_ACC_DEL_768  = 0x3, /* Access delay 768 clock cycles */
+	MSVDX_DMAC_ACC_DEL_1024 = 0x4, /* Access delay 1024 clock cycles */
+	MSVDX_DMAC_ACC_DEL_1280 = 0x5, /* Access delay 1280 clock cycles */
+	MSVDX_DMAC_ACC_DEL_1536 = 0x6, /* Access delay 1536 clock cycles */
+	MSVDX_DMAC_ACC_DEL_1792 = 0x7, /* Access delay 1792 clock cycles */
+};
+
+enum {
+	MSVDX_DMAC_INCR_OFF  = 0x0, /* Static peripheral address */
+	MSVDX_DMAC_INCR_ON   = 0x1, /* Incrementing peripheral address */
+};
+
+enum {
+	MSVDX_DMAC_BURST_0   = 0x0, /* burst size of 0 */
+	MSVDX_DMAC_BURST_1   = 0x1, /* burst size of 1 */
+	MSVDX_DMAC_BURST_2   = 0x2, /* burst size of 2 */
+	MSVDX_DMAC_BURST_3   = 0x3, /* burst size of 3 */
+	MSVDX_DMAC_BURST_4   = 0x4, /* burst size of 4 */
+	MSVDX_DMAC_BURST_5   = 0x5, /* burst size of 5 */
+	MSVDX_DMAC_BURST_6   = 0x6, /* burst size of 6 */
+	MSVDX_DMAC_BURST_7   = 0x7, /* burst size of 7 */
+};
+
+/* DMAC control */
+#define MSVDX_DMAC_VALUE_COUNT(BSWAP,PW,DIR,PERIPH_INCR,COUNT) \
+	(((BSWAP) & DMAC_DMAC_COUNT_BSWAP_LSBMASK) << DMAC_DMAC_COUNT_BSWAP_SHIFT) | \
+	(((PW)    & DMAC_DMAC_COUNT_PW_LSBMASK)    << DMAC_DMAC_COUNT_PW_SHIFT)    | \
+	(((DIR)   & DMAC_DMAC_COUNT_DIR_LSBMASK)   << DMAC_DMAC_COUNT_DIR_SHIFT)   | \
+	(((PERIPH_INCR) & DMAC_DMAC_COUNT_PI_LSBMASK) << DMAC_DMAC_COUNT_PI_SHIFT) | \
+	(((COUNT) & DMAC_DMAC_COUNT_CNT_LSBMASK)   << DMAC_DMAC_COUNT_CNT_SHIFT)
+
+#define MSVDX_DMAC_VALUE_PERIPH_PARAM(ACC_DEL,INCR,BURST) \
+	(((ACC_DEL) & DMAC_DMAC_PERIPH_ACC_DEL_LSBMASK) << DMAC_DMAC_PERIPH_ACC_DEL_SHIFT) | \
+	(((INCR)    & DMAC_DMAC_PERIPH_INCR_LSBMASK)    << DMAC_DMAC_PERIPH_INCR_SHIFT)    | \
+	(((BURST)   & DMAC_DMAC_PERIPH_BURST_LSBMASK)   << DMAC_DMAC_PERIPH_BURST_SHIFT)
+
+
+
+#define REGIO_READ_FIELD(reg_val, reg, field)                           \
+        ((reg_val & reg##_##field##_MASK) >> reg##_##field##_SHIFT)
+
+#define REGIO_WRITE_FIELD(reg_val, reg, field, value)                   \
+        (reg_val) =                                                     \
+                ((reg_val) & ~(reg##_##field##_MASK)) |                 \
+               (((value) << (reg##_##field##_SHIFT)) & (reg##_##field##_MASK));
+
+#define REGIO_WRITE_FIELD_LITE(reg_val, reg, field, value)              \
+        (reg_val) =                                                     \
+                ((reg_val) | ((value) << (reg##_##field##_SHIFT)));
+
+#define STACKGUARDWORD (0x10101010)
+
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_CORE_MAN_CLK_ENABLE_MASK	\
+	(0x00000001)
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_VDEB_PROCESS_MAN_CLK_ENABLE_MASK \
+	(0x00000002)
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_VDEB_ACCESS_MAN_CLK_ENABLE_MASK \
+	(0x00000004)
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_VDMC_MAN_CLK_ENABLE_MASK	\
+	(0x00000008)
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_VEC_ENTDEC_MAN_CLK_ENABLE_MASK \
+	(0x00000010)
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_VEC_ITRANS_MAN_CLK_ENABLE_MASK \
+	(0x00000020)
+#define MSVDX_CORE_CR_MSVDX_MAN_CLK_ENABLE_CR_MTX_MAN_CLK_ENABLE_MASK	\
+	(0x00000040)
+
+
+
+int msvdx_init_compositor_mmu(unsigned long mmu_base) {
+	msvdx_compositor_mmu_base = mmu_base;
+	return 0;
+}
+
+/*
+ * Map and copy the firmware image to the shared SGX heap.
+ */
+static int msvdx_map_fw(uint32_t size)
+{
+	drm_emgd_priv_t       *priv;
+	igd_context_t          *context;
+	platform_context_plb_t *platform;
+	PVRSRV_KERNEL_MEM_INFO *mem_info;
+	unsigned long alloc_size;
+	uint32_t *last_word;
+	void     *mapped_fw_addr;
+
+	priv     = gpDrmDevice->dev_private;
+	context  = priv->context;
+    platform = (platform_context_plb_t *)context->platform_context;
+
+	/* Round up as DMA's can overrun a page */
+	alloc_size = (size + 8192) & ~0x0fff;
+
+	mem_info = platform->msvdx_pvr->fw_mem_info;
+	if (!mem_info) {
+		mem_info = msvdx_pvr_alloc_devmem(alloc_size, "MSVDX firmware");
+		if (!mem_info) {
+			printk(KERN_ERR "[EMGD] MSVDX: Failed to allocate %u "
+				"bytes from SGX heap\n",
+				(unsigned int)alloc_size);
+			return -ENOMEM;
+		}
+		platform->msvdx_pvr->fw_mem_info = mem_info;
+	}
+
+	mapped_fw_addr = (unsigned long *)mem_info->pvLinAddrKM;
+
+	memset(mapped_fw_addr, 0x00, size);
+
+	memcpy(mapped_fw_addr, priv_fw->fw_text, priv_fw->fw_text_size * 4);
+
+	memcpy(mapped_fw_addr + (priv_fw->fw_data_location - MTX_DATA_BASE),
+		priv_fw->fw_data, priv_fw->fw_data_size * 4);
+
+	/*
+	 * Write a known value to the last word in MTX memory. Useful for
+	 * detection of stack overruns.
+	 */
+	last_word = (uint32_t *)(mapped_fw_addr + size - sizeof(uint32_t));
+	*last_word = STACKGUARDWORD;
+
+	OSFlushCPUCacheRangeKM(mapped_fw_addr, mapped_fw_addr + size);
+
+	return 0;
+}
+
+static void msvdx_get_mtx_control_from_dash(igd_context_t *context)
+{
+	platform_context_plb_t *platform;
+	unsigned char *mmio;
+	int count = 0;
+	uint32_t reg_val = 0;
+
+	mmio = context->device_context.virt_mmadr;
+        platform = (platform_context_plb_t *)context->platform_context;
 
+	REGIO_WRITE_FIELD(reg_val, MSVDX_MTX_DEBUG, MTX_DBG_IS_SLAVE, 1);
+	REGIO_WRITE_FIELD(reg_val, MSVDX_MTX_DEBUG, MTX_DBG_GPIO_IN, 0x02);
+	EMGD_WRITE32(reg_val, mmio + MSVDX_MTX_DEBUG);
+
+	do {		reg_val = EMGD_READ32(mmio + MSVDX_MTX_DEBUG);
+		count++;
+	} while (((reg_val & 0x18) != 0) && count < 50000);
+
+	if (count >= 50000)
+		printk(KERN_ERR "[EMGD] MSVDX: timeout in %s\n", __FUNCTION__);
+
+	/* Save the RAM access control register */
+	platform->msvdx_dash_access_ctrl =
+		EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+}
+
+static void msvdx_release_mtx_control_from_dash(igd_context_t *context)
+{
+	platform_context_plb_t *platform;
+	unsigned char *mmio;
+
+	mmio = context->device_context.virt_mmadr;
+        platform = (platform_context_plb_t *)context->platform_context;
+
+	/* Restore access control */
+	EMGD_WRITE32(platform->msvdx_dash_access_ctrl,
+		mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+
+	/* Release the bus */
+	EMGD_WRITE32(0x04, mmio + MSVDX_MTX_DEBUG);
+}
+
+static int msvdx_upload_fw_dma(uint32_t address)
+{
+	drm_emgd_priv_t       *priv;
+	igd_context_t          *context;
+	platform_context_plb_t *platform;
+	unsigned long addr;
+	unsigned char *mmio;
+	uint32_t core_rev;
+	uint32_t size;
+	uint32_t cmd;
+	uint32_t count_reg;
+	uint32_t dma_channel;
+	uint32_t reg_val;
+	int ret;
+
+    printk(KERN_INFO "MSVDX: Upload firmware by DMA\n");
+
+	priv     = gpDrmDevice->dev_private;
+	context  = priv->context;
+	mmio     = context->device_context.virt_mmadr;
+       platform = (platform_context_plb_t *)context->platform_context;
+
+	dma_channel = 0; /* Use DMA channel 0 */
+
+	core_rev = EMGD_READ32(mmio + PSB_MSVDX_CORE_REV);
+	if ((core_rev & 0xffffff) < 0x020000)
+		size = 16 * 1024; /* mtx_mem_size */
+	else
+		size = 40 * 1024;
+
+	if (platform->msvdx_pvr && !platform->msvdx_pvr->fw_mem_info) {
+		ret = msvdx_map_fw(size);
+		if (ret)
+			return ret;
+	}
+
+	msvdx_get_mtx_control_from_dash(context);
+
+	/*
+	 * dma transfers to/from the mtx have to be 32-bit aligned and in
+	 * multiples of 32 bits
+	 */
+	EMGD_WRITE32(address, mmio + PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAA);
+
+	reg_val = 0;
+	/* Burst size in multiples of 64 bytes (allowed values are 2 or 4) */
+	REGIO_WRITE_FIELD_LITE(reg_val, MTX_CORE_CR_MTX_SYSC_CDMAC, BURSTSIZE, 4);
+
+	/* False means write to MTX mem, true means read from MTX mem */
+	REGIO_WRITE_FIELD_LITE(reg_val, MTX_CORE_CR_MTX_SYSC_CDMAC, RNW, 0);
+
+	/* Begin transfer */
+	REGIO_WRITE_FIELD_LITE(reg_val, MTX_CORE_CR_MTX_SYSC_CDMAC, ENABLE, 1);
+
+	/* DMA transfer is in size of 32-bit words */
+	REGIO_WRITE_FIELD_LITE(reg_val, MTX_CORE_CR_MTX_SYSC_CDMAC, LENGTH, (size/4));
+
+	EMGD_WRITE32(reg_val, mmio + PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAC);
+
+	/* Toggle channel 0 usage between MTX and other MSVDX peripherals */
+	reg_val = EMGD_READ32(mmio + PSB_MSVDX_CONTROL);
+	REGIO_WRITE_FIELD(reg_val, PSB_MSVDX_CONTROL, DMAC_CH0_SELECT, 0);
+	EMGD_WRITE32(reg_val, mmio + PSB_MSVDX_CONTROL);
+
+	/* Clear the DMAC Stats */
+	EMGD_WRITE32(0, mmio + PSB_MSVDX_DMAC_IRQ_STAT + (dma_channel * 0x20));
+
+	addr = platform->msvdx_pvr->fw_mem_info->sDevVAddr.uiAddr;
+
+	/* Use bank 0 */
+	EMGD_WRITE32(0, mmio + PSB_MSVDX_MMU_BANK_INDEX);
+
+	/* Use the same MMU PTD as the SGX for MMU base 0 */
+	EMGD_WRITE32(platform->psb_cr_bif_dir_list_base1,
+		mmio + PSB_MSVDX_MMU_DIR_LIST_BASE0);
+
+	/* Invalidate and flush TLB */
+	msvdx_flush_tlb(context);
+
+	EMGD_WRITE32(addr,
+		mmio + PSB_MSVDX_DMAC_SETUP + (dma_channel * 0x20));
+
+	/* Only use single DMA - assert that this is valid */
+	if ((size / 4) >= (1 << 15)) {
+		printk(KERN_ERR "[EMGD] MSVDX: DMA size beyond limit. "
+			"Firmware uploading aborted.\n");
+        msvdx_release_mtx_control_from_dash(context);
+		return -ENODEV;
+	}
+
+        count_reg = MSVDX_DMAC_VALUE_COUNT(MSVDX_DMAC_BSWAP_NO_SWAP,
+					0,  /* 32 bits */
+					MSVDX_DMAC_DIR_MEM_TO_PERIPH,
+					0,
+					(size / 4));
+
+	/* Set the number of bytes to DMA */
+	EMGD_WRITE32(count_reg,
+		mmio + PSB_MSVDX_DMAC_COUNT + (dma_channel * 0x20));
+
+	cmd = MSVDX_DMAC_VALUE_PERIPH_PARAM(MSVDX_DMAC_ACC_DEL_0,
+					MSVDX_DMAC_INCR_OFF,
+					MSVDX_DMAC_BURST_2);
+	EMGD_WRITE32(cmd, mmio + PSB_MSVDX_DMAC_PERIPH + (dma_channel * 0x20));
+
+	/* Set the destination port for DMA */
+	cmd = 0;
+	REGIO_WRITE_FIELD(cmd, DMAC_DMAC_PERIPHERAL_ADDR,
+		ADDR, (PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAT - MSVDX_BASE));
+	EMGD_WRITE32(cmd,
+		mmio + PSB_MSVDX_DMAC_PERIPHERAL_ADDR + (dma_channel * 0x20));
+
+	/* Finally, rewrite the count register with the enable bit set */
+	EMGD_WRITE32(count_reg | DMAC_DMAC_COUNT_EN_MASK,
+		mmio + PSB_MSVDX_DMAC_COUNT + (dma_channel * 0x20));
+
+	/* Wait for DMA to complete */
+	if (reg_ready_psb(context,
+			PSB_MSVDX_DMAC_IRQ_STAT + (dma_channel * 0x20),
+			DMAC_DMAC_IRQ_STAT_TRANSFER_FIN_MASK,
+			DMAC_DMAC_IRQ_STAT_TRANSFER_FIN_MASK)) {
+		msvdx_release_mtx_control_from_dash(context);
+
+		printk(KERN_ERR "[EMGD] MSVDX: DMA firmware upload timed "
+			"out\n");
+
+		return -ENODEV;
+	}
+
+	/* Assert that the MTX DMA port is done */
+	if (reg_ready_psb(context,
+			PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_CDMAS0, 1, 1)) {
+		msvdx_release_mtx_control_from_dash(context);
+		printk(KERN_ERR "[EMGD] MSVDX: MTX DMA port done timed out\n");
+		return -ENODEV;
+	}
+
+	msvdx_release_mtx_control_from_dash(context);
+    printk(KERN_INFO "[EMGD] MSVDX: firmware DMA upload done!\n");
+	return 0;
+}
+
+/*
+ * Upload firmware using PIO
+*/
+static int msvdx_upload_fw(void)
+{
+	drm_emgd_priv_t *priv;
+	igd_context_t *context;
+	unsigned char *mmio;
+	unsigned long ram_bank;
+	unsigned long bank_size;
+	unsigned long current_bank;
+	unsigned long acc_control;
+	unsigned long address;
+	unsigned long fw_size;
+	unsigned long *fw_data;
+	unsigned long ram_id;
+	unsigned long ctrl;
+	unsigned long i;
+
+	priv    = gpDrmDevice->dev_private;
+	context = priv->context;
+	mmio    = context->device_context.virt_mmadr;
+
+	/*
+	 * Get the ram bank size
+	 * The banks size seems to be a 4 bit value in the MTX debug register.
+	 * Where this is documented other than the UMG code is not clear.
+	 */
+	ram_bank = EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_BANK);
+	bank_size = (ram_bank & 0x000f0000) >> 16;
+	bank_size = (1 << (bank_size + 2));
+
+	/* Save RAM access control register */
+	acc_control = EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+
+	/* Loop writing text/code to core memory */
+	current_bank = ~0L;
+	address = PC_START_ADDRESS - MTX_CODE_BASE;
+
+	fw_data = priv_fw->fw_text;
+	fw_size = priv_fw->fw_text_size;
+
+	for (i = 0; i < fw_size; i++) {
+		/* Wait for MCMSTAT to become be idle 1 */
+		if (reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
+					0xffffffff, 0x00000001) == 0) {
+			ram_id = MTX_CORE_CODE_MEM + (address / bank_size);
+			if (ram_id != current_bank) {
+				/*
+				 * bits 20:27 - ram bank (CODE_BASE | DATA_BASE)
+				 * bits  2:19 - address
+				 * bit   1    - enable auto increment
+				 *              addressing mode
+				 */
+				ctrl = (ram_id << 20) | (((address >> 2) & 0x000ffffc) << 2) | 0x02;
+				EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+
+				current_bank = ram_id;
+				/* Wait for MCMSTAT to become be idle 1 */
+				reg_ready_psb(context,
+					PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
+					0xffffffff, 0x00000001);
+			}
+
+			address +=  4;
+			EMGD_WRITE32(fw_data[i],
+				mmio + PSB_MSVDX_MTX_RAM_ACCESS_DATA_TRANSFER);
+		} else {
+			printk(KERN_ERR
+				"[EMGD] MSVDX: Timeout waiting for MCMSTAT "
+				"to be idle\n");
+		}
+	}
+
+	/* verify firmware upload. */
+	current_bank = ~0L;
+	address = PC_START_ADDRESS - MTX_CODE_BASE;
+
+	for (i = 0; i < fw_size; i++) {
+		if (reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
+				0xffffffff, 0x00000001) == 0) {
+			ram_id = MTX_CORE_CODE_MEM + (address / bank_size);
+			if (ram_id != current_bank) {
+				/*
+				 * bits 20:27 - ram bank (CODE_BASE | DATA_BASE)
+				 * bits  2:19 - address
+				 * bit   1    - enable auto increment
+				 *              addressing mode
+				 */
+				ctrl = (ram_id << 20) | (((address >> 2) & 0x000ffffc) << 2) | 0x03;
+				EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+				current_bank = ram_id;
+				reg_ready_psb(context,
+					PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
+					0xffffffff, 0x00000001);
+			}
+
+			address +=  4;
+			if (EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_ACCESS_DATA_TRANSFER) !=
+				fw_data[i]) {
+				printk(KERN_ERR "Verify Error at index %ld\n", i);
+			}
+		} else {
+			printk(KERN_ERR "Timeout waiting for MCMSTAT to be idle while verifying\n");
+		}
+	}
+
+	fw_data = priv_fw->fw_data;
+	fw_size = priv_fw->fw_data_size;
+
+	/* Loop writing data to core memory */
+	current_bank = ~0L;
+	address = priv_fw->fw_data_location - MTX_DATA_BASE;
+
+	for (i = 0; i < fw_size; i++) {
+		if (reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
+				0xffffffff, 0x00000001) == 0) {
+			ram_id = MTX_CORE_DATA_MEM + (address / bank_size);
+			if (ram_id != current_bank) {
+				/*
+				 * bits 20:27 - ram bank (CODE_BASE | DATA_BASE)
+				 * bits  2:19 - address
+				 * bit   1    - enable auto increment
+				 *              addressing mode
+				 */
+				ctrl = (ram_id << 20) | (((address >> 2) & 0x000ffffc) << 2) | 0x02;
+				EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+				current_bank = ram_id;
+				reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
+					0xffffffff, 0x00000001);
+			}
+
+			address +=  4;
+			EMGD_WRITE32(fw_data[i],
+				mmio + PSB_MSVDX_MTX_RAM_ACCESS_DATA_TRANSFER);
+		} else {
+			printk(KERN_ERR
+				"[EMGD] MSVDX: Timeout waiting for MCMSTAT "
+				"to be idle - data segment\n");
+		}
+	}
+
+	/* Restore the RAM access control register */
+	EMGD_WRITE32(acc_control, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+	return 0;
+}
 
 int msvdx_query_plb(igd_context_t *context,
 					unsigned long *status)
 {
 	platform_context_plb_t *platform;
-
 	EMGD_TRACE_ENTER;
 
 	platform = (platform_context_plb_t *)context->platform_context;
@@ -115,19 +750,6 @@ int msvdx_query_plb(igd_context_t *context,
 	return 0;
 }
 
-int msvdx_status(igd_context_t *context, unsigned long *queue_status, unsigned long *mtx_msg_status)
-{
-	platform_context_plb_t *platform = NULL;
-	platform = (platform_context_plb_t *)context->platform_context;
-	if (init_msvdx_first_time) {
-		*queue_status = 1;
-		*mtx_msg_status = 1;
-	} else {
-			*queue_status = list_empty(&platform->msvdx_queue);
-			*mtx_msg_status = mtx_message_complete;
-	}
-	return IGD_SUCCESS;
-}
 int msvdx_pwr_plb(
 	igd_context_t *context,
 	unsigned long power_state)
@@ -139,7 +761,7 @@ int msvdx_pwr_plb(
 	if(power_state != IGD_POWERSTATE_D0){
 		platform->msvdx_needs_reset = 1;
 	}
-	
+
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
 }
@@ -154,33 +776,56 @@ int msvdx_pre_init_plb(struct drm_device *dev)
     gpDrmDevice = dev;
 	priv = gpDrmDevice->dev_private;
 	context = priv->context;
-		
+
 	context->mod_dispatch.msvdx_pwr = msvdx_pwr_plb;
-	context->mod_dispatch.msvdx_status = msvdx_status;
 
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
 }
 
 int msvdx_init_plb(unsigned long base0, unsigned long base1,
-		           void *msvdx_fw, unsigned long msvdx_fw_size, int reset_flag)
+           void *msvdx_fw, unsigned long msvdx_fw_size, int reset_flag)
 {
     drm_emgd_priv_t *priv;
     igd_context_t *context;
     unsigned char *mmio;
-    unsigned long ram_bank;
-    unsigned long bank_size;
-    unsigned long current_bank;
-    unsigned long address;
-    unsigned long acc_control;
+    unsigned long mmu_base_address;
     unsigned long base_addr0, base_addr1, size0, size1;
-    unsigned long ram_id;
     unsigned long ctrl;
-    unsigned long i;
+	int tmp;
 	unsigned long fw_size;
-	unsigned long *fw_data;
+	unsigned long reg_val;
 	msvdx_fw_t *fw = NULL;
 	platform_context_plb_t *platform = NULL;
+	int ret =0;
+	int msvdx_status;
+
+    priv = gpDrmDevice->dev_private;
+	context = priv->context;
+	mmio = context->device_context.virt_mmadr;
+    platform = (platform_context_plb_t *)context->platform_context;
+
+    // return back if firmware is already loaded
+    if (init_msvdx_first_time) {
+	spin_lock_init(&platform->msvdx_init_plb);
+    } else if(!reset_flag){
+	return ret;
+    }
+
+    // Set the status for firmware loading
+    spin_lock(&platform->msvdx_init_plb);
+    platform->msvdx_status = platform->msvdx_status | 1;
+    spin_unlock(&platform->msvdx_init_plb);
+
+    // now wait for message processing to finish
+    do
+    {
+        spin_lock(&platform->msvdx_init_plb);
+        msvdx_status = platform->msvdx_status ;
+        spin_unlock(&platform->msvdx_init_plb);
+        OS_SLEEP(100);
+    }
+    while((msvdx_status & 2));
 
 	if (!priv_fw && msvdx_fw) {
 		fw = (msvdx_fw_t *) msvdx_fw;
@@ -205,53 +850,92 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
 			((unsigned long) fw->fw_version)));
 	} else if (!priv_fw) {
 		printk(KERN_INFO "Kernel firmware is not loaded");
-
-		return 1;
+		if(init_msvdx_first_time) {
+			printk(KERN_ERR "ALAN!!! !priv_fw at msvdx init 1st");
+		}
+		ret = 1;
+		goto cleanup;
 	}
 
-    priv = gpDrmDevice->dev_private;
-    context = priv->context;
-    mmio = context->device_context.virt_mmadr;
-	if(!context_count || reset_flag){
-		//init_msvdx_first_time = 1;
-	    /* Reset MSVDX engine */
-	    EMGD_WRITE32(0x00000100, mmio + PSB_MSVDX_CONTROL);
-	    reg_ready_psb(context, PSB_MSVDX_CONTROL, 0x00000100, 0);
-
-	    /*
-	    * Make sure the clock is on.
-	    *
-	    * Clock enable bits are 0 - 6, with each bit controlling one of the
-	    * clocks.  For this, make sure all the clocks are enabled.
-	    */
-	    EMGD_WRITE32(PSB_CLK_ENABLE_ALL, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
-
-	    /* Set default MMU PTD to the same value used by the SGX */
-	    ctrl = EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE1);
-
-	    address = EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE1);
-	    EMGD_WRITE32(address, mmio + PSB_MSVDX_MMU_DIR_LIST_BASE0);
-	    EMGD_WRITE32(address, mmio + PSB_MSVDX_MMU_DIR_LIST_BASE1);
-	    EMGD_WRITE32(address, mmio + PSB_MSVDX_MMU_DIR_LIST_BASE2);
-	    EMGD_WRITE32(address, mmio + PSB_MSVDX_MMU_DIR_LIST_BASE3);
-
-
-	    /*
-	    * MMU Page size = 12
-	    * MMU best count = 7
-	    * MMU ADT TTE = 0
-	    * MMU TTE threshold = 12
-	    */
-	    EMGD_WRITE32(0xc070000c, mmio + PSB_MSVDX_MMU_CONTROL1);
-
-
-	    /* Flush the directory cache */
-	    ctrl = EMGD_READ32(mmio + PSB_MSVDX_MMU_CONTROL0) | 0x0C; /* Flush */
-	    EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MMU_CONTROL0);
-
-	    /* Enable MMU by removing all bypass bits */
-	    EMGD_WRITE32(0, mmio + PSB_MSVDX_MMU_CONTROL0);
-	}
+	if(!context_count || reset_flag) {
+
+    //init_msvdx_first_time = 1;
+    /* Reset MSVDX engine */
+    EMGD_WRITE32(0x00000100, mmio + PSB_MSVDX_CONTROL);
+    reg_ready_psb(context, PSB_MSVDX_CONTROL, 0x00000100, 0);
+
+    /*
+    * Make sure the clock is on.
+    *
+    * Clock enable bits are 0 - 6, with each bit controlling one of the
+    * clocks.  For this, make sure all the clocks are enabled.
+    */
+    EMGD_WRITE32(PSB_CLK_ENABLE_ALL, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
+
+    /* Set default MMU PTD to the same value used by the SGX */
+    if (!msvdx_compositor_mmu_base) {
+		printk(KERN_ERR "XSERVER never sent compositor MMU base!!!");
+		mmu_base_address = EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE1);
+		tmp = 0;
+		while(!mmu_base_address){
+			mmu_base_address = EMGD_READ32(mmio + PSB_CR_BIF_DIR_LIST_BASE0);
+			++tmp;
+			if(!tmp%100){
+				printk(KERN_ERR "Cant read SGX Base0 count = %d", tmp);
+			}
+			if(tmp > 10000){
+				printk(KERN_ERR "Giving up reading SGX Base0 from register - expect hang!");
+				break;
+			}
+		}
+		platform->psb_cr_bif_dir_list_base1 = mmu_base_address;
+	} else {
+			platform->psb_cr_bif_dir_list_base1 = msvdx_compositor_mmu_base;
+    }
+
+    EMGD_WRITE32(platform->psb_cr_bif_dir_list_base1,
+	mmio + PSB_MSVDX_MMU_DIR_LIST_BASE0);
+
+    /*
+    * MMU Page size = 12
+    * MMU best count = 7
+    * MMU ADT TTE = 0
+    * MMU TTE threshold = 12
+    */
+    EMGD_WRITE32(0xc070000c, mmio + PSB_MSVDX_MMU_CONTROL1);
+
+
+    /* Flush the directory cache */
+    ctrl = EMGD_READ32(mmio + PSB_MSVDX_MMU_CONTROL0) | 0x0C; /* Flush */
+    EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MMU_CONTROL0);
+
+#if 1 //disable watchdog
+    reg_val = 0;
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CNT_CTRL, 0x3);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_ENABLE, 0);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_ACTION0, 1);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CLEAR_SELECT, 1);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL, FE_WDT_CLKDIV_SELECT, 7);
+    printk(KERN_INFO "CTL_MSG: WDT Control value = 0x%x", reg_val);
+    EMGD_WRITE32(0, mmio + MSVDX_CORE_CR_FE_MSVDX_WDT_COMPAREMATCH_OFFSET);
+    EMGD_WRITE32(reg_val, mmio + MSVDX_CORE_CR_FE_MSVDX_WDT_CONTROL_OFFSET);
+
+    reg_val = 0;
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CNT_CTRL, 0x7);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_ENABLE, 0);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_ACTION0, 1);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CLEAR_SELECT, 0xd);
+    REGIO_WRITE_FIELD(reg_val, MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL, BE_WDT_CLKDIV_SELECT, 7);
+    printk(KERN_INFO "CTL_MSG: WDT Control value = 0x%x", reg_val);
+    EMGD_WRITE32(0, mmio + MSVDX_CORE_CR_BE_MSVDX_WDT_COMPAREMATCH_OFFSET);
+    EMGD_WRITE32(reg_val, mmio + MSVDX_CORE_CR_BE_MSVDX_WDT_CONTROL_OFFSET);
+
+
+#endif
+
+    /* Enable MMU by removing all bypass bits */
+    EMGD_WRITE32(0, mmio + PSB_MSVDX_MMU_CONTROL0);
+    }
 
     /* Set up the RENDEC.
     *   The RENDEC requires two blocks of virtual address space so those
@@ -290,8 +974,9 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
         platform->rendec_base1 = base_addr1;
 
 		init_msvdx_first_time = 0;
-	INIT_LIST_HEAD(&platform->msvdx_queue);
+        INIT_LIST_HEAD(&platform->msvdx_queue);
 		spin_lock_init(&platform->msvdx_lock);
+
     } else {
         /* restore offsets. */
         platform = (platform_context_plb_t *)context->platform_context;
@@ -300,15 +985,17 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
 
         /* Init link list */
         if(!context_count) {
-			INIT_LIST_HEAD(&platform->msvdx_queue);
-		} else {
-			if(!reset_flag){
-				EMGD_TRACE_EXIT;
-				return 0;
-			}
+		INIT_LIST_HEAD(&platform->msvdx_queue);
+	} else {
+		if(!reset_flag){
+			EMGD_TRACE_EXIT;
+			ret = 0;
+			goto cleanup;
 		}
+	}
     }
 
+
 	platform->msvdx_busy = 0;
     EMGD_WRITE32(base_addr0, mmio + PSB_MSVDX_RENDEC_BASE_ADDR0);
     EMGD_WRITE32(base_addr1, mmio + PSB_MSVDX_RENDEC_BASE_ADDR1);
@@ -353,12 +1040,38 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
     * Stepping D0 should set MSVDX_DEVICE_NODE_FLAGS_DEFAULT_D0 (0x222)
     * Stepping D1 should set MSVDX_DEVICE_NODE_FLAGS_DEFAULT_D1 (0x220)
     */
-
+#if 0
     /* If POULSBO_D1 or later use MSVDX_DEVICE_NODE_FLAGS_MMU_HW_INVALIDATION */
     EMGD_WRITE32(MSVDX_DEVICE_NODE_FLAGS_DEFAULT,
             mmio + PSB_MSVDX_COMMS_OFFSET_FLAGS);
     /* Else EMGD_WRITE32(0x00, mmio + PSB_MSVDX_COMMS_OFFSET_FLAGS); */
+#endif
+#if 1
+{
+#define DISABLE_FW_WDT                          0x0008
+#define ABORT_ON_ERRORS_IMMEDIATE               0x0010
+#define ABORT_FAULTED_SLICE_IMMEDIATE           0x0020
+#define RETURN_VDEB_DATA_IN_COMPLETION          0x0800
+#define DISABLE_Auto_CLOCK_GATING               0x1000
+#define DISABLE_IDLE_GPIO_SIG                   0x2000
+
+    unsigned long msvdx_fw_flag;
+
+    // msvdx_fw_flag = DISABLE_Auto_CLOCK_GATING | RETURN_VDEB_DATA_IN_COMPLETION | DISABLE_FW_WDT;
+    msvdx_fw_flag = DISABLE_FW_WDT; /* Per ImgTec ticket 16892 */
+
+    EMGD_WRITE32(msvdx_fw_flag, mmio + PSB_MSVDX_COMMS_OFFSET_FLAGS);
 
+    /*
+     * Following two setting can't find reg definition in spec, just copy
+     * from IMG DDK 187
+     */
+    /* 1/200th of the clock frequency */
+    EMGD_WRITE32(200 - 1,
+      mmio + PSB_MSVDX_MTX_CORE_CR_MTX_SYSC_TIMERDIV_OFFSET);
+    EMGD_WRITE32(0, mmio + 0x2884); /* EXT_FW_ERROR_STATE */
+}
+#endif
     /* Initialize communication control */
     EMGD_WRITE32(0x00, mmio + PSB_MSVDX_COMMS_MSG_COUNTER);
     EMGD_WRITE32(0x00, mmio + PSB_MSVDX_COMMS_SIGNATURE);
@@ -368,124 +1081,11 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
     EMGD_WRITE32(0x00, mmio + PSB_MSVDX_COMMS_TO_MTX_WRT_INDEX);
     EMGD_WRITE32(0x00, mmio + PSB_MSVDX_COMMS_FW_STATUS);
 
-    /*
-    * Get the ram bank size
-    *   The banks size seems to be a 4 bit value in the MTX debug register.
-    *   Where this is documented other than the UMG code is not clear.
-    */
-    ram_bank = EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_BANK);
-    bank_size = (ram_bank & 0x000f0000) >> 16;
-    bank_size = (1 << (bank_size + 2));
-
-    /* Firmware version? */
-    printk(KERN_INFO "Firmware version is %s\n", priv_fw->fw_version);
-
-    /* Save RAM access control register */
-    acc_control = EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
-
-    /* Loop writing text/code to core memory */
-    current_bank = ~0L;
-    address = PC_START_ADDRESS - MTX_CODE_BASE;
-
-	fw_data = priv_fw->fw_text;
-	fw_size = priv_fw->fw_text_size;
-
-    for (i = 0; i < fw_size; i++) {
-        /* Wait for MCMSTAT to become be idle 1 */
-        if (reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
-                    0xffffffff, 0x00000001) == 0) {
-            ram_id = MTX_CORE_CODE_MEM + (address / bank_size);
-            if (ram_id != current_bank) {
-                /*
-                * bits 20:27    - ram bank (CODE_BASE | DATA_BASE)
-                * bits  2:19    - address
-                * bit   1       - enable auto increment addressing mode
-                */
-                ctrl = (ram_id << 20) | (((address >> 2) & 0x000ffffc) << 2) |
-                    0x02;
-                EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
-
-                current_bank = ram_id;
-                /* Wait for MCMSTAT to become be idle 1 */
-                reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
-                        0xffffffff, 0x00000001);
-            }
-
-            address +=  4;
-            EMGD_WRITE32(fw_data[i],
-                    mmio + PSB_MSVDX_MTX_RAM_ACCESS_DATA_TRANSFER);
-        } else {
-            printk(KERN_ERR "Timeout waiting for MCMSTAT to be idle\n");
-        }
-    }
-
-    /* verify firmware upload. */
-    current_bank = ~0L;
-    address = PC_START_ADDRESS - MTX_CODE_BASE;
-
-    for (i = 0; i < fw_size; i++) {
-        if (reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
-                    0xffffffff, 0x00000001) == 0) {
-            ram_id = MTX_CORE_CODE_MEM + (address / bank_size);
-            if (ram_id != current_bank) {
-                /*
-                * bits 20:27    - ram bank (CODE_BASE | DATA_BASE)
-                * bits  2:19    - address
-                * bit   1       - enable auto increment addressing mode
-                */
-                ctrl = (ram_id << 20) | (((address >> 2) & 0x000ffffc) << 2) |
-                    0x03;
-                EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
-                current_bank = ram_id;
-                reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
-                        0xffffffff, 0x00000001);
-            }
-
-            address +=  4;
-            if (EMGD_READ32(mmio + PSB_MSVDX_MTX_RAM_ACCESS_DATA_TRANSFER) !=
-                    fw_data[i]) {
-                printk(KERN_ERR "Verify Error at index %ld\n", i);
-            }
-        } else {
-            printk(KERN_ERR "Timeout waiting for MCMSTAT to be idle while verifying\n");
-        }
-    }
-
-	fw_data = priv_fw->fw_data;
-	fw_size = priv_fw->fw_data_size;
-
-    /* Loop writing data to core memory */
-    current_bank = ~0L;
-    address = priv_fw->fw_data_location - MTX_DATA_BASE;
-
-    for (i = 0; i < fw_size; i++) {
-        if (reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
-                    0xffffffff, 0x00000001) == 0) {
-            ram_id = MTX_CORE_DATA_MEM + (address / bank_size);
-            if (ram_id != current_bank) {
-                /*
-                * bits 20:27    - ram bank (CODE_BASE | DATA_BASE)
-                * bits  2:19    - address
-                * bit   1       - enable auto increment addressing mode
-                */
-                ctrl = (ram_id << 20) | (((address >> 2) & 0x000ffffc) << 2) |
-                    0x02;
-                EMGD_WRITE32(ctrl, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
-                current_bank = ram_id;
-                reg_ready_psb(context, PSB_MSVDX_MTX_RAM_ACCESS_STATUS,
-                        0xffffffff, 0x00000001);
-            }
-
-            address +=  4;
-            EMGD_WRITE32(fw_data[i],
-                    mmio + PSB_MSVDX_MTX_RAM_ACCESS_DATA_TRANSFER);
-        } else {
-            printk(KERN_ERR "Timeout waiting for MCMSTAT to be idle - data segment\n");
-        }
-    }
-
-    /* Restore the RAM access control register */
-    EMGD_WRITE32(acc_control, mmio + PSB_MSVDX_MTX_RAM_ACCESS_CONTROL);
+    printk(KERN_INFO "MSVDX: Firmware version is %s\n", priv_fw->fw_version);
+    if (msvdx_fw_dma_upload)
+        msvdx_upload_fw_dma(0 /* Offset of firmware's .text section */);
+    else
+        msvdx_upload_fw();
 
     /* Start the firmware thread running */
     EMGD_WRITE32(PC_START_ADDRESS, mmio + PSB_MSVDX_MTX_REGISTER_READ_WRITE_DATA);
@@ -507,7 +1107,8 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
                 0xA5A5A5A5)){
         /* Error initializing firmware.... */
         EMGD_DEBUG("Error, no MSVDX COMMS Signature");
-        return 0; /* FIXME: return an error code */
+	    ret = -1; /* FIXME: return an error code */
+        goto cleanup;
     }
     printk(KERN_INFO "MSVDX COMMS Signature OK\n");
 
@@ -554,10 +1155,14 @@ int msvdx_init_plb(unsigned long base0, unsigned long base1,
     /* Enable MTX interrupts to host */
     EMGD_WRITE32(1<<14, mmio + PSB_MSVDX_HOST_INTERRUPT_ENABLE);
 
-
+cleanup:
+    // unset fw loading flag
+    spin_lock(&platform->msvdx_init_plb);
+    platform->msvdx_status = platform->msvdx_status & ~1;
+    spin_unlock(&platform->msvdx_init_plb);
     /* Are we done? */
     EMGD_TRACE_EXIT;
-    return 0; /* Successfully initialized the MTX firmware */
+    return ret; /* Successfully initialized the MTX firmware */
 }
 
 
@@ -567,6 +1172,7 @@ int msvdx_uninit_plb(igd_context_t *context)
 
 	if(!context_count) {
 		//msvdx_reset_plb(context);
+		//msvdx_pvr_deinit();
 	}
 	EMGD_TRACE_EXIT;
 	return 0;
@@ -607,7 +1213,6 @@ int process_video_decode_plb(igd_context_t *context, unsigned long offset, void
     unsigned long irq_flags;
 	int ret = 0;
     platform_context_plb_t *platform;
-
     EMGD_TRACE_ENTER;
 
 
@@ -617,8 +1222,6 @@ int process_video_decode_plb(igd_context_t *context, unsigned long offset, void
     mtx_offset = mtx_buf[0];
     mtx_msg_cnt = mtx_buf[1];
 
-//	printk(KERN_INFO "process_video_decode_plb where buf=%lx, offset=%lx, cnt=%lx\n",
-//				mtx_buf, offset, mtx_msg_cnt);
     if (mtx_msg_cnt > 0x20) {
         printk(KERN_ERR "Message count too big at %ld\n", mtx_msg_cnt);
         return -EINVAL;
@@ -742,7 +1345,6 @@ void msvdx_reset_plb(igd_context_t *context)
 {
     unsigned char *mmio = context->device_context.virt_mmadr;
     platform_context_plb_t *platform;
-
     EMGD_TRACE_ENTER;
 
     platform = (platform_context_plb_t *)context->platform_context;
@@ -759,25 +1361,110 @@ void msvdx_reset_plb(igd_context_t *context)
     platform->msvdx_needs_reset = 0;
 }
 
+#if 0
+void MSVDXSetClocksEnable(int ClockState)
+{
+	unsigned long reg_val = 0;
+
+	if(ClockState == 0)
+	{
+		// Turn off clocks procedure
+
+		if(LastClockState)
+		{
+			// Turn off all the clocks except core
+			EMGD_WRITE32(0x00000001, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
+
+			// Make sure all the clocks are off except core
+			reg_ready_psb(context, PSB_MSVDX_MAN_CLK_ENABLE, 0x00000001, 0);
+
+			// Turn off core clock
+			EMGD_WRITE32(0, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
+		}
+
+		LastClockState = 0;
+	}
+	else
+	{
+		// ui32ClockState
+		unsigned long ClocksEn = ClockState;
+
+		//Make sure that core clock is not accidentally turned off
+		ClocksEn |= 0x00000001;
+
+		//If all clocks were disable do the bring up procedure
+		if(LastClockState == 0 )
+		{
+			// turn on core clock
+			EMGD_WRITE32(0x00000001, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
+
+			// Make sure it is on
+			reg_ready_psb(context, PSB_MSVDX_MAN_CLK_ENABLE, 0x00000001, 0);
+
+			// turn on the other clocks as well
+			EMGD_WRITE32(ClocksEn, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
+
+			// Make sure that they are on
+			reg_ready_psb(context, PSB_MSVDX_MAN_CLK_ENABLE, ClocksEn, 0);
+		}
+		else
+		{
+			EMGD_WRITE32(ClocksEn, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
+
+			// Make sure that they are on
+			reg_ready_psb(context, PSB_MSVDX_MAN_CLK_ENABLE, ClocksEn, 0);
+		}
+
+		LastClockState = ClocksEn;
+	}
+}
+
+void msvdx_reset_plb_workaround(igd_context_t *context)
+{
+    unsigned char *mmio = context->device_context.virt_mmadr;
+    platform_context_plb_t *platform;
+
+    EMGD_TRACE_ENTER;
+
+    platform = (platform_context_plb_t *)context->platform_context;
+
+    /*
+    * Make sure the clock is on.
+    *
+    * Clock enable bits are 0 - 6, with each bit controlling one of the
+    * clocks.  For this, make sure all the clocks are enabled.
+    */
+
+    EMGD_WRITE32(PSB_CLK_ENABLE_ALL, mmio + PSB_MSVDX_MAN_CLK_ENABLE);
 
+    /* Reset MSVDX engine */
+    EMGD_WRITE32(0x11111100, mmio + PSB_MSVDX_CONTROL);
+    reg_ready_psb(context, PSB_MSVDX_CONTROL, 0x00000100, 0);
+
+    /* Clear interrupt and clear pending interrupts */
+    EMGD_WRITE32(0, mmio + PSB_MSVDX_HOST_INTERRUPT_ENABLE);
+    EMGD_WRITE32(0xffffffff, mmio + PSB_MSVDX_INTERRUPT_CLEAR);
+
+    /* Mark the engine as being reset */
+    platform->msvdx_needs_reset = 0;
+}
+#endif
 /*
  * When shuting down, need to reset the MSVDX engine too.
  */
 int msvdx_shutdown_plb(igd_context_t *context)
 {
 	platform_context_plb_t *platform;
-
 	EMGD_TRACE_ENTER;
 	platform = (platform_context_plb_t *)context->platform_context;
 
 	/* Reset MSVDX engine */
 	msvdx_reset_plb(context);
-
+	msvdx_pvr_deinit();
 	/* Free RENDEC memory allocations */
 	platform->rendec_base0 = 0;
 	platform->rendec_base1 = 0;
 	init_msvdx_first_time = 1;
-
 	EMGD_TRACE_EXIT;
 	return 0;
 }
diff --git a/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.c b/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.c
index 99ccec1..0dcf0a0 100644
--- a/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.c
+++ b/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_pvr.c
- * $Revision: 1.9 $
+ * $Revision: 1.10 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -43,8 +43,12 @@
 #include "memmap.h"
 #include <drm_emgd_private.h>
 #include "emgd_drm.h"
+#include <linux/kthread.h>
+#include <plb/regs.h>
+#include <plb/context.h>
 
 extern IMG_BOOL msvdx_mtx_isr(IMG_VOID *pvData);
+#if 0
 extern int emgd_test_pvrsrv(struct drm_device *dev, void *arg,
 	struct drm_file *file_priv);
 
@@ -169,6 +173,270 @@ int alloc_ramdec_region(unsigned long *base_addr0, unsigned long *base_addr1,
 	return 0;
 
 }
+#endif
+
+/*
+ * Dummy kernel thread.  Needed for a persistent per process data for
+ * PVR services.
+ */
+static int msvdx_pvr_kthread(void *data)
+{
+	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();
+	}
+	return 0;
+}
+
+int msvdx_preinit_mmu(unsigned long hmemcxt)
+{
+	PVRSRV_ERROR err;
+	PVRSRV_PER_PROCESS_DATA *ps_data = NULL;
+	IMG_HANDLE hmem = (IMG_HANDLE) hmemcxt;
+	IMG_HANDLE hmemkm;
+	IMG_DEV_PHYADDR addr;
+	IMG_UINT32 pid = OSGetCurrentProcessIDKM();
+	int ret;
+	drm_emgd_priv_t *priv = gpDrmDevice->dev_private;
+	igd_context_t *context = priv->context;
+	platform_context_plb_t *platform =
+		(platform_context_plb_t *) context->platform_context;
+
+    ps_data = PVRSRVPerProcessData(pid);
+	if (!ps_data) {
+		printk(KERN_ERR "MSVDX: Cannot get process data information");
+
+		return -1;
+	}
+
+
+	err = PVRSRVLookupHandle(ps_data->psHandleBase, &hmemkm, hmem, PVRSRV_HANDLE_TYPE_DEV_MEM_CONTEXT);
+
+	if(err != PVRSRV_OK)
+	{
+		printk(KERN_ERR "MSVDX: Cannot get memory context from process data");
+
+		return -1;
+	}
+
+	addr = BM_GetDeviceNode(hmemkm)->pfnMMUGetPDDevPAddr(BM_GetMMUContextFromMemContext(hmemkm));
+	msvdx_init_compositor_mmu(addr.uiAddr);
+
+	if (!platform->msvdx_pvr) {
+		ret = msvdx_pvr_init();
+		if (ret) {
+			printk(KERN_INFO "Failed in msvdx_pvr_init()");
+		} else {
+
+			printk(KERN_INFO "Succeed for msvdx_pvr_init()");
+
+		}
+	}
+
+
+	return 0;
+}
+
+/*
+ * Can't call from module initialization, since PVR services are started when
+ * the Xorg server starts.
+ */
+int msvdx_pvr_init(void)
+{
+	drm_emgd_priv_t        *priv;
+	igd_context_t           *context;
+	platform_context_plb_t  *platform;
+	struct msvdx_pvr_info   *pvr;
+	PVRSRV_DEVICE_IDENTIFIER dev_id_list[PVRSRV_MAX_DEVICES];
+	IMG_UINT32   pid;
+	IMG_UINT32   num_devices;
+	IMG_UINT32   i;
+	IMG_BOOL     mem_created;
+	PVRSRV_ERROR err;
+	int ret;
+
+	priv     = gpDrmDevice->dev_private;
+	context  = priv->context;
+	platform = (platform_context_plb_t *)context->platform_context;
+
+	if (platform->msvdx_pvr) {
+		printk(KERN_INFO "[EMGD] MSVDX: PVR services already "
+			"initialized\n");
+		return 0;
+	}
+
+    pvr = kzalloc(sizeof(*pvr), GFP_KERNEL);
+	if (!pvr)
+		return -ENOMEM;
+
+    /*
+	 * Create a dummy kernel thread so that a persistent PVR per process
+	 * data could be created.
+	 */
+	pvr->kthread = kthread_run(msvdx_pvr_kthread, NULL, "msvdx-pvr");
+	if (IS_ERR(pvr->kthread)) {
+		ret = PTR_ERR(pvr->kthread);
+		printk(KERN_ERR "[EMGD] MSVDX: failed to create MSVDX PVR "
+			"kernel tread, error=%i\n", ret);
+		pvr->kthread = NULL;
+		goto out_free;
+	}
+
+	ret = -ENODEV;
+	pid = OSGetCurrentProcessIDKM(); //(IMG_UINT32)pvr->kthread->pid;
+    err = PVRSRVPerProcessDataConnect(pid);
+	if (err != PVRSRV_OK) {
+		printk(KERN_ERR "[EMGD] MSVDX: connect to PVR failed (pid=%u), "
+			"error=%i\n", (unsigned int)err, err);
+		goto out_stop_kthread;
+	}
+	pvr->per_proc = PVRSRVPerProcessData(pid);
+	if (pvr->per_proc == IMG_NULL) {
+		printk(KERN_ERR "[EMGD] MSVDX: Couldn't find per process "
+			"data for pid=%u\n", (unsigned int)pid);
+		goto out_stop_kthread;
+	}
+
+	err = PVRSRVEnumerateDevicesKM(&num_devices, dev_id_list);
+	if (err != PVRSRV_OK) {
+		printk(KERN_ERR "[EMGD] MSVDX: PVRSRVEnumerateDevice() failed, "
+			"error=%u\n", (unsigned int)err);
+		goto out_stop_kthread;
+	}
+
+	for (i = 0 ; i < num_devices ; i++) {
+		PVRSRV_DEVICE_IDENTIFIER *id;
+		IMG_HANDLE cookie;
+
+		cookie = IMG_NULL;
+		id = &dev_id_list[i];
+
+		if (id->eDeviceType != PVRSRV_DEVICE_TYPE_EXT) {
+			err = PVRSRVAcquireDeviceDataKM(id->ui32DeviceIndex,
+				PVRSRV_DEVICE_TYPE_UNKNOWN, &cookie);
+			if (err != PVRSRV_OK) {
+				printk(KERN_ERR "[EMGD] MSVDX: "
+					"PVRSRVAcquireDeviceDataKM() failed, "
+					"error=%u\n", err);
+				break;
+			}
+			if (PVRSRV_DEVICE_TYPE_SGX == id->eDeviceType) {
+				pvr->sgx_cookie = cookie;
+				break;
+			}
+		}
+	}
+
+	if (pvr->sgx_cookie == IMG_NULL)
+		goto out_stop_kthread;
+
+	err = PVRSRVCreateDeviceMemContextKM(pvr->sgx_cookie, pvr->per_proc,
+			&pvr->dev_mem_context, &pvr->heap_count,
+			pvr->heap_info, &mem_created, pvr->heap_shared);
+	if (err != PVRSRV_OK) {
+		printk(KERN_ERR "[EMGD] MSVDX: PVRSRVCreateDeviceMemContextKM()"
+			" failed, error=%u\n", (unsigned int)err);
+		goto out_stop_kthread;
+	}
+
+	for (i = 0; i < pvr->heap_count; i++) {
+		if (HEAP_IDX(pvr->heap_info[i].ui32HeapID) ==
+			SGX_GENERAL_MAPPING_HEAP_ID) {
+			pvr->mapping_heap_index = i;
+			break;
+		}
+	}
+
+	platform->msvdx_pvr = pvr;
+	pvr->pid = pid;
+
+
+	return 0;
+
+out_stop_kthread:
+	kthread_stop(pvr->kthread);
+out_free:
+	kfree(pvr);
+	return ret;
+}
+
+/*
+ * HHP: FIXME:
+ * This should also be called when GMM/GTT is re-initialized, i.e. when
+ * the Xorg server stops.  The PVR backed memory is invalid when this happens,
+ * so if we call this function from msvdx_driver_unload() when the module is
+ * removed, the "fw_mem_info" and "dev_mem_context" are invalid.
+ */
+void msvdx_pvr_deinit(void)
+{
+	drm_emgd_priv_t       *priv;
+	igd_context_t          *context;
+	platform_context_plb_t *platform;
+	struct msvdx_pvr_info  *pvr;
+	IMG_BOOL mem_destroyed;
+	int pid=0;
+	unsigned char *mmio;
+
+	priv     = gpDrmDevice->dev_private;
+	context  = priv->context;
+	platform = (platform_context_plb_t *)context->platform_context;
+    mmio = context->device_context.virt_mmadr;
+	pvr = platform->msvdx_pvr;
+
+    //Reset MTX before unloading firmware
+    EMGD_WRITE32(0x00000001, mmio + PSB_MSVDX_MTX_SOFT_RESET);
+
+
+	if (pvr) {
+        kthread_stop(pvr->kthread);
+		if (pvr->fw_mem_info)
+			PVRSRVFreeDeviceMemKM(pvr->sgx_cookie,
+						pvr->fw_mem_info);
+
+		PVRSRVDestroyDeviceMemContextKM(pvr->sgx_cookie,
+						pvr->dev_mem_context,
+						&mem_destroyed);
+
+	//	PVRSRVPerProcessDataDisconnect((IMG_UINT32)pvr->kthread->pid);
+        PVRSRVPerProcessDataDisconnect((IMG_UINT32)pvr->pid);
+        pid = pvr->pid;
+		kfree(pvr);
+		platform->msvdx_pvr = NULL;
+	}
+
+}
+
+PVRSRV_KERNEL_MEM_INFO *msvdx_pvr_alloc_devmem(unsigned long alloc_size,
+	const char *mame)
+{
+	drm_emgd_priv_t        *priv;
+	igd_context_t           *context;
+	platform_context_plb_t  *platform;
+	struct msvdx_pvr_info   *pvr;
+	PVRSRV_KERNEL_MEM_INFO  *mem_info;
+	PVRSRV_ERROR err;
+
+	priv     = gpDrmDevice->dev_private;
+	context  = priv->context;
+	platform = (platform_context_plb_t *)context->platform_context;
+
+	pvr = platform->msvdx_pvr;
+	if (!pvr)
+		return NULL;
+
+	/* Is PVRSRV_MEM_CACHE_CONSISTENT needed in the allocation flags? */
+	err = PVRSRVAllocDeviceMemKM(pvr->sgx_cookie, pvr->per_proc,
+			pvr->heap_info[pvr->mapping_heap_index].hDevMemHeap,
+			PVRSRV_MEM_READ | PVRSRV_MEM_WRITE,
+			alloc_size, 0, &mem_info, name);
+	if (err != PVRSRV_OK) {
+		printk(KERN_ERR "[EMGD] MSVDX: PVRSRVAllocDeviceMemKM failed, "
+			"error=%u\n", (unsigned int)err);
+		return NULL;
+	}
+
+	return mem_info;
+}
 
 static PVRSRV_ERROR DevInitMSVDXPart1(IMG_VOID *pvDeviceNode)
 {
diff --git a/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.h b/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.h
index 3f28f81..070c935 100644
--- a/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.h
+++ b/drivers/staging/emgd/emgd/video/msvdx/msvdx_pvr.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx_pvr.h
- * $Revision: 1.6 $
+ * $Revision: 1.7 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -31,12 +31,27 @@
 
 #ifndef MSVDX_POWER_H_
 #define MSVDX_POWER_H_
-
+#include <linux/sched.h>
 #include "services_headers.h"
 #include "sysconfig.h"
 
 extern struct drm_device *gpDrmDevice;
 
+struct msvdx_pvr_info {
+	/* HHP: FIXME: review if a mutex lock is needed here */
+	IMG_HANDLE                sgx_cookie;
+	IMG_HANDLE                dev_mem_context;
+	PVRSRV_PER_PROCESS_DATA  *per_proc;
+	PVRSRV_HEAP_INFO          heap_info[PVRSRV_MAX_CLIENT_HEAPS];
+	IMG_BOOL                  heap_shared[PVRSRV_MAX_CLIENT_HEAPS];
+	IMG_UINT32                heap_count;
+	/* index of SGX_GENERAL_MAPPING_HEAP_ID in heap_info[] */
+	int                       mapping_heap_index;
+	PVRSRV_KERNEL_MEM_INFO   *fw_mem_info;
+	/* Needed for PVR per process data */
+	struct task_struct       *kthread;
+	IMG_UINT32                pid;
+};
 /* function define */
 PVRSRV_ERROR MSVDXRegisterDevice(PVRSRV_DEVICE_NODE *psDeviceNode);
 PVRSRV_ERROR MSVDXDevInitCompatCheck(PVRSRV_DEVICE_NODE *psDeviceNode);
@@ -56,4 +71,8 @@ PVRSRV_ERROR MSVDXPostClockSpeedChange(IMG_HANDLE	hDevHandle,
 			       PVRSRV_DEV_POWER_STATE	eCurrentPowerState);
 PVRSRV_ERROR MSVDXInitOSPM(PVRSRV_DEVICE_NODE *psDeviceNode);
 
+extern int  msvdx_pvr_init(void);
+extern void msvdx_pvr_deinit(void);
+extern PVRSRV_KERNEL_MEM_INFO *msvdx_pvr_alloc_devmem(
+	unsigned long alloc_size, const char *name);
 #endif /* !MSVDX_POWER_H_ */
diff --git a/drivers/staging/emgd/include/emgd_drm.h b/drivers/staging/emgd/include/emgd_drm.h
index e95e008..c696071 100644
--- a/drivers/staging/emgd/include/emgd_drm.h
+++ b/drivers/staging/emgd/include/emgd_drm.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drm.h
- * $Revision: 1.59 $
+ * $Revision: 1.60 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -56,6 +56,7 @@ enum {
 #define PSB_ENGINE_TA 3
 #define PSB_ENGINE_HPRAST 4
 #define TNC_ENGINE_ENCODE 5
+#define PSB_ENGINE_COMPOSITOR_MMU 6
 
 
 /* OEM flags for buffer allocation through the PVR2DCreateFlipChain */
@@ -410,6 +411,11 @@ typedef struct _kdrm_video_flush_tlb {
 	int engine;
 } emgd_drm_video_flush_tlb_t;
 
+typedef struct _kdrm_preinit_mmu {
+	int rtn;
+	unsigned long memcontext;
+} emgd_drm_preinit_mmu_t;
+
 typedef struct _kdrm_get_display_info {
 	int rtn; /* (UP) - return value of HAL procedure */
 	igd_display_info_t primary_pt_info; /* (UP) */
@@ -736,6 +742,7 @@ typedef struct _kdrm_bc_ts {
 #define DRM_IGD_ALTER_OVL2          0x2f
 #define DRM_IGD_GET_CHIPSET_INFO    0x30
 #define DRM_IGD_GET_DISPLAY_INFO    0x38
+#define DRM_IGD_PREINIT_MMU         0x39
 /* For Buffer Class of Texture Stream */
 #define DRM_IGD_BC_TS_INIT			0x40
 #define DRM_IGD_BC_TS_UNINIT		0x41
@@ -876,6 +883,8 @@ typedef struct _kdrm_bc_ts {
 		emgd_drm_video_get_info_t)
 #define DRM_IOCTL_IGD_VIDEO_FLUSH_TLB  DRM_IOR(DRM_IGD_VIDEO_FLUSH_TLB + BASE,\
 		emgd_drm_video_flush_tlb_t)
+#define DRM_IOCTL_IGD_PREINIT_MMU  DRM_IOR(DRM_IGD_PREINIT_MMU + BASE,\
+		emgd_drm_preinit_mmu_t)
 #define DRM_IOCTL_IGD_GET_DISPLAY_INFO  DRM_IOR(DRM_IGD_GET_DISPLAY_INFO + BASE,\
 		emgd_drm_get_display_info_t)
 /* For Buffer Class of Texture Stream */
diff --git a/drivers/staging/emgd/include/igd_init.h b/drivers/staging/emgd/include/igd_init.h
index 011cf93..c382b0d 100644
--- a/drivers/staging/emgd/include/igd_init.h
+++ b/drivers/staging/emgd/include/igd_init.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_init.h
- * $Revision: 1.14 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -436,6 +436,7 @@ typedef struct _igd_display_params {
 #define IGD_DISPLAY_MULTI_DVO     0x00000002  /* igd_param_t.display_flags  */
 #define IGD_DISPLAY_DETECT        0x00000004  /* igd_param_t.display_flags  */
 #define IGD_DISPLAY_FB_BLEND_OVL  0x00000008  /* igd_param_t.display_flags  */
+#define IGD_DISPLAY_BATCH_BLITS   0x00000010
 	/*! @brief enable dynamic blending of display frame buffer with overlay */
 
 
@@ -640,6 +641,8 @@ typedef struct _igd_config_info {
 	unsigned long stolen_memory_base_virt;
 	/* pixel format that matches the bpp that was passed in */
 	unsigned long pixel_format;
+	/* port-specific rotation read from DisplayID */
+	igd_DID_rotation_info_t displayid_rotation[IGD_MAX_PORTS];
 } igd_config_info_t;
 
 
diff --git a/drivers/staging/emgd/include/igd_mode.h b/drivers/staging/emgd/include/igd_mode.h
index dcaf863..4a8a68f 100644
--- a/drivers/staging/emgd/include/igd_mode.h
+++ b/drivers/staging/emgd/include/igd_mode.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_mode.h
- * $Revision: 1.14 $
+ * $Revision: 1.15 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -376,6 +376,11 @@ typedef void* igd_driver_h;
  * - IGD_DISPLAY_CONFIG_TWIN: Two (or more) displays using a single display
  *    pipe. In this configuration a single set of display timings are
  *    used for multiple displays.
+ * - IGD_DISPLAY_CONFIG_VEXT: Two (or more) displays making use of two
+ *    display pipes and two display planes, however only one contiguous
+ *    Frame buffer has been allocated that spans bothe displays vertically.
+ *    In this configuration two sets of display timings are used and two
+ *    source data planes.
  * - IGD_DISPLAY_CONFIG_EXTENDED: Two (or more) displays making use of two
  *    display pipes and two display planes. In this configuration two sets
  *    of display timings are used and two source data planes.
@@ -385,6 +390,7 @@ typedef void* igd_driver_h;
 #define IGD_DISPLAY_CONFIG_SINGLE   0x1
 #define IGD_DISPLAY_CONFIG_CLONE    0x2
 #define IGD_DISPLAY_CONFIG_TWIN     0x4
+#define IGD_DISPLAY_CONFIG_VEXT	    0x5
 #define IGD_DISPLAY_CONFIG_EXTENDED 0x8
 #define IGD_DISPLAY_CONFIG_MASK     0xf
 /*! @} */
@@ -416,6 +422,11 @@ typedef void* igd_driver_h;
  */
 #define IGD_DC_CLONE(dc)    ((dc & 0xf) == IGD_DISPLAY_CONFIG_CLONE)
 /*!
+ * @name IGD_DC_VEXT
+ * For a given dc, return true if it is in vertically extended display mode
+ */
+#define IGD_DC_VEXT(dc) ((dc & 0xf) == IGD_DISPLAY_CONFIG_VEXT)
+/*!
  * @name IGD_DC_EXTENDED
  * For a given dc, return true if it is in extended display mode
  */
diff --git a/drivers/staging/emgd/include/igd_ovl.h b/drivers/staging/emgd/include/igd_ovl.h
index 6a4f355..4e0491f 100644
--- a/drivers/staging/emgd/include/igd_ovl.h
+++ b/drivers/staging/emgd/include/igd_ovl.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_ovl.h
- * $Revision: 1.13 $
+ * $Revision: 1.14 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -83,6 +83,10 @@
 #define IGD_OVL_FORCE_USE_DISP   0x10
 #define IGD_OVL_OSD_ON_SPRITEC   0x20
 #define IGD_OVL_GET_SURFACE_DATA 0x50
+
+/* Note: VEXT: Keep this bitwise! */
+#define IGD_OVL_ALTER_VEXT_PRIMARY			0x100
+#define IGD_OVL_ALTER_VEXT_SECONDARY		0x200
 /*! @} */
 
 /* These are not actually used by any IAL
@@ -293,6 +297,7 @@ typedef struct _ovl_um_context {
 	/* OVLADD add additional overlay initialization parameters here. */
 
 	int in_dihclone;
+	int vext;
 	int chiptype;
 	void *dispatch; /* can't make this igd_dispatch_t due to circular reference */
 	unsigned long dc;
diff --git a/drivers/staging/emgd/include/igd_pd.h b/drivers/staging/emgd/include/igd_pd.h
index 21c4a99..51164d0 100644
--- a/drivers/staging/emgd/include/igd_pd.h
+++ b/drivers/staging/emgd/include/igd_pd.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_pd.h
- * $Revision: 1.11 $
+ * $Revision: 1.12 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -427,6 +427,11 @@
 	{id, type, name, flags, def, cur, a, b, c}
 #endif
 
+typedef struct _igd_DID_rotation_info_t {
+	int rotation;
+	int flip;
+} igd_DID_rotation_info_t;
+
 /* IMP NOTE: All below structures should be with same size.
  *         igd_attr_t            : General attribute structure
  *         igd_range_attr_t      : Range type attribute structure
diff --git a/drivers/staging/emgd/include/igd_version.h b/drivers/staging/emgd/include/igd_version.h
index df10e88..b96a3d5 100644
--- a/drivers/staging/emgd/include/igd_version.h
+++ b/drivers/staging/emgd/include/igd_version.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_version.h
- * $Revision: 1.190 $
+ * $Revision: 1.192 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -34,8 +34,8 @@
 #define _IGD_VERSION_H
 
 #define IGD_MAJOR_NUM  1
-#define IGD_MINOR_NUM  10
-#define IGD_BUILD_NUM  2335
+#define IGD_MINOR_NUM  14
+#define IGD_BUILD_NUM  2348
 
 #define IGD_PCF_VERSION   0x00000400
 #endif
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
index 41377d8..211fb60 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
@@ -308,7 +308,7 @@ emgd_error_t bc_ts_uninit(IMG_UINT32 id) {
     if (psDevInfo == NULL){
         return (EMGD_ERROR_GENERIC);
     }
-  	EMGD_DEBUG("To Unregister the Device: ID - %lu, RefCount - %lu, idx - %lu",
+	EMGD_DEBUG("To Unregister the Device: ID - %lu, RefCount - %lu, idx - %lu",
   		psDevInfo->Device_ID,
   		psDevInfo->ulRefCount,
   		psDevInfo->sBufferInfo.ui32BufferDeviceID);
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
index d382a13..a79e276 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
@@ -425,7 +425,7 @@ int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_cont
 
 	if (p->count < 1) {
   		return -1;
-  	}
+	}
 
     if (p->width <= 1 || p->height <= 1) {
         return -1;
@@ -474,7 +474,7 @@ int BC_CreateBuffers(BC_DEVINFO *psDevInfo, bc_buf_params_t *p, IMG_BOOL is_cont
     	if (psDevInfo->sBufferInfo.ui32Width != p->width
     		|| psDevInfo->sBufferInfo.ui32Height != p->height
     		|| psDevInfo->sBufferInfo.ui32ByteStride != p->stride
-    		|| psDevInfo->sBufferInfo.pixelformat != pixel_fmt
+		|| psDevInfo->sBufferInfo.pixelformat != pixel_fmt
     		|| psDevInfo->buf_type != p->type) {
 
 			EMGD_ERROR("Request invalid buffers");
diff --git a/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c b/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c
index e01a837..b6d7a8b 100644
--- a/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c
+++ b/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c
@@ -830,6 +830,7 @@ static PVRSRV_ERROR DestroyDCSwapChain(PVRSRV_DC_SWAPCHAIN *psSwapChain)
 	PVRSRV_ERROR				eError;
 	PVRSRV_DISPLAYCLASS_INFO	*psDCInfo = psSwapChain->psDCInfo;
 	IMG_UINT32 i;
+	int timeout = 30;
 
 
 
@@ -856,8 +857,14 @@ static PVRSRV_ERROR DestroyDCSwapChain(PVRSRV_DC_SWAPCHAIN *psSwapChain)
 		}
 	}
 
-
-	PVRSRVDestroyCommandQueueKM(psSwapChain->psQueue);
+    do
+    {
+        eError = PVRSRVDestroyCommandQueueKM(psSwapChain->psQueue);
+    } while (eError != PVRSRV_OK && (timeout-- > 0));
+	if (eError != PVRSRV_OK)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"DestroyDCSwapChainCallBack: Failed to destroy command queue"));
+	}
 
 
 	eError = psDCInfo->psFuncTable->pfnDestroyDCSwapChain(psDCInfo->hExtDevice,
@@ -970,6 +977,7 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 	PVRSRV_ERROR eError;
 	IMG_UINT32 i;
 	DISPLAY_INFO sDisplayInfo;
+	int timeout = 30;
 
 
 	if(!hDeviceKM
@@ -1032,10 +1040,15 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 		eError = PVRSRV_ERROR_OUT_OF_MEMORY;
 		goto ErrorExit;
 	}
+
 	OSMemSet (psSwapChain, 0, sizeof(PVRSRV_DC_SWAPCHAIN));
 
+    // try few times to get the lock
+    do
+    {
+        eError = PVRSRVCreateCommandQueueKM(1024, &psQueue);
+    } while (eError != PVRSRV_OK && (timeout-- > 0));
 
-	eError = PVRSRVCreateCommandQueueKM(1024, &psQueue);
 	if(eError != PVRSRV_OK)
 	{
 		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Failed to create CmdQueue"));
-- 
1.7.4.1

