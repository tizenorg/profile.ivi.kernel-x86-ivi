From 41587d38688fba4f7a0d62068ee3198abb55e830 Mon Sep 17 00:00:00 2001
From: Liu Xinyun <xinyun.liu@linux.intel.com>
Date: Thu, 19 Apr 2012 13:24:36 +0800
Subject: [PATCH 1/3] imported EMGD 2443 build from ECG

---
 drivers/staging/emgd/emgd/display/dsp/cmn/dsp.c    |    3 +-
 .../emgd/emgd/display/mode/cmn/micro_mode.c        |   14 +-
 .../emgd/emgd/display/mode/tnc/kms_mode_tnc.c      |  125 +-
 .../staging/emgd/emgd/display/mode/tnc/mode_tnc.c  |   26 +-
 drivers/staging/emgd/emgd/drm/drm_emgd_private.h   |    8 +-
 drivers/staging/emgd/emgd/drm/emgd_crtc.c          |   17 +-
 drivers/staging/emgd/emgd/drm/emgd_encoder.c       |    7 +-
 drivers/staging/emgd/emgd/drm/emgd_fb.c            |   14 +-
 drivers/staging/emgd/emgd/drm/emgd_fbcon.c         |   10 +-
 drivers/staging/emgd/emgd/drm/emgd_interface.c     |  139 +-
 drivers/staging/emgd/emgd/drm/user_config.c        |    4 +-
 drivers/staging/emgd/emgd/gmm/gmm.c                |  378 ++-
 drivers/staging/emgd/emgd/include/memlist.h        |    3 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036.c      |  106 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036.h      |    2 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c |  355 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.h |   10 +-
 .../emgd/emgd/pal/ch7036/ch7036_def_regmap.h       |    2 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c   |  339 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.h   |   92 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.c  |   61 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.h  |   12 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c | 1479 ++++-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.h |   91 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_pm.c   |   86 +-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c |  866 ++-
 drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.h |    2 +-
 .../emgd/emgd/pal/ch7036/ch7036_reg_table.c        |  370 +-
 .../emgd/emgd/pal/ch7036/ch7036_reg_table.h        |    9 +-
 .../staging/emgd/emgd/pal/ch7036/ch7036_typedef.h  |   40 +-
 drivers/staging/emgd/emgd/pal/ch7036/config_.h     |   30 +-
 drivers/staging/emgd/emgd/pal/ch7036/edid7036.car  | 3362 ++++++++++
 drivers/staging/emgd/emgd/pal/ch7036/hdcp7036.car  | 6782 --------------------
 drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.c   |   40 +-
 drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.h   |    5 +-
 drivers/staging/emgd/emgd/pal/sdvo/sdvo_port.c     |   35 +-
 drivers/staging/emgd/emgd/video/msvdx/msvdx.c      |   10 +-
 .../staging/emgd/emgd/video/overlay/plb/ovl_plb.c  |    4 +-
 .../staging/emgd/emgd/video/overlay/tnc/ovl2_tnc.c |   32 +-
 .../staging/emgd/emgd/video/overlay/tnc/ovl_tnc.c  |    4 +-
 drivers/staging/emgd/include/emgd_drm.h            |   23 +-
 drivers/staging/emgd/include/igd.h                 |   13 +-
 drivers/staging/emgd/include/igd_gmm.h             |    6 +-
 drivers/staging/emgd/include/igd_mode.h            |   18 +-
 drivers/staging/emgd/include/igd_ovl.h             |    5 +-
 drivers/staging/emgd/include/igd_pd.h              |    3 +-
 drivers/staging/emgd/include/igd_render.h          |    4 +-
 drivers/staging/emgd/include/igd_version.h         |    4 +-
 drivers/staging/emgd/pvr/include4/servicesext.h    |    1 +
 .../services4/3rdparty/emgd_bufferclass/emgd_bc.c  |   18 +-
 .../services4/3rdparty/emgd_bufferclass/emgd_bc.h  |   12 +
 .../3rdparty/emgd_bufferclass/emgd_bc_linux.c      |   53 +-
 .../services4/3rdparty/emgd_displayclass/emgd_dc.c |  206 +-
 .../services4/3rdparty/emgd_displayclass/emgd_dc.h |    2 +
 .../staging/emgd/pvr/services4/include/sgxinfo.h   |    4 +
 .../emgd/pvr/services4/srvkm/common/deviceclass.c  |   55 +-
 .../pvr/services4/srvkm/devices/sgx/sgxtransfer.c  |    4 +
 .../emgd/pvr/services4/srvkm/env/linux/event.c     |    2 +
 58 files changed, 7133 insertions(+), 8274 deletions(-)
 create mode 100644 drivers/staging/emgd/emgd/pal/ch7036/edid7036.car
 delete mode 100755 drivers/staging/emgd/emgd/pal/ch7036/hdcp7036.car

diff --git a/drivers/staging/emgd/emgd/display/dsp/cmn/dsp.c b/drivers/staging/emgd/emgd/display/dsp/cmn/dsp.c
index 77daf7a..d4abefb 100755
--- a/drivers/staging/emgd/emgd/display/dsp/cmn/dsp.c
+++ b/drivers/staging/emgd/emgd/display/dsp/cmn/dsp.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: dsp.c
- * $Revision: 1.26 $
+ * $Revision: 1.27 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -2298,6 +2298,7 @@ void dsp_shutdown(igd_context_t *context)
 		 * to their defaults when the HAL is shutting down or else they
 		 * would retain their previous values.
 		 */
+		hal_attr_index = 0;
 		while (PD_ATTR_LIST_END != port->attributes[hal_attr_index].id) {
 			port->attributes[hal_attr_index].current_value =
 				port->attributes[hal_attr_index].default_value;
diff --git a/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c b/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c
index a6e20c0..5d615aa 100644
--- a/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c
+++ b/drivers/staging/emgd/emgd/display/mode/cmn/micro_mode.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: micro_mode.c
- * $Revision: 1.31 $
+ * $Revision: 1.32 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1108,6 +1108,7 @@ int igd_alter_displays(
 	igd_display_context_t **secondary = (igd_display_context_t **)_secondary;
 	igd_framebuffer_info_t *fb_info = NULL;
 	igd_display_context_t *display = NULL,*tv_display=NULL;
+	drm_emgd_priv_t *priv = ((struct drm_device *)context->drm_dev)->dev_private;
 	int p;
 	int ret;
 	unsigned short tv_port_num=0;
@@ -1206,6 +1207,10 @@ int igd_alter_displays(
 		 * external clock needs to be on till the pipes and
 		 * DPLLs are off
 		 */
+				/* Invalidate flip-chains to avoid race conditions during the
+				 * mode-set */
+				priv->invalidate_flip_chains(IGD_DISPLAY_SECONDARY);
+
 				if(PORT(display,DC_PORT_NUMBER(current_dc, p))->pd_type ==
 					PD_DISPLAY_TVOUT) {
 					tv_display = display;
@@ -1235,6 +1240,10 @@ int igd_alter_displays(
 		 * external clock needs to be on till the pipes and
 		 * DPLLs are off
 		 */
+				/* Invalidate flip-chains to avoid race conditions during the
+				 * mode-set */
+				priv->invalidate_flip_chains(IGD_DISPLAY_PRIMARY);
+
 				if(PORT(display,DC_PORT_NUMBER(current_dc, p))->pd_type ==
 					PD_DISPLAY_TVOUT) {
 					tv_display = display;
@@ -1273,6 +1282,9 @@ int igd_alter_displays(
 	 * alter_displays at the same point with the same valid DC */
 	if (!dc) {
 		int i;
+
+		priv->invalidate_flip_chains(IGD_DISPLAY_ALL);
+
 		mode_context->dispatch->reset_plane_pipe_ports(mode_context->context);
 		/* Should de-allocate everything here */
 		dsp_alloc(driver_handle, dc, flags);
diff --git a/drivers/staging/emgd/emgd/display/mode/tnc/kms_mode_tnc.c b/drivers/staging/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
index a3aa69d..53c2c71 100644
--- a/drivers/staging/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
+++ b/drivers/staging/emgd/emgd/display/mode/tnc/kms_mode_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: kms_mode_tnc.c
- * $Revision: 1.3 $
+ * $Revision: 1.5 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -583,6 +583,7 @@ static void kms_set_pipe_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
 {
 	unsigned long       pipe_conf;
 	unsigned long       port_type;
+	unsigned long 		temp;
 	struct drm_device  *dev;
 	igd_display_pipe_t *pipe;
 	igd_context_t      *context;
@@ -596,8 +597,8 @@ static void kms_set_pipe_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
 
 	pipe      = emgd_crtc->igd_pipe;
 	port_type = get_port_type(emgd_crtc->crtc_id);
-	pipe_conf = device_data_tnc->pipe_preserve &
-					READ_MMIO_REG_TNC(port_type, pipe->pipe_reg);
+	pipe_conf = READ_MMIO_REG_TNC(port_type, pipe->pipe_reg);
+
 
 	/* Do nothing if current power state is same as what we want to set */
 	/* The PIPE_ENABLE bit is at bit-position 31 */
@@ -622,10 +623,16 @@ static void kms_set_pipe_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
 		/* check when the pipe is disabled. */
 		wait_pipe(port_type, pipe->pipe_reg, 0);
 
-		/* Disable DPLL */
-		//WRITE_MMIO_REG_TNC(pt, PIPE(display)->clock_reg->dpll_control,
-		//	READ_MMIO_REG_TNC(pt,
-		//		PIPE(display)->clock_reg->dpll_control) & ~0x80000000L);
+		/* Make sure the associated DPLL is turned off. */
+		temp = READ_MMIO_REG_TNC(port_type, pipe->clock_reg->dpll_control);
+		if (temp & BIT31) {
+			/* Double buffered */
+			WRITE_MMIO_REG_TNC(port_type, pipe->clock_reg->dpll_control,
+				temp & ~BIT31);
+			WRITE_MMIO_REG_TNC(port_type, pipe->clock_reg->dpll_control,
+				temp & ~BIT31);
+		}
+
 
 		EMGD_DEBUG("Set Pipe Power: OFF");
 
@@ -676,6 +683,7 @@ static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc)
 	emgd_encoder_t     *emgd_encoder = NULL;
 	pd_timing_t        *vga_timing   = NULL;
 
+	unsigned long flag_clip_fix;
 	unsigned long pipe_reg;
 	unsigned long temp;
 	unsigned long pt;
@@ -684,6 +692,7 @@ static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc)
 	int           i;
 	tnc_wa_timing_t *wa;
 	/* igd_framebuffer_info_t *fb_info = PLANE(display)->fb_info; */
+	platform_context_tnc_t *platform_context;
 
 	EMGD_TRACE_ENTER;
 
@@ -696,10 +705,48 @@ static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc)
 	dev      = ((struct drm_crtc *)(&emgd_crtc->base))->dev;
 	context  = ((drm_emgd_priv_t *)dev->dev_private)->context;
 
+	platform_context = (platform_context_tnc_t *) mode_context->context->platform_context;
+	flag_clip_fix    = mode_context->clip_hw_fix;
+
 	EMGD_DEBUG("Device power state: D%ld", context->device_context.power_state);
 
-	pipe_conf = device_data_tnc->pipe_preserve &
-		READ_MMIO_REG_TNC(pt, pipe->pipe_reg);
+	pipe_conf = READ_MMIO_REG_TNC(pt, pipe->pipe_reg);
+
+	/* Preserving bits 0:17, bit 20, bit 24, bit 26, bit 29:30.  The spec on
+	 * which bits to preserve has been updated since we've originally written
+	 * the code for the non-KMS path.  However, to minimize risk of this fix,
+	 * we are only updating them here.  This is why we are not using
+	 * device_data_tnc->pipe_preserve.  */
+	pipe_conf &= 0x6513FFFF;
+
+	/* For TNC B1, enable hardware cliping fix*/
+	if((platform_context->tnc_dev3_rid == TNC_B1_DEV3_RID)&&
+		(flag_clip_fix & IGD_CLIP_FIX_GLOBAL_ENABLE)) {
+
+		/* Disable SDVO Pipe in Device 2 and Device 3 */
+		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, pipe->pipe_reg,
+			pipe_conf & (~0x80000000L));
+
+		WRITE_MMIO_REG_TNC(IGD_PORT_SDVO, pipe->pipe_reg,
+			pipe_conf & (~0x80000000L));
+
+		/* check when the pipe is disabled. */
+		wait_pipe(IGD_PORT_LVDS, pipe->pipe_reg, 0);
+
+		/* Enable clipping hardware fix */
+		temp = READ_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS);
+		if(flag_clip_fix & IGD_CLIP_FIX_REPLACE_STALL) {
+			temp |= BIT18;
+		} else {
+			temp &= ~BIT18;
+		}
+		if(flag_clip_fix & IGD_CLIP_FIX_DISABLE_THROTTLE) {
+			temp |= BIT15;
+		} else {
+			temp &= ~BIT15;
+		}
+		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS, temp);
+	}
 
 	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 		if (((struct drm_crtc *)(&emgd_crtc->base)) == encoder->crtc) {
@@ -927,6 +974,7 @@ static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc)
 			pipe_conf &= ~(INTERLACE_EN);
 		}
 
+		pipe_conf |= PIPE_ENABLE;
 		WRITE_MMIO_REG_TNC(ports_tnc[i], pipe->pipe_reg, pipe_conf);
 		WRITE_MMIO_REG_TNC(ports_tnc[i], pipe->pipe_reg, pipe_conf);
 
@@ -966,7 +1014,8 @@ static void kms_program_pipe_tnc(emgd_crtc_t *emgd_crtc)
 		/*  Enable Chicken Bit */
 		/*  Setting BIT6 enable Pipe B Palette Write
          *  to prevent hang during palette write */
-		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, 0x70400, 0x4088 | BIT6);
+		temp = READ_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS);
+		WRITE_MMIO_REG_TNC(IGD_PORT_LVDS, DSP_CHICKENBITS, temp | BIT6);
 	}
 
 	EMGD_TRACE_EXIT;
@@ -1006,13 +1055,6 @@ static void kms_set_plane_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
 	plane_reg     = plane->plane_reg;
 	plane_control = EMGD_READ32(context->device_context.virt_mmadr + plane_reg);
 
-	if(plane->plane_reg == DSPACNTR) {
-		plane_control &= device_data_tnc->plane_a_preserve;
-	} else { /* if it's plane b or plane c */
-		plane_control &= device_data_tnc->plane_b_c_preserve;
-	}
-
-
 	if((enable == FALSE) ||
 		(context->device_context.power_state != IGD_POWERSTATE_D0)) {
 		/*
@@ -1022,11 +1064,22 @@ static void kms_set_plane_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
 		 */
 		disable_vga_tnc(context->device_context.virt_mmadr);
 
+		/* The Sprite and Cursor planes need to turned off for the modeset
+		   to succeed. */
+	EMGD_WRITE32(0x0, context->device_context.virt_mmadr + DSPCCNTR);
+	EMGD_WRITE32(0x0, context->device_context.virt_mmadr + DSPCCNTR + DSP_START_OFFSET);
+
+	EMGD_WRITE32(0x0, context->device_context.virt_mmadr + CUR_B_CNTR);
+	EMGD_WRITE32(0x0, context->device_context.virt_mmadr + CUR_B_CNTR + CUR_BASE_OFFSET);
+
+	EMGD_WRITE32(0x0, context->device_context.virt_mmadr + CUR_A_CNTR);
+	EMGD_WRITE32(0x0, context->device_context.virt_mmadr + CUR_B_CNTR + CUR_BASE_OFFSET);
+
 		/*
 		 * To turn off plane A or B, the program have to trigger the plane A
 		 * or B start register.  Or else, it will not work.
 		 */
-		//plane_control &= 0xEFFFFFFF;
+		plane_control &= ~BIT31;
 
 		EMGD_WRITE32(plane_control,
 						context->device_context.virt_mmadr + plane_reg);
@@ -1035,8 +1088,8 @@ static void kms_set_plane_pwr_tnc(emgd_crtc_t *emgd_crtc, unsigned long enable)
 			plane_reg + DSP_START_OFFSET),
 			context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
 	} else {
-		/* Enable Pipe */
-		plane_control |= 0x80000000;
+		/* Enable Plane */
+		plane_control |= BIT31;
 
 		EMGD_WRITE32(plane_control,
 			context->device_context.virt_mmadr + plane_reg);
@@ -1100,32 +1153,6 @@ static void kms_program_plane_tnc(emgd_crtc_t *emgd_crtc, unsigned long status)
 	}
 
 
-	if((status == FALSE) ||
-		(context->device_context.power_state != IGD_POWERSTATE_D0)) {
-
-		/*
-		 * Note: The vga programming code does not have an "off". So
-		 * when programming the plane to off we make sure VGA is off
-		 * as well.
-		 */
-		disable_vga_tnc(context->device_context.virt_mmadr);
-
-		/*
-		 * To turn off plane A or B, the program have to triger the plane A or B
-		 * start register.  Or else, it will not work.
-		 */
-		EMGD_WRITE32(plane_control,
-						context->device_context.virt_mmadr + plane_reg);
-
-		EMGD_WRITE32(EMGD_READ32(context->device_context.virt_mmadr +
-			plane_reg + DSP_START_OFFSET),
-			context->device_context.virt_mmadr + plane_reg + DSP_START_OFFSET);
-
-		wait_for_vblank_tnc(pipe->pipe_reg);
-		EMGD_TRACE_EXIT;
-		return;
-	}
-
 	/*
 	 * Note: The very first pass through this function will be with
 	 * status false and timings == NULL. Don't use the timings before
@@ -1146,7 +1173,7 @@ static void kms_program_plane_tnc(emgd_crtc_t *emgd_crtc, unsigned long status)
 	disable_vga_tnc(context->device_context.virt_mmadr);
 
 	/* enable plane, select pipe, enable gamma correction logic */
-	plane_control |= 0x80000000 | (pipe->pipe_num<<24);
+	plane_control |= (pipe->pipe_num<<24);
 	pipe->plane = plane;
 	plane_control |= (1<<30);
 
@@ -1438,7 +1465,6 @@ static int kms_program_port_sdvo_tnc(emgd_encoder_t *emgd_encoder,
 {
 	unsigned long port_control;
 	unsigned long pd_powerstate = PD_POWER_MODE_D3;
-	unsigned long preserve = 0;
 	unsigned long upscale = 0;
 	igd_timing_info_t  local_timing;
 	igd_timing_info_t  *timing    = NULL;
@@ -1472,8 +1498,7 @@ static int kms_program_port_sdvo_tnc(emgd_encoder_t *emgd_encoder,
 
 	timing = pipe->timing;
 
-	port_control = preserve & READ_MMIO_REG_TNC(IGD_PORT_SDVO,
-			port->port_reg);
+	port_control = READ_MMIO_REG_TNC(IGD_PORT_SDVO, port->port_reg);
 
 	if (status == TRUE) {
 		if (!(port->pt_info->flags & IGD_DISPLAY_ENABLE)) {
diff --git a/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c b/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c
index 4cc2d79..ccb825a 100644
--- a/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c
+++ b/drivers/staging/emgd/emgd/display/mode/tnc/mode_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: mode_tnc.c
- * $Revision: 1.33 $
+ * $Revision: 1.35 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -15,7 +15,6 @@
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
  *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
@@ -850,11 +849,16 @@ static int igd_set_surface_tnc(igd_display_h display_handle,
 			EMGD_ERROR("Display surface offset %lu is not 256kb aligned", surface->offset);
 		}
 
-		/* calculate the visible offset, taking panning into account */
-		visible_offset =
-			(PORT_OWNER(display)->pt_info->y_offset * surface->pitch) +
-			(PORT_OWNER(display)->pt_info->x_offset *
-				IGD_PF_BYPP(surface->pixel_format));
+		if (flags & IGD_BUFFER_NO_PAN) {
+			/* Do not pan. Set visible_offset to zero */
+			visible_offset = 0;
+		} else {
+			/* calculate the visible offset, taking panning into account */
+			visible_offset =
+				(PORT_OWNER(display)->pt_info->y_offset * surface->pitch) +
+				(PORT_OWNER(display)->pt_info->x_offset *
+					IGD_PF_BYPP(surface->pixel_format));
+		}
 		EMGD_DEBUG("visible surface_offset = 0x%08lx", visible_offset);
 
 		/* Save new fb_info */
@@ -1686,7 +1690,11 @@ int request_vblanks_tnc(unsigned long request_for, unsigned char *mmio)
 
 		}
 		vblank_interrupt_state |= request_for;
-		vblank_interrupt_ref_cnt_port2++;
+		/* Since there is only  one vblank interrupt per request for now,
+		   add counter have been remove for now and disable it when end request.
+		   The counter may required after there is more than one request in future.
+		*/
+		vblank_interrupt_ref_cnt_port2 = 1;
 	} else /* if (request_for & VBLANK_INT4_PORT4) */ {
 		if (!VBLANK_INTERRUPTS_ENABLED4_PORT4) {
 			/* 1. Change Pipe Display Status Register for this pipe: set the
@@ -1766,7 +1774,7 @@ int end_request_tnc(unsigned long request_for, unsigned char *mmio)
 	 */
 	if (request_for & VBLANK_INT4_PORT2) {
 		/* Decrement reference count */
-		vblank_interrupt_ref_cnt_port2--;
+		vblank_interrupt_ref_cnt_port2 = 0;
 		if (0 > vblank_interrupt_ref_cnt_port2) {
 			EMGD_DEBUG("WARNING:  Disabled vblank INT too many times.");
 			vblank_interrupt_ref_cnt_port2 = 0;
diff --git a/drivers/staging/emgd/emgd/drm/drm_emgd_private.h b/drivers/staging/emgd/emgd/drm/drm_emgd_private.h
index cad47c3..ead99dd 100644
--- a/drivers/staging/emgd/emgd/drm/drm_emgd_private.h
+++ b/drivers/staging/emgd/emgd/drm/drm_emgd_private.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: drm_emgd_private.h
- * $Revision: 1.21 $
+ * $Revision: 1.22 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -97,6 +97,12 @@ typedef struct _drm_emgd_private {
 	 */
 	int (*reinit_3dd)(struct drm_device *dev);
 
+	/**
+	 * Function to invalidate the flip-chains assosciated with a display (or all
+	 * displays). Called from igd_alter_displays before a possible mode_change
+	 */
+	int (*invalidate_flip_chains)(int display);
+
 
 	/** The context is set during the DRM module load function. */
 	igd_context_t *context;
diff --git a/drivers/staging/emgd/emgd/drm/emgd_crtc.c b/drivers/staging/emgd/emgd/drm/emgd_crtc.c
index 4dfb1e1..76e0235 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_crtc.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_crtc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_crtc.c
- * $Revision: 1.3 $
+ * $Revision: 1.4 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -166,11 +166,11 @@ static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode)
 			EMGD_ERROR("No pipe timing, can't enable pipe");
 		} else {
 			EMGD_DEBUG("Calling program pipe");
-			mode_context->kms_dispatch->kms_set_pipe_pwr(emgd_crtc, TRUE);
+			mode_context->kms_dispatch->kms_program_pipe(emgd_crtc);
 
 			EMGD_DEBUG("Calling program plane");
-			//mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, TRUE);
-			mode_context->kms_dispatch->kms_program_plane(emgd_crtc, TRUE);
+			mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, TRUE);
+
 			crtc->enabled = true;
 		}
 		break;
@@ -180,9 +180,7 @@ static void emgd_crtc_dpms(struct drm_crtc *crtc, int mode)
 	case DRM_MODE_DPMS_OFF:
 		if (emgd_crtc->igd_pipe->inuse && crtc->enabled) {
 			EMGD_DEBUG("Calling program plane");
-			//mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, FALSE);
-			mode_context->kms_dispatch->kms_program_plane(emgd_crtc, FALSE);
-
+			mode_context->kms_dispatch->kms_set_plane_pwr(emgd_crtc, FALSE);
 
 			EMGD_DEBUG("Calling program pipe");
 			mode_context->kms_dispatch->kms_set_pipe_pwr(emgd_crtc, FALSE);
@@ -374,12 +372,7 @@ static void emgd_crtc_prepare(struct drm_crtc *crtc)
 
 static void emgd_crtc_commit(struct drm_crtc *crtc)
 {
-	emgd_crtc_t *emgd_crtc = NULL;
-
 	EMGD_TRACE_ENTER;
-
-	emgd_crtc = container_of(crtc, emgd_crtc_t, base);
-	mode_context->kms_dispatch->kms_program_pipe(emgd_crtc);
 	emgd_crtc_dpms(crtc, DRM_MODE_DPMS_ON);
 
 	EMGD_TRACE_EXIT;
diff --git a/drivers/staging/emgd/emgd/drm/emgd_encoder.c b/drivers/staging/emgd/emgd/drm/emgd_encoder.c
index 1413c91..a95aad0 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_encoder.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_encoder.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_encoder.c
- * $Revision: 1.2 $
+ * $Revision: 1.3 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -349,9 +349,12 @@ static void emgd_encoder_commit(struct drm_encoder *encoder)
 		emgd_crtc = container_of(encoder->crtc, emgd_crtc_t, base);
 		pipe      = emgd_crtc->igd_pipe;
 
+		mode_context->kms_dispatch->kms_program_port(emgd_encoder,
+			IGD_DISPLAY_ENABLE);
+/*
 		port->pd_driver->set_mode(port->pd_context, pipe->timing,
 								1<<pipe->pipe_num);
-
+*/
 		encoder_funcs = encoder->helper_private;
 		encoder_funcs->dpms(encoder, DRM_MODE_DPMS_ON);
 
diff --git a/drivers/staging/emgd/emgd/drm/emgd_fb.c b/drivers/staging/emgd/emgd/drm/emgd_fb.c
index 83f91bd..9fc0335 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_fb.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_fb.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_fb.c
- * $Revision: 1.9 $
+ * $Revision: 1.11 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -694,6 +694,7 @@ void emgd_modeset_init(struct drm_device *dev)
 {
 	drm_emgd_priv_t *devpriv = (drm_emgd_priv_t *)dev->dev_private;
 	int ret;
+	struct drm_encoder *encoder;
 
 	EMGD_TRACE_ENTER;
 	drm_mode_config_init(dev);  /* drm helper function */
@@ -726,6 +727,15 @@ void emgd_modeset_init(struct drm_device *dev)
 	drm_mode_create_scaling_mode_property(dev);
 	emgd_setup_outputs(dev);
 
+	/* The encoders need to be turned off to prevent the locking of some
+	   of the registers - before doing a modeset */
+    list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+        struct drm_encoder_helper_funcs *e_funcs = encoder->helper_private;
+        (*e_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);
+    }
+
+	drm_helper_disable_unused_functions(dev);
+
 	/* Initialize the framebuffer device */
 	emgd_fbdev_init(devpriv);
 
@@ -1187,7 +1197,7 @@ static int emgd_fb_create(emgd_fbdev_t *emgd_fbdev,
 	}
 
 	priv->initfb_info.allocated = 1;
-	priv->initfb_info.visible_offset = priv->initfb_info.fb_base_offset;
+	priv->initfb_info.visible_offset = 0;
 
 	mode_cmd.handle = EMGD_INITIAL_FRAMEBUFFER;
 	mode_cmd.pitch  = priv->initfb_info.screen_pitch;
diff --git a/drivers/staging/emgd/emgd/drm/emgd_fbcon.c b/drivers/staging/emgd/emgd/drm/emgd_fbcon.c
index 012387d..bbc340b 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_fbcon.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_fbcon.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_fbcon.c
- * $Revision: 1.2 $
+ * $Revision: 1.4 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2011, Intel Corporation.
  *
@@ -258,6 +258,10 @@ static int alloc_initial_fb(emgd_fbdev_t *emgd_fbdev)
 	priv->initfb_info.height       = config_drm.height;
 	priv->initfb_info.pixel_format = IGD_PF_ARGB32;
 
+	/* The initial framebuffer is a displayable surface. */
+	priv->initfb_info.flags = (priv->initfb_info.flags & IGD_FB_FLAGS_MASK) |
+									IGD_SURFACE_DISPLAY;
+
 	ret = context->dispatch.gmm_alloc_surface(
 								&priv->initfb_info.fb_base_offset,
 								 priv->initfb_info.pixel_format,
@@ -273,7 +277,7 @@ static int alloc_initial_fb(emgd_fbdev_t *emgd_fbdev)
 	}
 
 	priv->initfb_info.allocated      = 1;
-	priv->initfb_info.visible_offset = priv->initfb_info.fb_base_offset;
+	priv->initfb_info.visible_offset = 0;
 
 
 	/* Allocate emgd_framebuffer_t */
@@ -778,7 +782,7 @@ int emgd_fbcon_initial_config(emgd_fbdev_t *emgd_fbdev)
 				secondary_mode.vrefresh      = config_drm.refresh;
 
 				mode_set_ret = drm_crtc_helper_set_mode(crtc,
-								&primary_mode,
+								&secondary_mode,
 								0, 0,
 								NULL);
 								break;
diff --git a/drivers/staging/emgd/emgd/drm/emgd_interface.c b/drivers/staging/emgd/emgd/drm/emgd_interface.c
index d3857a7..c22bff3 100644
--- a/drivers/staging/emgd/emgd/drm/emgd_interface.c
+++ b/drivers/staging/emgd/emgd/drm/emgd_interface.c
@@ -1,6 +1,6 @@
 /*-----------------------------------------------------------------------------
  * Filename: emgd_interface.c
- * $Revision: 1.186 $
+ * $Revision: 1.190 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -167,6 +167,52 @@ int emgd_get_chipset_info(struct drm_device *dev, void *arg,
 }
 
 
+int do_wait_vblank(void *display, int headline, int footline)
+{
+	int rtn;
+	int scnlne;
+	os_alarm_t timeout;
+	int ext = -99999;
+	unsigned long height = PIPE((igd_display_context_t *)display)->timing->height;
+
+	/*EMGD_TRACE_ENTER;*/
+
+	if (footline + 50 > height)
+		ext = IGD_IN_VBLANK;
+
+	timeout = OS_SET_ALARM(50);
+	do {
+		/* Call the HAL: */
+		rtn = dispatch->get_scanline((igd_display_context_t *)display, &scnlne);
+		if (rtn || (scnlne >= footline && scnlne <= footline + 50) || ext == scnlne) {
+			break;
+		}
+		OS_SCHEDULE();
+	} while (!OS_TEST_ALARM(timeout));
+
+	/*EMGD_DEBUG("rtn = %d", rtn);*/
+	/*EMGD_TRACE_EXIT;*/
+	return 0;
+}
+
+/*!
+ * IOCTL to bridge the IAL to the HAL's wait_vblank() procedure.
+ */
+int emgd_wait_vblank(struct drm_device *dev, void *arg,
+	struct drm_file *file_priv)
+{
+	int rtn;
+	emgd_drm_driver_set_sync_refresh_t *refresh = arg;
+	igd_display_h *display_handle = &(refresh->display_handle);
+
+	/*EMGD_TRACE_ENTER;*/
+	rtn = do_wait_vblank((igd_display_context_t *)(*display_handle), refresh->start_line, refresh->bottom_line);
+
+	/*EMGD_DEBUG("rtn = %d", rtn);*/
+	/*EMGD_TRACE_EXIT;*/
+	return 0;
+} /* emgd_wait_vblank() */
+
 /*!
  * IOCTL to bridge the IAL to the HAL's alter_cursor() procedure.
  */
@@ -655,6 +701,10 @@ int emgd_get_attrs(struct drm_device *dev, void *arg,
 		i++;
 	}
 
+	if(drm_data->port_number == IGD_PORT_TYPE_LVDS) {
+		/* LVDS port driver returns +1 is to include the end attribute */
+		ext_cnt++;
+	}
 	if (drm_data->extended) {
 		drm_data->list_size = ext_cnt; /* size of extension list */
 
@@ -696,6 +746,7 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 		(igd_display_context_t *) drm_data->display_handle;
 	drm_emgd_priv_t *priv = dev->dev_private;
 	int dc, port_num;
+	int do_reinit_3dd = 1;
 
 	EMGD_TRACE_ENTER;
 
@@ -716,6 +767,11 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 	dc = *(context->mod_dispatch.dsp_current_dc);
 	port_num = drm_data->port_number;
 
+	if (drm_data->flags & IGD_GET_DISPLAY_NO_3DD_REINIT){
+		do_reinit_3dd = 0;
+		drm_data->flags &= (~IGD_GET_DISPLAY_NO_3DD_REINIT);
+	}
+
 	/* Call the HAL: */
 	drm_data->rtn = dispatch->get_display(drm_data->display_handle,
 		drm_data->port_number,
@@ -735,19 +791,21 @@ int emgd_get_display(struct drm_device *dev, void *arg,
 	 * combination. Also, we may not have to call reinit_3dd() as this is already done
 	 * as a part of configuring the primary.
 	 */
-	if(mode_context->seamless && !(IGD_DC_CLONE(dc) && port_num == priv->secondary_port_number)) {
-		if (priv->reinit_3dd) {
-			if(IGD_DC_VEXT(drm_emgd_dc)) {
-				priv->dc = drm_emgd_dc;
-			} else {
-				priv->dc = *(context->mod_dispatch.dsp_current_dc);
+	if (do_reinit_3dd) {
+		if(mode_context->seamless && !(IGD_DC_CLONE(dc) && port_num == priv->secondary_port_number)) {
+			if (priv->reinit_3dd) {
+				if(IGD_DC_VEXT(drm_emgd_dc)) {
+					priv->dc = drm_emgd_dc;
+				} else {
+					priv->dc = *(context->mod_dispatch.dsp_current_dc);
+				}
+				EMGD_DEBUG("priv->dc = 0x%lX", priv->dc);
+				priv->primary = drm_data->display_handle;
+				priv->secondary = NULL;
+				priv->primary_port_number = (priv->dc & 0xf0) >> 4;
+				priv->secondary_port_number = (priv->dc & 0xf00000) >> 20;
+				priv->reinit_3dd(dev);
 			}
-			EMGD_DEBUG("priv->dc = 0x%lX", priv->dc);
-			priv->primary = drm_data->display_handle;
-			priv->secondary = NULL;
-			priv->primary_port_number = (priv->dc & 0xf0) >> 4;
-			priv->secondary_port_number = (priv->dc & 0xf00000) >> 20;
-			priv->reinit_3dd(dev);
 		}
 	}
 
@@ -1719,61 +1777,6 @@ int emgd_dihclone_set_surface(struct drm_device *dev, void *arg,
 		}
 	}
 
-
-/* setting fake clone (dih clone) mode */
-
-
-	/*first save the display's original offset  */
-	surf.offset = pipe1->plane->fb_info->fb_base_offset;
-	drm_data->rtn = dispatch->set_surface(display,
-			IGD_PRIORITY_NORMAL,
-			IGD_BUFFER_SAVE,
-			&surf,
-			NULL,
-			0);
-
-	display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
-	surf.offset = pipe2->plane->fb_info->fb_base_offset;
-	drm_data->rtn = dispatch->set_surface(display,
-		IGD_PRIORITY_NORMAL,
-		IGD_BUFFER_SAVE,
-		&surf,
-		NULL,
-		0);
-
-	/* primary display */
-
-	if( drm_data->dih_clone_display == CLONE_PRIMARY){
-		surf.offset = pipe1->plane->fb_info->fb_base_offset;
-	} else {
-
-		surf.offset = pipe2->plane->fb_info->fb_base_offset;
-	}
-
-	display = context->mod_dispatch.dsp_display_list[IGD_DC_PRIMARY(dc)];
-	/* Call the HAL: */
-	drm_data->rtn = dispatch->set_surface(display,
-		IGD_PRIORITY_NORMAL,
-		IGD_BUFFER_DISPLAY,
-		&surf,
-		NULL,
-		0);
-
-	/* secondary display */
-
-	display = context->mod_dispatch.dsp_display_list[IGD_DC_SECONDARY(dc)];
-
-	drm_data->rtn = dispatch->set_surface(display,
-		IGD_PRIORITY_NORMAL,
-		IGD_BUFFER_DISPLAY,
-		&surf,
-		NULL,
-		0);
-
-	if(drm_data->rtn == 0){
-		context->mod_dispatch.in_dih_clone_mode = true;
-		context->mod_dispatch.dih_clone_display = drm_data->dih_clone_display;
-	}
 	EMGD_DEBUG("drm_data->rtn = %d", drm_data->rtn);
 
 	EMGD_DEBUG("Returning 0");
diff --git a/drivers/staging/emgd/emgd/drm/user_config.c b/drivers/staging/emgd/emgd/drm/user_config.c
index 6729e7b..cea78e1 100644
--- a/drivers/staging/emgd/emgd/drm/user_config.c
+++ b/drivers/staging/emgd/emgd/drm/user_config.c
@@ -218,7 +218,7 @@ igd_param_t *config_params = {&config_params_config1};
  * for the EMGD kernel module.
  */
 emgd_drm_config_t config_drm = {
-	1,	/* Whether to initialize the display at EMGD module startup time
+	0,	/* Whether to initialize the display at EMGD module startup time
 		 * (corresponds to the "init" module parameter)
 		 */
 	1,	/* The display configuration to use if initializing the display
@@ -238,7 +238,7 @@ emgd_drm_config_t config_drm = {
 	60,	/* Display refresh rate to use if initializing the display
 		 * (corresponds to the "refresh" module parameter)
 		 */
-	1,  /* KMS */
+	0,  /* KMS */
 	0,	/* ovl_brightness */
 	0,	/* ovl_contrast */
 	0,	/* ovl_saturation */
diff --git a/drivers/staging/emgd/emgd/gmm/gmm.c b/drivers/staging/emgd/emgd/gmm/gmm.c
index 6677c7a..c4d528c 100644
--- a/drivers/staging/emgd/emgd/gmm/gmm.c
+++ b/drivers/staging/emgd/emgd/gmm/gmm.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: gmm.c
- * $Revision: 1.50 $
+ * $Revision: 1.52 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -37,9 +37,21 @@
 #include <io.h>
 #include <memory.h>
 
+#include <linux/module.h>
+#include <linux/init.h>
+
 #include <asm/agp.h>
 
 #define AGP_PHYS_MEMORY 2 /* Physical contigous memory */
+struct emgd_ci_surface_t{
+	unsigned int used;
+	unsigned int v4l2_offset;
+	unsigned int virt;
+	unsigned long size;
+	unsigned long gtt_offset;
+	};
+#define MAX_CI_LIST_SIZE 14
+struct emgd_ci_surface_t ci_surfaces[MAX_CI_LIST_SIZE];
 
 
 gmm_context_t gmm_context;
@@ -78,6 +90,15 @@ void emgd_gtt_insert(igd_context_t *context, gmm_mem_buffer_t *mem,
 		unsigned long offset);
 
 
+static int gmm_map_ci(unsigned long *gtt_offset,
+			unsigned long ci_param,
+			unsigned long *virt_addr,
+			unsigned int map_method,
+			unsigned long size);
+
+
+static int gmm_unmap_ci(unsigned long virt_addr);
+
 static void gmm_free(unsigned long offset)
 {
 	gmm_chunk_t *chunk;
@@ -508,6 +529,8 @@ int gmm_init(igd_context_t *context,
 	context->dispatch.gmm_get_page_list = gmm_get_page_list;
 	context->dispatch.gmm_get_num_surface = gmm_get_num_surface;
 	context->dispatch.gmm_get_surface_list = gmm_get_surface_list;
+	context->dispatch.gmm_map_ci = gmm_map_ci;
+	context->dispatch.gmm_unmap_ci = gmm_unmap_ci;
 
 	context->mod_dispatch.gmm_save = gmm_save;
 	context->mod_dispatch.gmm_restore = gmm_restore;
@@ -665,6 +688,302 @@ static int gmm_alloc_linear_surface(unsigned long *offset,
 
 
 
+
+/*
+ * gmm_contig_page_list(): Create the page list for a previously-allocated
+ * block of contiguous memory. (This is needed for GTT insertion, and normally
+ * created by the emgd_alloc_pages() function.)
+ */
+static gmm_mem_buffer_t *gmm_contig_page_list(unsigned long num_pages,
+			unsigned long phys_addr)
+{
+	gmm_mem_buffer_t *mem;
+	size_t list_size;
+	int i;
+	void *virt_addr = phys_to_virt(phys_addr);
+
+	mem = (gmm_mem_buffer_t *)kzalloc(sizeof(gmm_mem_buffer_t), GFP_KERNEL);
+	if (mem == NULL) {
+		printk(KERN_ERR "[EMGD] Cannot allocate gmm_mem_buffer_t ");
+		EMGD_ERROR_EXIT("Returning NULL\n");
+		return NULL;
+	}
+
+	/* First allocate page array */
+	list_size = num_pages * sizeof(struct page *);
+	mem->vmalloc_flag = false;
+
+	if (list_size <= (2 * PAGE_SIZE)) {
+		mem->pages = kmalloc(list_size, GFP_KERNEL | __GFP_NORETRY);
+	}
+
+	if (mem->pages == NULL) {
+		mem->pages = vmalloc(list_size);
+		mem->vmalloc_flag = true;
+	}
+
+	if (mem->pages == NULL) {
+		kfree(mem);
+		printk(KERN_ERR "Failed to allocate memory info struct.\n");
+		EMGD_ERROR_EXIT("Returning NULL\n");
+		return NULL;
+	}
+
+	mem->pages[0] = virt_to_page(virt_addr);
+	if (num_pages > 1) {
+		for (i = 1; i < num_pages; i++) {
+			mem->pages[i] = mem->pages[i-1] + 1;
+		}
+	}
+	mem->physical = page_to_phys(mem->pages[0]);
+	mem->page_count = num_pages;
+
+	return mem;
+}
+
+/*
+ * gmm_map_contig_buffer(): Map a previously-allocated contiguous SDRAM memory
+ * block into a graphics-accessible memory.
+ */
+
+static int gmm_map_contig_buffer(gmm_context_t *gmm_context,
+		unsigned long phys_addr,
+		unsigned long size,
+		unsigned long *offset)
+{
+	gmm_chunk_t *chunk;
+
+	EMGD_TRACE_ENTER;
+
+
+	/* Check for a free contiguous chunk of sufficent size */
+	chunk = gmm_context->head_chunk;
+
+	/* Allocate a new chunk list element */
+	chunk = (gmm_chunk_t *)OS_ALLOC(sizeof(gmm_chunk_t));
+	if (!chunk) {
+		printk(KERN_ERR "[EMGD] Cannot allocate gmm_chunk_t element");
+		EMGD_ERROR_EXIT("Returning %d", -IGD_ERROR_NOMEM);
+		return -IGD_ERROR_NOMEM;
+	}
+	OS_MEMSET(chunk, 0, sizeof(gmm_chunk_t));
+
+	/* Contiguous memory is needed, so set the type to AGP_PHYS_MEMORY */
+	chunk->size = size;
+	chunk->pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+	chunk->type = AGP_PHYS_MEMORY;
+
+	/* Create the GTT page list for this contiguous memory block */
+	chunk->gtt_mem = gmm_contig_page_list(chunk->pages, phys_addr);
+	if (chunk->gtt_mem == NULL) {
+		printk(KERN_ERR "[EMGD] Cannot allocate gmm_chunk_t element");
+		EMGD_ERROR_EXIT("Returning %d", -IGD_ERROR_NOMEM);
+		return -IGD_ERROR_NOMEM;
+	}
+
+	/* Assign the specified memory block to this chunk */
+	chunk->used = 1;
+	chunk->ref_cnt = 0;
+	chunk->page_addresses = NULL;
+
+	/* Determine the offset value for this chunk */
+	if (gmm_context->tail_chunk == NULL) {
+
+		chunk->offset = 0;
+
+	} else {
+		chunk->offset = gmm_context->tail_chunk->offset +
+			gmm_context->tail_chunk->size;
+
+
+	}
+
+
+	/* Adjust the offset since display surfaces require 256KB alignment */
+	chunk->offset = (chunk->offset + 0x3ffff) & ~0x3ffff;
+
+	/* Insert this chunk in the list */
+	chunk->next = NULL;
+	if (gmm_context->head_chunk == NULL) {
+
+		gmm_context->head_chunk = chunk;
+	} else {
+		gmm_context->tail_chunk->next = chunk;
+	}
+	gmm_context->tail_chunk = chunk;
+
+	/* Now update the GTT so the display HW can access this memory */
+	emgd_gtt_insert(gmm_context->context, chunk->gtt_mem, chunk->offset);
+
+	/* Bind the gart memory to the offset */
+	chunk->bound = 1;
+
+	/* For contiguous pages, physical is the address of the first allocated page */
+	if (chunk->gtt_mem->physical == 0x0) {
+		chunk->gtt_mem->physical = page_to_phys(chunk->gtt_mem->pages[0]);
+	}
+
+	/* Return the offset associated with this contiguous block */
+	*offset = chunk->offset;
+
+	EMGD_TRACE_EXIT;
+	return 0;
+}
+
+/*
+ * gmm_map_to_graphics(): Facilitates direct display of contiguous video input
+ * buffers by mapping the specified block into the "graphics aperture" via the
+ * GTT.
+ */
+int gmm_map_to_graphics(unsigned long phys_addr,
+	unsigned long size,
+	unsigned long *offset)
+{
+	int ret;
+
+	EMGD_TRACE_ENTER;
+
+	if (phys_addr && size) {
+		ret = gmm_map_contig_buffer(&gmm_context, phys_addr, size,
+			offset);
+
+	} else {
+		printk(KERN_ERR "Invalid address (0x%lx) and/or size (0x%lx) !",
+			phys_addr, size);
+		printk(KERN_ERR "EXIT  Returning %d", -EINVAL);
+		ret = -EINVAL;
+	}
+
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+
+/*
+ * find gtt_offset and virtual address from ci_surface list according to the same v4l2_offset
+ */
+
+static int gmm_map_ci(unsigned long *gtt_offset,
+			unsigned long ci_param,	/* virtaddr or v4l2_offset */
+			unsigned long *virt_addr,
+			unsigned int map_method,
+			unsigned long size)
+
+{
+	unsigned char i;
+	int ret;
+
+	if(map_method){
+		ret = gmm_map_to_graphics(virt_to_phys((unsigned long *)ci_param),size,gtt_offset);
+		if(ret)
+			return ret;
+		else{
+			for(i=0;i<MAX_CI_LIST_SIZE;i++){
+
+				if(!ci_surfaces[i].used){
+
+					ci_surfaces[i].used = 1;
+					ci_surfaces[i].virt = ci_param;
+					ci_surfaces[i].size = size;
+					ci_surfaces[i].gtt_offset = *gtt_offset;
+					*virt_addr = ci_param;
+					break;
+				}
+			}
+		}
+	}
+	else{
+
+		for(i=0;i<MAX_CI_LIST_SIZE;i++){
+			if(ci_surfaces[i].used && (ci_surfaces[i].v4l2_offset ==ci_param)){
+
+				*gtt_offset = ci_surfaces[i].gtt_offset;
+				*virt_addr = ci_surfaces[i].virt;
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+
+/*
+ * gmm_unmap_contig_buffer(): Un-map a previously-allocated contiguous SDRAM
+ * memory block into graphics memory.
+ */
+
+static int gmm_unmap_contig_buffer(gmm_context_t *gmm_context,
+		unsigned long offset,
+		unsigned long size)
+{
+
+	gmm_chunk_t *chunk;
+#ifdef GMM_CI_CLEANUP
+	gmm_chunk_t *del;
+#endif
+	EMGD_TRACE_ENTER;
+
+	/* Locate the specified chunk and mark it as unused */
+	chunk = gmm_context->head_chunk;
+	while (chunk) {
+		if ((chunk->used == 1) && (chunk->size >= size) &&
+			(chunk->type == AGP_PHYS_MEMORY) &&
+			chunk->offset == offset) {
+
+			emgd_gtt_remove(gmm_context->context, chunk->gtt_mem, chunk->offset);
+
+			chunk->used =0;
+#ifdef GMM_CI_CLEANUP
+			kfree(chunk->gtt_mem);
+
+			/* Free the array of page address, if applicable: */
+			if (chunk->page_addresses != NULL) {
+				EMGD_DEBUG("About to free chunk->page_addresses = 0x%p",
+					chunk->page_addresses);
+				OS_FREE(chunk->page_addresses);
+			}
+
+			/* Free the chunk */
+			del = chunk;
+			chunk = chunk->next;
+			OS_FREE(del);
+#endif
+
+			EMGD_DEBUG("EXIT  Returning %d", 0);
+			return 0;
+		}
+		chunk = chunk->next;
+	}
+	printk(KERN_ERR "Buffer @ 0x%lx (size 0x%lu) not found !", offset, size);
+	printk(KERN_ERR "EXIT  Returning %d", -EINVAL);
+	EMGD_TRACE_EXIT;
+	return -EINVAL;
+}
+
+
+/*
+ * gmm_unmap_from_graphics(): Disables direct display of DMA video input buffers
+ * by unmapping the specified block from the "graphics aperture" via the GTT.
+ */
+int gmm_unmap_from_graphics(unsigned long offset, unsigned long size)
+{
+	int ret;
+
+	EMGD_TRACE_ENTER;
+	if (offset && size) {
+		/* Mark the GTT chunk as currently unused */
+		ret = gmm_unmap_contig_buffer(&gmm_context, offset, size);
+	} else {
+		printk(KERN_ERR "Invalid offset (0x%lx) and/or size (0x%lx) !",
+			offset, size);
+		printk(KERN_ERR "EXIT  Returning %d", -EINVAL);
+		ret = -EINVAL;
+	}
+	EMGD_TRACE_EXIT;
+	return ret;
+}
+EXPORT_SYMBOL(gmm_unmap_from_graphics);
+
+
 /*
  * Maintain a very simple linear linked list of memory allocations. Try
  * to re-use freed blocks.  No error checking is done and alignment is
@@ -1001,3 +1320,60 @@ static int gmm_get_page_list(unsigned long offset,
 	EMGD_TRACE_EXIT;
 	return 0;
 }
+
+struct emgd_ci_meminfo_t {
+	unsigned long v4l2_offset;
+	unsigned long virt;
+	unsigned long  size;
+	};
+
+int emgd_map_ci_buf(struct emgd_ci_meminfo_t * ci_meminfo)
+{
+	int ret;
+	unsigned long gtt_offset;
+	unsigned char i;
+	ret = gmm_map_to_graphics(virt_to_phys((unsigned long *)ci_meminfo->virt), ci_meminfo->size, &gtt_offset);
+	if(ret)
+	{
+		return ret;/*error handling*/
+	}
+	/* save meminfo into our context */
+	for(i=0;i<MAX_CI_LIST_SIZE;i++){
+		if(!ci_surfaces[i].used){
+			ci_surfaces[i].used = 1;
+			ci_surfaces[i].virt = virt_to_phys((unsigned long *)ci_meminfo->virt);
+			ci_surfaces[i].size =  ci_meminfo->size;
+			ci_surfaces[i].gtt_offset =  gtt_offset;
+			return 0;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(emgd_map_ci_buf);
+int emgd_unmap_ci_buf(unsigned long virt_addr)
+{
+	unsigned char i;
+	int ret;
+	for(i=0;i<MAX_CI_LIST_SIZE;i++)
+	{
+		if(ci_surfaces[i].used && (ci_surfaces[i].virt == virt_addr))
+			{
+				ret = gmm_unmap_from_graphics(ci_surfaces[i].gtt_offset, ci_surfaces[i].size);
+				ci_surfaces[i].used = 0;
+				ci_surfaces[i].gtt_offset = 0;
+				return 0;
+			}
+	}
+	printk(KERN_ERR"[gmm]ci unmap failed\n");
+	return 1;
+}
+
+EXPORT_SYMBOL(emgd_unmap_ci_buf);
+
+
+static int gmm_unmap_ci(unsigned long virt_addr)
+{
+	int ret;
+	ret =emgd_unmap_ci_buf(virt_addr);
+	return ret;
+}
diff --git a/drivers/staging/emgd/emgd/include/memlist.h b/drivers/staging/emgd/emgd/include/memlist.h
index 34cb2ec..7d9fa22 100644
--- a/drivers/staging/emgd/emgd/include/memlist.h
+++ b/drivers/staging/emgd/emgd/include/memlist.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: memlist.h
- * $Revision: 1.16 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -126,6 +126,7 @@ typedef struct _gmm_chunk {
 	} usage;
 	/* The offset of the allocated memory, after alignment */
 	unsigned long offset;
+	unsigned long used;
 	/* The number of bytes of memory requested/allocated for this chunk */
 	unsigned long size;
 	/* The number of pages of memory required for "size" bytes */
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c
index 56a835b..76c3726 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036.c
@@ -21,25 +21,19 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036.c
-* @version 1.1.4
+* @version 1.2.2.1
 *-----------------------------------------------------------------------------
 */
 
 
 
-
-#include "ch7036.h"
-#include "ch7036_iic.h"
-#include "asm/div64.h"
-#include <linux/kernel.h>
-
+#include "ch7036_intf.h"
 
 
 static uint32 g_nLastError;
 
 
 
-
 static ch_bool convert_pll1n1_div(ch_bool pll1n1_to_div, uint8* pll1n1_addr, uint8* div_addr);
 static ch_bool convert_pll1n2_div(ch_bool pll1n2_to_div, uint8* pll1n2_addr, uint8* div_addr);
 static ch_bool convert_pll1n3_div(ch_bool pll1n3_to_div, uint8* pll1n3_addr, uint8* div_addr);
@@ -758,14 +752,12 @@ ch_bool set_output_info(OUTPUT_INFO* pOutput_Info)
 {
 	uint8 lvds0_seq, lvds1_seq, lvds2_seq, lvds3_seq, lvdsclk_seq;
 	uint8 lvds0_pol, lvds1_pol, lvds2_pol, lvds3_pol, lvdsclk_pol;
-	/* uint8 hpo_o, vpo_o, depo_o; */
 	uint8 hd_dvib, intlc = 0, copy, hd_lv_pol, hd_lv_seq, hdmi_lvds_sel, hsp, vsp, m1m0, c1c0, vic;
 	uint32 hao_down, vao_down;
-	LVDS_FMT* pLvdsFmt = &pOutput_Info->lvds_fmt;
-	HDMI_FMT* pHdmiFmt = &pOutput_Info->hdmi_fmt;
 
-	/* VGA_FMT* pVgaFmt = &pOutput_Info->vga_fmt; */
 
+	LVDS_FMT* pLvdsFmt = &pOutput_Info->lvds_fmt;
+	HDMI_FMT* pHdmiFmt = &pOutput_Info->hdmi_fmt;
 
 
 
@@ -1016,8 +1008,7 @@ ch_bool set_output_info(OUTPUT_INFO* pOutput_Info)
 ch_bool set_prefer_info(PREFER_INFO* pPrefer_Info)
 {
 	uint8 hsync_cnt_th, prbs_set_sel;
-	uint8 dbp; /*, hpo_o, vpo_o, depo_o;*/
-
+	uint8 dbp ;
 
 	iic_write_ex(MCLK, pPrefer_Info->mclk_khz);
 
@@ -1062,7 +1053,7 @@ ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
 	uint32 a1_reg = 0;
 	uint32 a3_reg = 0;
 	uint32 uclk2d_reg = 0;
-	uint8 uclksec_reg;
+	uint8 uclksec_reg = 0;
 	uint8 dri_pll_n1_reg;
 	uint8 dri_pll_n3_reg;
 
@@ -1071,7 +1062,7 @@ ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
 
 	uint8 gcksel = 0;
 	uint8 tsten1 = 0;
-    uint8 REV_ID;
+	uint8 REV_ID;
 	uint64 temp1;
 
 
@@ -1083,6 +1074,7 @@ ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
 	REV_ID = I2CRead(pDevContext,0x51) & 0x0F;
 
 
+
 	if(pPrefer_Info->reset == 1)
 	{
       I2CWrite(pDevContext,0x03, 0x01);
@@ -1268,16 +1260,31 @@ ch_bool cal_and_set_clk_pll(DEV_CONTEXT* pDevContext)
 		{
 			if((gcksel == 0x40)&&(tsten1 == 0x40)){
 				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
+#ifdef T_LINUX
 			do_div(temp1 , pInput_Info->rx_clk_khz);
 				a1_reg = (uint32)temp1;
-			} else if((gcksel == 0x40)&&(tsten1 == 0x00)){
+#else
+				a1_reg = (uint32)((uint64)temp1 / pInput_Info->rx_clk_khz);
+#endif
+				PD_DEBUG ("#1 a1_reg = 0x%.8X\n", a1_reg);
+		} else if((gcksel == 0x40)&&(tsten1 == 0x00)){
 				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
+#ifdef T_LINUX
 			do_div(temp1 , (uint32)27000);
 				a1_reg = (uint32)temp1;
+#else
+				a1_reg = (uint32)((uint64)temp1 / (uint32)27000);
+#endif
+				PD_DEBUG ("#2 a1_reg = 0x%.8X\n", a1_reg);
 		}else if((gcksel == 0x00)&&(tsten1 == 0x00)){
 				temp1 = (((uint64)pOutput_Info->uclk_khz) * pll1n1_div * pll2n5_div * (1 << 20));
+#ifdef T_LINUX
 			do_div(temp1 , (uint32)27000);
 				a1_reg = (uint32)temp1;
+#else
+				a1_reg = (uint32)((uint64)temp1 / (uint32)27000);
+#endif
+				PD_DEBUG ("#3 a1_reg = 0x%.8X\n", a1_reg);
 			}
 		   iic_write_ex(A1, a1_reg);
 		}
@@ -1676,17 +1683,17 @@ ch_bool cal_and_set_scaler(DEV_CONTEXT* pDevContext)
 	iic_write_ex(WRFAST, wrfast_reg);
 
 
-	chg_hl_reg = (	(pPrefer_Info->dat16_32b == 0)		&&
-					(pPrefer_Info->true24 == 0)			&&
+	chg_hl_reg = (	( 		(pPrefer_Info->dat16_32b == 0)		&&
+					(pPrefer_Info->true24 == 0)		&&
 					(pPrefer_Info->true_com == 0)		&&
-					(	((pOutput_Info->rotate == 0)	&&
-						(pOutput_Info->h_flip == 1))	||
-						((pOutput_Info->rotate == 1)	&&
-						(pOutput_Info->h_flip == 0))	||
-						((pOutput_Info->rotate == 3) &&
-						(pOutput_Info->h_flip == 1)) ||
-						((pOutput_Info->rotate == 2) &&
-						(pOutput_Info->h_flip == 0))  )   ) ? 1 : 0;
+				(	(pOutput_Info->rotate == 0)		&&
+					(pOutput_Info->h_flip == 1)	) )	||
+				(	(pOutput_Info->rotate == 1)		&&
+					(pOutput_Info->h_flip == 0)	)	||
+				(	(pOutput_Info->rotate == 3) 		&&
+					(pOutput_Info->h_flip == 1) 	)	||
+				(	(pOutput_Info->rotate == 2) 		&&
+					(pOutput_Info->h_flip == 0)  )   ) 	? 1 : 0;
 	iic_write_ex(CHG_HL, chg_hl_reg);
 
 
@@ -1704,7 +1711,7 @@ ch_bool post_cal_and_set(DEV_CONTEXT* pDevContext)
 
 	uint32 val_t;
 	uint64 temp1;
-	/* uint32 temp2; */
+
 
 
 	I2CWrite(pDevContext,0x03, 0x04);
@@ -1739,10 +1746,15 @@ ch_bool post_cal_and_set(DEV_CONTEXT* pDevContext)
 			return ch_false;
 		}
 		temp1 = ((uint64)hdinca_reg) * (1 << 20);
+#ifdef T_LINUX
 		do_div(temp1 , hdincb_reg);
 		hdinc_reg = (uint32)temp1;
+#else
+		hdinc_reg = (uint32)((uint64)temp1  / hdincb_reg);
+#endif
 
 
+		PD_DEBUG ("#1 hdinc_reg = 0x%.8X\n", hdinc_reg);
 		I2CWrite(pDevContext,0x3C, (hdinc_reg >> 16) & 0xFF);
 		I2CWrite(pDevContext,0x3D, (hdinc_reg >>  8) & 0xFF);
 		I2CWrite(pDevContext,0x3E, (hdinc_reg >>  0) & 0xFF);
@@ -1760,12 +1772,24 @@ ch_bool post_cal_and_set(DEV_CONTEXT* pDevContext)
 	}
 
 	temp1 = (uint64)hinca_reg * (1 << 20);
+#ifdef T_LINUX
 	do_div(temp1 , hincb_reg);
 	hinc_reg = (uint32)temp1;
+#else
+	hinc_reg = (uint32)((uint64)temp1 / hincb_reg);
+#endif
+
+PD_DEBUG ("#2 hinc_reg = 0x%.8X\n", hinc_reg);
 
 	temp1 = (uint64)vinca_reg * (1 << 20);
+#ifdef T_LINUX
 	do_div( temp1 , vincb_reg);
 	vinc_reg = (uint32)temp1;
+#else
+	vinc_reg = (uint32)((uint64)temp1 / vincb_reg);
+#endif
+
+	PD_DEBUG ("#1 vinc_reg = 0x%.8X\n", vinc_reg);
 
 	I2CWrite(pDevContext,0x36, (hinc_reg >> 16) & 0xFF);
 	I2CWrite(pDevContext,0x37, (hinc_reg >>  8) & 0xFF);
@@ -1864,12 +1888,6 @@ ch_bool cal_and_set_power(DEV_CONTEXT* pDevContext)
 		pdio = 0;
 
 
-
-
-
-
-
-
 	}
 	if(pOutput_Info->channel & CHANNEL_HDMI)
 	{
@@ -1886,7 +1904,6 @@ ch_bool cal_and_set_power(DEV_CONTEXT* pDevContext)
 		dri_pd_pll = 0;
 		pd_ddc = 0;
 
-
 		vga_pd = 0;
 		pdmio = 0;
 		sclpd = 0;
@@ -1900,34 +1917,33 @@ ch_bool cal_and_set_power(DEV_CONTEXT* pDevContext)
 		pdpll0 = 0;
 		pdpll1 = 0;
 		icen0 =0;
-
 		pdio = 0;
+
 		hpd_pd = 0;
 
 	}
 	if(pOutput_Info->channel & CHANNEL_VGA)
 	{
+		vga_pd = 0;
+		pdmio = 0;
+		sclpd = 0;
+		sdpd = 0;
+		gckoff = 0;
+		mempd = 0;
+
 		rx_pd = 0;
 		rxpll_pd = 0;
-		vga_pd = 0;
-		pddac = 0;
 
 		pdpll0 = 0;
 		pdpll1 = 0;
 		icen0 =0;
-
-		pdmio = 0;
 		pdio = 0;
-		sclpd = 0;
-		sdpd = 0;
-		gckoff = 0;
 
-		mempd = 0;
 		dispon = 1;
 		dri_pd_pll = 0;
 
-
 		dacsence=1;
+		pddac = 0;
 	}else{
 
 
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036.h
index 85ad2a3..b138174 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036.h
-* @version 1.1.4
+* @version 1.2.2
 *-----------------------------------------------------------------------------
 */
 
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c
index 04ffa7f..a58d4d6 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.c
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_attr.c
-* @version 1.1.4
+* @version 1.2.5
 *-----------------------------------------------------------------------------
 */
 
@@ -30,8 +30,14 @@
 
 #include "ch7036_intf.h"
 #include "ch7036_attr.h"
-#include "ch7036_fw.h"
-#include "lvds/lvds.h"
+
+
+#ifdef T_LINUX
+	#include "lvds/lvds.h"
+#else
+	#include "lvds.h"
+#endif
+
 
 
 static pd_attr_t g_ch7036_attrs[] =
@@ -39,43 +45,48 @@ static pd_attr_t g_ch7036_attrs[] =
 
 
 
-	PD_MAKE_ATTR (PD_ATTR_ID_HPOSITION,   PD_ATTR_TYPE_RANGE, "H Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    0,  4096,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_VPOSITION,   PD_ATTR_TYPE_RANGE, "V Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    0,  4096,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, HDMI_DEFAULT_UNDERSCAN,   HDMI_DEFAULT_UNDERSCAN,  0,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, HDMI_DEFAULT_UNDERSCAN,     HDMI_DEFAULT_UNDERSCAN,   0,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE_CRT,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  0,  20,  1),
-	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE_CRT,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  0,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HPOSITION,   PD_ATTR_TYPE_RANGE, "H Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    DEFAULT_POSITION - 40,  DEFAULT_POSITION + 40,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VPOSITION,   PD_ATTR_TYPE_RANGE, "V Pos.",  0, DEFAULT_POSITION,	DEFAULT_POSITION,                    DEFAULT_POSITION - 30,  DEFAULT_POSITION + 30,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, HDMI_DEFAULT_UNDERSCAN,   HDMI_DEFAULT_UNDERSCAN,  10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, HDMI_DEFAULT_UNDERSCAN,     HDMI_DEFAULT_UNDERSCAN,   10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_HSCALE_CRT,   PD_ATTR_TYPE_RANGE, "H_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_VSCALE_CRT,   PD_ATTR_TYPE_RANGE, "V_Scale",  0, CRT_DEFAULT_UNDERSCAN,   CRT_DEFAULT_UNDERSCAN,  10,  20,  1),
+	PD_MAKE_ATTR (PD_ATTR_ID_DITHER,   PD_ATTR_TYPE_RANGE, "Dither", PD_ATTR_FLAG_USER_INVISIBLE, 0,   0,  0,  3,  1),
 
+	PD_MAKE_ATTR (PD_ATTR_ID_TEXT_FILTER,   PD_ATTR_TYPE_RANGE, "Text Tuning", PD_ATTR_FLAG_USER_INVISIBLE, 4,   DEFAULT_TEXT_ENHANCE,  0,  7,  1),
 
 
-	PD_MAKE_ATTR (PD_ATTR_ID_DITHER_BYPASS, PD_ATTR_TYPE_BOOL, "Quality Enhancement",  0, 0,                 1,                 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_DITHER_BYPASS, PD_ATTR_TYPE_BOOL, "Quality Enhance",  0, 0,                 0,                 0, 0, 0),
 
 	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_DLY, PD_ATTR_TYPE_BOOL, "Pll Reference Delay",PD_ATTR_FLAG_USER_INVISIBLE, 0,0,0, 0, 0),
 	PD_MAKE_ATTR (PD_ATTR_ID_PLL_REF_FBDLY,PD_ATTR_TYPE_BOOL, "Pll Reference FBDelay",PD_ATTR_FLAG_USER_INVISIBLE, 1,   1, 0, 0, 0),
 
-	PD_MAKE_ATTR (PD_ATTR_ID_LOAD_FIRMWARE,PD_ATTR_TYPE_BOOL, "Load Firmware",PD_ATTR_FLAG_USER_INVISIBLE, 0,   1, 0, 0, 0),
+	PD_MAKE_ATTR (PD_ATTR_ID_LOAD_FIRMWARE,PD_ATTR_TYPE_BOOL, "Load Firmware",PD_ATTR_FLAG_USER_INVISIBLE, 0, 1, 0, 0, 0),
 	PD_MAKE_ATTR (PD_ATTR_ID_REFRESH,PD_ATTR_TYPE_BOOL, "Refresh",0, 0,   0, 0, 0, 0),
-
+	PD_MAKE_ATTR (PD_ATTR_ID_DWNSCAL_BYPASS,PD_ATTR_TYPE_BOOL, "Remove_DS",PD_ATTR_FLAG_USER_INVISIBLE, 0, 1, 0, 0, 0),
 
 };
 
 
-
-
 static ch7036_attr_list_entry_t g_list_entry_hdmi[] =
 {
+	{OUT_HDMI_640x480P_59,		"640x480p_59",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_640x480P_60,		"640x480p_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_720x480P_59,		"720x480p_59",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_720x480P_60,		"720x480p_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_HDMI_720x576P_50,     "720x576p_50",PD_ATTR_FLAG_DYNAMIC},
+
 	{OUT_HDMI_1280x720P_59,    "1280x720p_59",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_1280x720P_60,    "1280x720p_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_1920x1080I_59,   "1920x1080i_59",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_1920x1080I_60,   "1920x1080i_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_1920x1080P_59,   "1920x1080p_59",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_1920x1080P_60,   "1920x1080p_60",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_720x576P_50,     "720x576p_50",PD_ATTR_FLAG_DYNAMIC},
+
 	{OUT_HDMI_1280x720P_50,    "1280x720p_50",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_HDMI_1920x1080I_50,   "1920x1080i_50",PD_ATTR_FLAG_DYNAMIC},
-	{OUT_HDMI_1920x1080P_50,   "1920x1080i_50",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_HDMI_1920x1080P_50,   "1920x1080p_50",PD_ATTR_FLAG_DYNAMIC},
 	{0, NULL,0}
 };
 
@@ -84,29 +95,39 @@ static ch7036_attr_list_entry_t g_list_entry_hdmi[] =
 static ch7036_attr_list_entry_t g_list_entry_dvi[] =
 {
 
-	{OUT_DVI_800x600_60,	"800x600_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_640x480_60,	"640x480_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_640x480_72,	"640x480_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_640x480_75,	"640x480_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_720x400_70,	"720x400_70",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_800x600_56,	"800x600_56",PD_ATTR_FLAG_DYNAMIC},
 
+	{OUT_DVI_800x600_60,	"800x600_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_800x600_72,	"800x600_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_800x600_75,	"800x600_75",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_DVI_1024x768_60,	"1024x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1024x768_70,	"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1024x768_75,	"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
 
-
-
+	{OUT_DVI_1152x864_60,	"1152x864_60",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_DVI_1280x720_60,   "1280x720_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_DVI_1280x800_60,   "1280x800_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_DVI_1280x960_60,    "1280x960_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_DVI_1280x1024_60,   "1280x1024_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1280x1024_75,   "1280x1024_75",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_DVI_1360x768_60,    "1360x768_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_DVI_1366x768_60,    "1366x768_60",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_DVI_1400x1050_60,   "1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
-
-
+	{OUT_DVI_1400x1050_75,   "1400x1050_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1440x900_60,    "1440x900_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_DVI_1440x1050_60,   "1440x1050_60",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_DVI_1600x900_60,    "1600x900_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_DVI_1600x1200_60,   "1600x1200_60",PD_ATTR_FLAG_DYNAMIC},
-
+	{OUT_DVI_1680x1050_60,   "1680x1050_60",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_DVI_1920x1080_60,   "1920x1080_60",PD_ATTR_FLAG_DYNAMIC},
 	{0, NULL,0}
@@ -116,14 +137,52 @@ static ch7036_attr_list_entry_t g_list_entry_dvi[] =
 
 static ch7036_attr_list_entry_t g_list_entry_crt[] =
 {
+	{OUT_CRT_640x400_85, "640x400_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_640x480_60, "640x480_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_640x480_72, "640x480_72",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_640x480_75, "640x480_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_640x480_85, "640x480_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_720x400_85, "720x400_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_800x600_56, "800x600_56",PD_ATTR_FLAG_DYNAMIC},
+
 	{OUT_CRT_800x600_60, "800x600_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_CRT_800x600_72, "800x600_72",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_CRT_800x600_75, "800x600_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_800x600_85, "800x600_85",PD_ATTR_FLAG_DYNAMIC},
 
 	{OUT_CRT_1024x768_60,"1024x768_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_CRT_1024x768_70,"1024x768_70",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_CRT_1024x768_75,"1024x768_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1024x768_85,"1024x768_85",PD_ATTR_FLAG_DYNAMIC},
+
+
+	{OUT_CRT_1152x864_75,"1152x864_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1280x768_60,"1280x768_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x768_75,"1280x768_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x768_85,"1280x768_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1280x960_60,"1280x960_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x960_85,"1280x960_85",PD_ATTR_FLAG_DYNAMIC},
+
+
 	{OUT_CRT_1280x1024_60,"1280x1024_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x1024_75,"1280x1024_75",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1280x1024_85,"1280x1024_85",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1360x768_60,"1360x768_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1400x1050_60,"1400x1050_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1400x1050_75,"1400x1050_75",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1440x900_60,"1440x900_60",PD_ATTR_FLAG_DYNAMIC},
+	{OUT_CRT_1440x1050_60,"1440x1050_60",PD_ATTR_FLAG_DYNAMIC},
+
+	{OUT_CRT_1600x900_60,"1600x900_60",PD_ATTR_FLAG_DYNAMIC},
+
 	{OUT_CRT_1600x1200_60,"1600x1200_60",PD_ATTR_FLAG_DYNAMIC},
 	{OUT_CRT_1920x1080_60,"1920x1080_60",PD_ATTR_FLAG_DYNAMIC},
 	{0, NULL,0}
@@ -132,24 +191,28 @@ static ch7036_attr_list_entry_t g_list_entry_crt[] =
 
 static ch7036_attr_list_entry_t g_list_entry_channel[] =
 {
+	{CHANNEL_AUTO_DETECT,"Auto Detect",PD_ATTR_FLAG_DYNAMIC},
 	{CHANNEL_LVDS_HDMI, "LVDS_HDMI",PD_ATTR_FLAG_DYNAMIC},
 	{CHANNEL_LVDS_DVI, "LVDS_DVI",PD_ATTR_FLAG_DYNAMIC},
 	{CHANNEL_LVDS_VGA,  "LVDS_VGA",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_HDMI, "HDMI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_DVI, "DVI",PD_ATTR_FLAG_DYNAMIC},
+	{CHANNEL_VGA,  "VGA",PD_ATTR_FLAG_DYNAMIC},
 	{0, NULL,0}
 };
 
 static ch7036_attr_list_header_t g_list_header[] =
 {
-	{3, PD_ATTR_ID_DISPLAY,"Display Channel", 1,1,
+	{7, PD_ATTR_ID_DISPLAY,"Display Channel", 1,1,
 	g_list_entry_channel},
 
-	{12, PD_ATTR_ID_HDMI_OUT_MODE, "HDMI",4,4,
+	{14, PD_ATTR_ID_HDMI_OUT_MODE, "HDMI",7,7,
 	 g_list_entry_hdmi},
 
-	{12, PD_ATTR_ID_DVI_OUT_MODE,"DVI", 2,2,
+	{27, PD_ATTR_ID_DVI_OUT_MODE,"DVI", 9,9,
 	 g_list_entry_dvi},
 
-	{9, PD_ATTR_ID_CRT_OUT_MODE, "VGA", 4,4,
+	{32, PD_ATTR_ID_CRT_OUT_MODE, "VGA", 12,12,
 	 g_list_entry_crt},
 
 	{ 0 }
@@ -161,12 +224,11 @@ ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx, ch70
 {
 	unsigned long ch7036_num_attrs, num_attrs;
 	unsigned char *p_table;
-	/* ch7036_status_t status; */
 
 
 
 	ch7036_num_attrs = ch7036_enumerate_attr_table(p_ctx, NULL, p_list_header);
-	PD_DEBUG("ch7036_init_attribute_table- ch7036 num_attr = [%u]\n",ch7036_num_attrs);
+	PD_DEBUG("ch7036_init_attribute_table- ch7036 num_attr = [%lu]\n",ch7036_num_attrs);
 
 
 	p_ctx->ch7036_num_attrs =  ch7036_num_attrs ;
@@ -202,7 +264,7 @@ ch7036_status_t ch7036_init_attribute_table(ch7036_device_context_t *p_ctx, ch70
 		num_attrs = ch7036_enumerate_attr_table(p_ctx, (pd_attr_t *)p_table, p_list_header);
 
 
-		PD_DEBUG("ch7036_init_attribute_table: ch7036_enumerate_attr_table()- returned %ld entries, expected %ld\n",
+		PD_DEBUG("ch7036_init_attribute_table: ch7036_enumerate_attr_table()- returned %lu entries, expected %lu\n",
 					  num_attrs, p_ctx->ch7036_num_attrs) ;
 
 	}
@@ -218,11 +280,8 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 	pd_attr_t *p_attr, ch7036_attr_list_header_t* p_list_header)
 {
 
-	/*DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;*/
-	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info; */
 
 	unsigned long num_attrs, i, j, num_attrs_static;
-	/*ch7036_status_t status;*/
 	ch7036_attr_list_entry_t *list_item;
 	int ret;
 	pd_attr_t *p_table;
@@ -236,9 +295,9 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 
 
 
-	if ( p_list_header == NULL ){
-		p_list_header = g_list_header;
-	}
+	if ( p_list_header == NULL )
+			p_list_header = g_list_header;
+
 
 	if (p_attr == NULL) {
 
@@ -248,7 +307,7 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 			if(ret != PD_SUCCESS)
 				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes() return ERROR! check this routine\n");
 			else
-				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes()- lvds num_attr = [%u]\n",p_ctx->lvds_num_attrs);
+				PD_DEBUG("ch7036_enumerate_attr_table: lvds_get_attributes()- lvds num_attr = [%lu]\n",p_ctx->lvds_num_attrs);
 		}
 
 
@@ -280,19 +339,23 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 		for (i=0 ; i < p_ctx->lvds_num_attrs; i++, p_lvds_des++) {
 
 			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
-				  "adding lvds attr='%s', id=%ld, default=%ld, current=%ld, \n",
+				  "adding lvds attr='%s', id=%lu, default=%lu, current=%lu, \n",
 				  p_lvds_des->name, p_lvds_des->id, p_lvds_des->default_value, p_lvds_des->current_value);
 		}
 
 	}
 
-	PD_DEBUG("ch7036 : ch7036_enumerate_attr_table adding lvds num attrs = %ld \n", num_attrs);
+	PD_DEBUG("ch7036 : ch7036_enumerate_attr_table adding lvds num attrs = %lu \n", num_attrs);
+
+
 
 	i=0;
 
+
 	while (p_list_header[i].num_entries) {
 
-		pd_list_attr_t *p_hdr = (pd_list_attr_t *) &p_attr[num_attrs - 1];
+		pd_list_attr_t *p_hdr = (pd_list_attr_t *) &p_attr[num_attrs];
+
 
 		p_hdr->type	= PD_ATTR_TYPE_LIST;
 		p_hdr->id = p_list_header[i].id;
@@ -305,8 +368,8 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 		p_hdr->default_index = p_list_header[i].default_index;
 
 		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
-				  "adding attr - list header='%s', id=%ld, default=%ld, current=%ld, \n"
-				  "num_entries=%ld\n",
+				  "adding attr - list header='%s', id=%lu, default=%lu, current=%lu, \n"
+				  "num_entries=%lu\n",
 				  p_hdr->name, p_hdr->id, p_hdr->default_index, p_hdr->current_index,
 				  p_hdr->num_entries);
 
@@ -318,7 +381,7 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 		for (j = 0; j < p_list_header[i].num_entries; ++j, ++num_attrs) {
 
 			pd_list_entry_attr_t *p_entry =
-				(pd_list_entry_attr_t *)&p_attr[num_attrs - 1];
+				(pd_list_entry_attr_t *)&p_attr[num_attrs];
 
 			p_entry->id		= p_list_header[i].id;
 			p_entry->type	= PD_ATTR_TYPE_LIST_ENTRY;
@@ -338,8 +401,8 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 
 
 
-			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : list entry[%ld]=%s, id=%ld, "
-					  "value=%ld, flags=0x%x \n",
+			PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : list entry[%lu]=%s, id=[%lu], "
+					  "value=%lu, flags=0x%x \n",
 					  j, p_entry->name, p_entry->id,
 					  p_entry->value, (unsigned char)p_entry->flags);
 
@@ -349,15 +412,14 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 	}
 
 
-	p_table = (pd_attr_t *)&p_attr[num_attrs - 1];
-
+	p_table = (pd_attr_t *)&p_attr[num_attrs];
 	num_attrs_static = sizeof(g_ch7036_attrs)/sizeof(pd_attr_t);
 	pd_memcpy(p_table, g_ch7036_attrs,num_attrs_static*sizeof(pd_attr_t));
 
 	for (i=0 ; i < num_attrs_static; i++, p_table++) {
 
 		PD_DEBUG("ch7036 : ch7036_enumerate_attr_table : \n"
-				  "adding ch7036 static attr='%s', id=%ld, default=%ld, current=%ld, \n",
+				  "adding ch7036 static attr='%s', id=%lu, default=%lu, current=%lu, \n",
 				  p_table->name, p_table->id, p_table->default_value, p_table->current_value);
 
 	}
@@ -369,8 +431,6 @@ unsigned long ch7036_enumerate_attr_table (ch7036_device_context_t *p_ctx,
 
 }
 
-
-
 void ch7036_set_dither(ch7036_device_context_t* p_ctx)
 {
 	uint8 reg=0x00;
@@ -384,6 +444,7 @@ void ch7036_set_dither(ch7036_device_context_t* p_ctx)
 	switch(p_ctx->dither_select)
 	{
 		  case DITHER_18_TO_18:
+			  reg &= 0x3F;
 			  break;
 		  case DITHER_18_TO_24:
 			  reg = reg | 0x40;
@@ -429,21 +490,16 @@ ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
 	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
 	pd_attr_t *p_attr_hdmi, *p_attr_crt, *p_attr_dvi;
-	pd_attr_t *p_attr_hscale, *p_attr_vscale, *p_attr_hscale_crt, *p_attr_vscale_crt, *p_attr_hp, *p_attr_vp, *p_attr_disp;
+	pd_attr_t *p_attr_hscale, *p_attr_vscale, *p_attr_hscale_crt, *p_attr_vscale_crt, *p_attr_hp, *p_attr_vp;
 	pd_attr_t* p_attr_dither;
-	/*unsigned long id;*/
 
 
-	PD_DEBUG("ch7036_set_output_channel- channel [%x]\n", channel);
 
+	PD_DEBUG("ch7036_set_output_channel- channel [%x]\n", channel);
 
 	pOutput_Info->channel = channel;
 
 
-	p_attr_disp = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
-				PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST);
-
-	p_attr_disp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
 
 	p_attr_dvi = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
 				PD_ATTR_ID_DVI_OUT_MODE, PD_GET_ATTR_LIST);
@@ -489,7 +545,7 @@ ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
 			p_attr_dvi += p_attr_dvi->current_value;
 			p_ctx->dvi_mode_index = ((pd_list_entry_attr_t *)p_attr_dvi)->value;
 
-			PD_DEBUG("ch7036_set_output_channel- dvi mode index [%ld]\n",p_ctx->dvi_mode_index);
+			PD_DEBUG("ch7036_set_output_channel- dvi mode index [%hu]\n",p_ctx->dvi_mode_index);
 
 
 
@@ -505,12 +561,10 @@ ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
 			p_attr_hdmi += p_attr_hdmi->current_value;
 			p_ctx->hdmi_mode_index = ((pd_list_entry_attr_t *)p_attr_hdmi)->value;
 
-			PD_DEBUG("ch7036_set_output_channel- hdmi mode index [%ld]\n",p_ctx->hdmi_mode_index);
+			PD_DEBUG("ch7036_set_output_channel- hdmi mode index [%hu]\n",p_ctx->hdmi_mode_index);
 
 		}
 
-
-
 		if(p_attr_crt)
 			p_attr_crt->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
 
@@ -521,7 +575,6 @@ ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
 		p_attr_hp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
 		p_attr_vp->flags |= PD_ATTR_FLAG_USER_INVISIBLE;
 
-
 		//show it
 		p_attr_hscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
 		p_attr_vscale->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
@@ -537,8 +590,6 @@ ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
 		ch7036_set_scaling(pOutput_Info,PD_ATTR_ID_VSCALE,(uint8)p_attr_vscale->current_value);
 
 
-
-
 	} else if (pOutput_Info->channel & CHANNEL_VGA) {
 
 		p_attr_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
@@ -552,7 +603,7 @@ ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel)
 		p_attr_crt += p_attr_crt->current_value;
 		p_ctx->crt_mode_index = ((pd_list_entry_attr_t *)p_attr_crt)->value;
 
-		PD_DEBUG("ch7036_set_output_channel- crt mode index [%ld\n",p_ctx->crt_mode_index);
+		PD_DEBUG("ch7036_set_output_channel- crt mode index [%hu]\n",p_ctx->crt_mode_index);
 
 
 		p_attr_hscale_crt->flags &= ~PD_ATTR_FLAG_USER_INVISIBLE;
@@ -606,19 +657,23 @@ unsigned long ch7036_get_output_channel(void* p_context)
 {
 	ch7036_device_context_t * p_ctx= (ch7036_device_context_t *)p_context;
 	pd_list_entry_attr_t *p_attr;
+	uint32 channel = 0;
 
 	PD_DEBUG("ch7036_get_output_channel- enter\n");
 
 	p_attr = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,
 			PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
 
-	return (p_attr->value);
+	if(p_attr->value & CHANNEL_DVI)
+		channel = (p_attr->value & 0xF7) | CHANNEL_HDMI;
+
+	return channel;
 }
 
 ch7036_status_t ch7036_set_position(ch7036_device_context_t *p_ctx, uint8 attr_id, uint16 pos)
 {
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+
 	uint8 reg;
 
 	PD_DEBUG("ch7036_set_position- enter\n");
@@ -761,11 +816,21 @@ void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info)
 	pOutput_Info->v_flip = DEFAULT_VFLIP;
 }
 
-void ch7036_set_text_enhancement (PREFER_INFO* pPrefer_Info)
+void ch7036_set_text_enhancement (ch7036_device_context_t *p_ctx, uint8 val)
 {
 
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
+
+
+	PD_DEBUG("ch7036_set_text_enhancement- enter\n");
 
-	pPrefer_Info->text_enhancement = DEFAULT_TEXT_ENHANCE;
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	I2CWrite(p_ch7xxx_context,0x2E, (I2CRead(p_ch7xxx_context,0x2E) & 0xF8) |  val);
+
+	pPrefer_Info->text_enhancement = val;
+	iic_write_ex(TXTEN, val);
 }
 
 
@@ -786,10 +851,11 @@ void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info)
 
 
 
-ch7036_status_t ch7036_alter_display_list (ch7036_device_context_t *p_ctx)
+ch7036_status_t ch7036_alter_display_channel (ch7036_device_context_t *p_ctx)
 {
-	/*DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;*/
-	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+
+
+	ch7036_status_t status;
 
 
 	pd_list_entry_attr_t  *list_item;
@@ -797,59 +863,97 @@ ch7036_status_t ch7036_alter_display_list (ch7036_device_context_t *p_ctx)
 	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
 	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
 
-	PD_DEBUG("ch7036_alter_display_list- enter\n");
 
+	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
+					PD_GET_ATTR_LIST_ENTRY);
+
+	PD_DEBUG("ch7036_alter_display_channel=> enter- list_item->value [0x%lu]\n",list_item->value);
 
 	switch (p_ctx->hpd & 0x22) {
 
 		case 0x22:
 		case 0x20:
+			PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi hpd status: attached... \n");
+			if(p_ctx->hpd & 0x41 ) {
+
+				status = ch7036_read_edid(p_ctx, CHANNEL_LVDS_HDMI);
+
+
+				if (status == SS_SUCCESS) {
 
-			if(p_ctx->hpd & 0x40) {
+					if( p_ctx->man_sel_out==1 )
+						p_ctx->hpd &= 0x3F; //need parsing but dont do edid again
+					else
+						p_ctx->hpd &= 0x7F;
 
-				ch7036_read_edid(p_ctx);
 
-				if( p_hedid && p_hedid->is_edid) {
-					ch7036_get_hdvi_display_modes_supported(p_ctx);
+					PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi, status changed,edid read is a success- proceed to alter attr table...\n");
 
-					PD_DEBUG("ch7036_alter_display_list=> hdmi-dvi hpd is good,edid success- proceed to alter attr table...\n");
 				}
 				else {
 
-					PD_DEBUG("ch7036_alter_display_list=> hpd hdmi-dvi is good, edid failed- use default attr table- show all modes..\n");
+					PD_DEBUG("ch7036_alter_display_channel=> hdmi-dvi, status changed,edid read failed- use default attr table- show all modes..\n");
+
 
 				}
 
 
+
 			}
 			else {
 
-				PD_DEBUG("ch7036_alter_display_list=> hpd hdmi/dvi status is not change, attached... check if edid read needed...\n");
-				ch7036_redo_edid_if_needed(p_ctx, (void *)p_hedid);
+				PD_DEBUG("ch7036_alter_display_channel=> hdmi/dvi, status unchanged,check if edid read needed...\n");
+				ch7036_redo_edid_if_needed(p_ctx, (void *)p_hedid, CHANNEL_LVDS_HDMI);
+			}
+
+
+
+
+			if(list_item->value == CHANNEL_AUTO_DETECT) {
+				if(p_ctx->prev_outchannel != CHANNEL_LVDS_HDMI)
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_HDMI);
 			}
+			else {
+
+
 
 
-			list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_HDMI);
-			ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+				if(list_item->value & CHANNEL_DVI)
+					//	map DVI to HDMI output channel;
+					ch7036_set_output_channel((void *)p_ctx, (list_item->value & 0x01) | CHANNEL_HDMI);
+
+				else
+
+					ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+
+
+			}
+
 
 			break;
 
 		case 0x02:
 
-			PD_DEBUG("ch7036_alter_display_list=> crt only, no hdmi/dvi- hide hdmi/dvi list entry...\n");
+			PD_DEBUG("ch7036_alter_display_channel=> crt hpd status: attached... \n");
+
+			if(p_ctx->hpd & 0x05) {
 
-			if(p_ctx->hpd & 0x04) {
+				status = ch7036_read_edid(p_ctx, CHANNEL_LVDS_VGA);
 
-				ch7036_read_edid(p_ctx);
 
-				if(p_cedid->is_edid) {
+				if (status == SS_SUCCESS) {
+
+					PD_DEBUG("ch7036_alter_display_channel=> crt only, status changed, edid is a success, proceed ..\n");
+					if( p_ctx->man_sel_out==1 )
+						p_ctx->hpd &= 0xF3; //need parsing,hpd manually updated to 'unchanged',dont do edid again
+					else
+						p_ctx->hpd &= 0xF7;
 
-					PD_DEBUG("ch7036_alter_display_list=> hpd crt status changed, edid is a success, proceed ..\n");
 
 				}
 				else {
 
-					PD_DEBUG("ch7036_alter_display_list=> hpd crt is good, edid failed- use default attr table- show all modes..\n");
+					PD_DEBUG("ch7036_alter_display_channel=> crt only, status changed, edid failed- use default attr table- show all modes..\n");
 
 				}
 
@@ -857,43 +961,45 @@ ch7036_status_t ch7036_alter_display_list (ch7036_device_context_t *p_ctx)
 			}
 
 			else  {
-				PD_DEBUG("ch7036_alter_display_list=> crt hpd status is not change, attached... check if edid read needed...\n");
-				ch7036_redo_edid_if_needed(p_ctx, (void *)p_cedid);
+				PD_DEBUG("ch7036_alter_display_channel=> crt only, status unchange,check if edid read needed...\n");
+				ch7036_redo_edid_if_needed(p_ctx, (void *)p_cedid, CHANNEL_LVDS_VGA);
 			}
 
+			if(list_item->value == CHANNEL_AUTO_DETECT)
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_VGA);
+			else {
+
+				//set output channel, correct display choice if needed
+				ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
+			}
 
-			list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_VGA);
-			ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
 
 			break;
 
 		default:
 
-			PD_DEBUG("ch7036_alter_display_list=> hdmi/dvi/vga devices appeared detached...\n");
-
-			if (!p_ctx->init_done)
-				list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_VGA);
+			if(list_item->value == CHANNEL_AUTO_DETECT) {
+				if (!p_ctx->init_done) {
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS_VGA);
+				}
+				else
+					ch7036_set_output_channel((void *)p_ctx, CHANNEL_LVDS);
+			}
 			else
-				list_item = ch7036_get_updated_display_ouput_entry(p_ctx, CHANNEL_LVDS);
+				ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
 
-			ch7036_set_output_channel((void *)p_ctx, (uint32)list_item->value );
-
-
-#if 0
-			if (p_ctx->init_done)
-				ch7036_device_set_power(p_ctx, (uint32)list_item->value);
-#endif
 
 		break;
 
 
 	}
 
-
+	PD_DEBUG("ch7036_alter_display_channel=> exit- list_item->value [0x%x]\n",list_item->value);
 	return SS_SUCCESS;
 
 }
 
+
 pd_list_entry_attr_t *ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel)
 {
 
@@ -902,28 +1008,53 @@ pd_list_entry_attr_t *ch7036_get_updated_display_ouput_entry(ch7036_device_conte
 	list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
 					PD_GET_ATTR_LIST_ENTRY);
 
-	list_item->value = (list_item->value & 0xF1) | channel;
+	list_item->value = (list_item->value & 0x01) | channel;
 
 	return list_item;
 }
 
-void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk)
+
+void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk, uint32 channel)
 {
 	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_edidblk;
+	ch7036_status_t status = SS_UNSUCCESSFUL;;
+
+
 
 	if (!p_ctx->init_done) {
 
-			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, hpd status is not changed at init., read edid...\n");
-			ch7036_read_edid(p_ctx);
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, status unchanged at init, read edid NOW...\n");
+			status = ch7036_read_edid(p_ctx, channel);
+
 	}
 	else {
 
 		if(!p_edid->is_edid) {
-			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=>attached, hpd status is not changed, never read edid or edid failed, read it now..\n");
-			ch7036_read_edid(p_ctx);
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=>attached, status unchanged, never read edid or edid failed, read it NOW..\n");
+			status= ch7036_read_edid(p_ctx, channel);
+
+
 		}
 		else
-			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, hpd status is not changed, edid was read, abort read edid request...\n");
+			PD_DEBUG("ch7036_alter_list: ch7036_check_if_edid_read_needed=> attached, status unchanged, edid read was done, edid read is NOT needed...\n");
+	}
+
+	if(status == SS_SUCCESS) {
+
+		if(channel & CHANNEL_HDMI)
+			if( p_ctx->man_sel_out==1 )
+				p_ctx->hpd &= 0x3F;
+			else
+				p_ctx->hpd &= 0x7F;
+
+		else
+			if( p_ctx->man_sel_out==1 )
+				p_ctx->hpd &= 0xF3;
+			else
+				p_ctx->hpd &= 0xF7;
+
 	}
 
+
+
 }
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.h
index 6745088..8c3aa21 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_attr.h
@@ -21,13 +21,13 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_attr.h
-* @version 1.1.4
+* @version 1.2.5
 *-----------------------------------------------------------------------------
 */
 
 
 
-#include <linux/kernel.h>
+//#include <linux/kernel.h>
 
 #ifndef _CH7036_ATTR_H_
 #define _CH7036_ATTR_H_
@@ -66,11 +66,11 @@ void ch7036_set_vflip (OUTPUT_INFO* pOutput_Info);
 
 ch7036_status_t ch7036_set_output_channel(void* p_context, uint32 channel);
 unsigned long ch7036_get_output_channel(void* p_context);
-ch7036_status_t ch7036_alter_display_list (ch7036_device_context_t *p_ctx);
+ch7036_status_t ch7036_alter_display_channel (ch7036_device_context_t *p_ctx);
 
 pd_list_entry_attr_t * ch7036_get_updated_display_ouput_entry(ch7036_device_context_t *p_ctx, uint32 channel);
 
-void ch7036_set_text_enhancement (PREFER_INFO* pPrefer_Info);
+void ch7036_set_text_enhancement (ch7036_device_context_t *p_ctx, uint8 val);
 void ch7036_set_quality_enhancement(ch7036_device_context_t *p_ctx, uint8 val);
 
 void ch7036_set_pll_refdly(PREFER_INFO* pPrefer_Info);
@@ -79,7 +79,7 @@ void ch7036_set_lvds_txdrv_ctrl(PREFER_INFO* pPrefer_Info);
 
 void ch7036_set_dither(ch7036_device_context_t* p_ctx);
 
-void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk);
+void ch7036_redo_edid_if_needed(ch7036_device_context_t *p_ctx, void* p_edidblk, uint32 channel);
 
 
 #endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_def_regmap.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
index 4858c63..fe2e79a 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_def_regmap.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_def_regmap.h
-* @version 1.1.4
+* @version 1.2.2
 *-----------------------------------------------------------------------------
 */
 
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c
index 94c708c..61c9dd7 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.c
@@ -21,30 +21,29 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_fw.c
-* @version 1.1.4
+* @version 1.2.5
 *-----------------------------------------------------------------------------
 */
 
 
 
 #include "ch7036_intf.h"
-#include "ch7036_fw.h"
 
-#include "hdcp7036.car"
+#include "edid7036.car"
 
 
 #define EDID_RETRY_MAX_TIMES 5
 #define HPD_LOOP_MAX 10
 
 
-
-#define SLEEP_TIME 40
+#define SLEEP_TIME 200
 
 
 #define lhfm_size  sizeof(lhfm_array)
 
+#define LHFM_TIMEOUT	10
 
-#define LHFM_TIMEOUT	0x1F
+static unsigned char edid_header[8]={0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00};
 
 static unsigned char es_map[16] = {
 	0x26,0x27,0x42,0x43,0x44,0x45,0x46,0x47,
@@ -53,36 +52,34 @@ static unsigned char es_map[16] = {
 
 
 
+
+
 established_timings_t et_I[8] = {
-	{0,"800x600_60"},
-	{0,"800x600_56"},
-	{0,"640x480_75"},
-	{0,"640x480_72"},
-	{0,"640x480_67"},
-	{0,"640x480_60"},
-	{0,"720x400_88"},
-	{0,"720x400_70"}
+	{0,"800x600_60", {OUT_DVI_800x600_60,OUT_HDMI_END, OUT_CRT_800x600_60} },
+	{0,"800x600_56", {OUT_DVI_800x600_56,OUT_HDMI_END, OUT_CRT_800x600_56} },
+	{0,"640x480_75", {OUT_DVI_640x480_75, OUT_HDMI_END, OUT_CRT_640x480_75} },
+	{0,"640x480_72", {OUT_DVI_640x480_72, OUT_HDMI_END, OUT_CRT_640x480_72} },
+	{0,"640x480_67", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END } },
+	{0,"640x480_60", {OUT_DVI_640x480_60, OUT_HDMI_640x480P_60, OUT_CRT_640x480_60} },
+	{0,"720x400_88", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END } },
+	{0,"720x400_70", {OUT_DVI_720x400_70, OUT_HDMI_END, OUT_CRT_END} },
 };
 
 established_timings_t et_II[8] ={
-	{0, "1280x1024_75"},
-	{0, "1024x768_75"},
-	{0, "1024x768_70"},
-	{0, "1024x768_60"},
-	{0, "1024x768_87"},
-	{0, "832x624_75"},
-	{0, "800x600_75"},
-	{0, "800x600_72"}
+	{0, "1280x1024_75", {OUT_DVI_1280x1024_75, OUT_HDMI_END, OUT_CRT_1280x1024_75} },
+	{0, "1024x768_75", {OUT_DVI_1024x768_75, OUT_HDMI_END, OUT_CRT_1024x768_75} },
+	{0, "1024x768_70", {OUT_DVI_1024x768_70, OUT_HDMI_END, OUT_CRT_1024x768_70} },
+	{0, "1024x768_60", {OUT_DVI_1024x768_60, OUT_HDMI_END, OUT_CRT_1024x768_60} },
+	{0, "1024x768_87", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} },
+	{0, "832x624_75", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END} },
+	{0, "800x600_75", {OUT_DVI_800x600_75, OUT_HDMI_END, OUT_CRT_800x600_75} },
+	{0, "800x600_72", {OUT_DVI_800x600_72, OUT_HDMI_END, OUT_CRT_800x600_72} }
 };
 
 established_timings_t et_man = {
-	0, "1152x870_75"
+	0, "1152x870_75", {OUT_DVI_END, OUT_HDMI_END, OUT_CRT_END}
 };
 
-extern OUT_FMT hdmi_timing_table[OUT_HDMI_END];
-extern OUT_FMT dvi_timing_table[OUT_DVI_END];
-extern OUT_FMT ch_vga_timing_table[OUT_CRT_END];
-
 
 int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg)
 {
@@ -122,9 +119,6 @@ int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg)
 
 				 }
 
-
-
-
 			 }
 
 		 }
@@ -133,88 +127,22 @@ int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg)
 }
 
 
-
-ch7036_status_t LHFM_get_hdmi_hpd(DEV_CONTEXT* p_ch7xxx_context,uint8 *hpd)
-{
-
-	unsigned char reg;
-	unsigned wj, count=0;
-	ch7036_status_t status = SS_FIRMWARE_TIMEOUT;
-
-
-	do {
-
-
-		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
-		 reg = I2CRead(p_ch7xxx_context,0x4F);
-
-
-		 if (0==(LHFM_REQUEST & reg)) {
-
-			 I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+ LHFM_GET_HPD));
-			 wj = 0;
-
-			 while (wj++< LHFM_TIMEOUT) {
-				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
-				 reg = I2CRead(p_ch7xxx_context,0x4F);
-
-				 if(reg == LHFM_GET_HPD) {
-
-					 reg = I2CRead(p_ch7xxx_context,0x50);
-
-					 if (!(LHFM_RET_ERROR & reg)) {
-
-						    I2CWrite(p_ch7xxx_context,0x03, 0x01);
-						    reg = I2CRead(p_ch7xxx_context,es_map[0]);
-
-							if (hpd) *hpd = reg;
-
-							PD_DEBUG("ch7036: LHFM_get_hdmi_hpd- SUCCESS- hpd [%x]\n", *hpd);
-							return SS_SUCCESS;
-					 } else {
-
-						 status = SS_FIRMWARE_ERR;
-					 }
-
-				 }
-
-				if(status == SS_FIRMWARE_ERR)  break;
-				pd_usleep(SLEEP_TIME);
-
-			 }
-
-		 }
-
-		pd_usleep(SLEEP_TIME);
-		PD_DEBUG("ch7036: LHFM_get_hdmi_hpd- NOT SUCCESS-status = [%s]\n",status==SS_FIRMWARE_ERR?"firmware error":"timeout");
-
-	} while ( ( (status== SS_FIRMWARE_ERR) || (status== SS_FIRMWARE_TIMEOUT) ) && ( (++count) < HPD_LOOP_MAX) );
-
-
-	return status;
-}
-
-
 void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
 {
 	uint8 reg;
 
+	PD_DEBUG("ch7036: LHFM_enable_crt_hpd-enter\n");
 
 	I2CWrite(p_ch7xxx_context,0x03, 0x04);
 	reg = I2CRead(p_ch7xxx_context,0x57);
 	I2CWrite(p_ch7xxx_context,0x57, reg | 0x02);
 
-
 	pd_usleep(SLEEP_TIME);
 
-
 	I2CWrite(p_ch7xxx_context,0x03, 0x00);
-	reg = I2CRead(p_ch7xxx_context,0x74);
-	I2CWrite(p_ch7xxx_context,0x74, reg | 0x02);
+	I2CWrite(p_ch7xxx_context,0x08, I2CRead(p_ch7xxx_context,0x08) & 0xF1);
 
 	pd_usleep(SLEEP_TIME);
-
-
 }
 
 
@@ -224,39 +152,24 @@ ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
 	unsigned char reg, count =0;
 	ch7036_status_t status = SS_CRT_HPD_NOTCONNECTED;
 
-
 	do {
+
 		I2CWrite(p_ch7xxx_context,0x03, 0x00);
 		reg = I2CRead(p_ch7xxx_context,0x74);
 		I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);
-
 		pd_usleep(SLEEP_TIME);
 
 		I2CWrite(p_ch7xxx_context,0x03, 0x00);
 		reg = I2CRead(p_ch7xxx_context,0x74);
 		I2CWrite(p_ch7xxx_context,0x74, reg | 0x02);
-
 		pd_usleep(SLEEP_TIME);
 
-
 		I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		reg = I2CRead(p_ch7xxx_context,0x7C);
 
-
-
-		PD_DEBUG("ch7036: LHFM_get_crt_hpd- DAC sense- reg dump [%x]\n", reg);
-
-		if( (reg & 0xFC) == 0x54 || (reg & 0xFC) == 0x50 ){
-
+		if( (reg & 0xF0) == 0x50  || (reg & 0xF4) == 0x14 || (reg & 0xF4) == 0x44)
 			status= SS_SUCCESS;
 
-		}
-		else
-			LHFM_enable_crt_hpd(p_ch7xxx_context);
-
-		pd_usleep(SLEEP_TIME+100000);
-
-
 	} while ( (status == SS_CRT_HPD_NOTCONNECTED) && ( (++count) < HPD_LOOP_MAX ) );
 
 
@@ -264,6 +177,8 @@ ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context)
 	reg = I2CRead(p_ch7xxx_context,0x74);
 	I2CWrite(p_ch7xxx_context,0x74, reg & 0xFD);
 
+	I2CWrite(p_ch7xxx_context,0x08, I2CRead(p_ch7xxx_context,0x08) | 0x0E);
+
 	return status;
 
 }
@@ -298,9 +213,6 @@ ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned ch
 
 				 }
 
-
-
-
 			 }
 
 		 }
@@ -310,7 +222,6 @@ ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned ch
 }
 
 
-
 ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char* edid, unsigned char* ebn, unsigned char flag)
 {
 
@@ -319,30 +230,31 @@ ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char* edid,
 	unsigned char reg;
 	unsigned wj;
 
-	ch7036_status_t status = SS_SUCCESS;
+	ch7036_status_t status;
 
 
-	*ebn = 0;
-
 
-	for (i=0; i<512; i++) edid[i]=0;
-
-	 I2CWrite(p_ch7xxx_context,0x03, 0x00);
-	 reg = I2CRead(p_ch7xxx_context,0x4F);
+	status = SS_SUCCESS;
+	*ebn = 0;
 
+	pd_memset(edid, 0, EDID_SIZE);
 
-	 if (0==(LHFM_REQUEST & reg)) {
+	I2CWrite(p_ch7xxx_context,0x03, 0x00);
+	reg = I2CRead(p_ch7xxx_context,0x4F);
 
+	if( (reg & LHFM_REQUEST) != 0 )
+		return SS_FIRMWARE_ERR; //mcu is busy
+	else { //mcu is ready to serve host request
 
-		 for(i=0,j=0; i < 8; i++,j+=16) {
+		for(i=0,j=0; i < 8; i++,j+=16) {
 
 		    I2CWrite(p_ch7xxx_context,0x03, 0x00);
-			I2CWrite(p_ch7xxx_context,0x50, i + flag);
+			I2CWrite(p_ch7xxx_context,0x50, i | flag);
 			I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
 			wj = 0;
 
 			status = SS_FIRMWARE_TIMEOUT;
-
+			PD_DEBUG("ch7036: LHFM_get_edid- block [%d] - getting [%d]- 16 bytes - wj=[0x%x]\n",*ebn,i+1,wj);
 			while (wj++< (2*LHFM_TIMEOUT) ) {
 				 I2CWrite(p_ch7xxx_context,0x03, 0x00);
 				 pd_usleep(SLEEP_TIME);
@@ -356,86 +268,80 @@ ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char* edid,
 					 if (!(LHFM_RET_ERROR & reg)) {
 							I2CWrite(p_ch7xxx_context,0x03, 0x01);
 							for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );
-
-
 							break;
 					 }
-					 else {
-
-
-
-
-						return SS_FIRMWARE_ERR;
-
-					 }
+					 else
+							return SS_FIRMWARE_ERR;
 
 				 }
 
 
-			}
+			} //while block
 
 			status = SS_SUCCESS;
 
+		} //for
 
-		}
-
+		for(i=0;i<8;i++)
+			if (edid_header[i] != edid[i]) {
+				return SS_FIRMWARE_ERR;
+			}
 
 		(*ebn)++;
 
+		if(flag & 0x80 && (edid[0x7E] > 0) ) {
+			PD_DEBUG("ch7036: LHFM_get_edid- incorrect # of VGA EDID blocks read [%x]\n",edid[0x7E]);
+			return SS_FIRMWARE_ERR;
+		}
 
 		k2 = edid[0x7E];
 
 		k2 = (k2 > 3)? 3 : k2;
-		if (k2>0) {
-		  for (k1=1; k1<=k2; k1++) {
-
-
 
-		    for(i=k1*8; i < 8+k1*8; i++,j+=16){
-				I2CWrite(p_ch7xxx_context,0x03, 0x00);
-			    I2CWrite(p_ch7xxx_context,0x50, i + flag);
-				I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
-				wj = 0;
+		if (k2>0) { //case: there are more than 1 blocks
+			for (k1=1; k1<=k2; k1++) {
 
-				status = SS_FIRMWARE_TIMEOUT;
+				for(i=k1*8; i < 8+k1*8; i++,j+=16){
+					I2CWrite(p_ch7xxx_context,0x03, 0x00);
+					I2CWrite(p_ch7xxx_context,0x50, i + flag);
+					I2CWrite(p_ch7xxx_context,0x4F, (LHFM_REQUEST+LHFM_GET_EDID));
+					wj = 0;
 
-				while (wj++< (2*LHFM_TIMEOUT)) {
-					 I2CWrite(p_ch7xxx_context,0x03, 0x00);
-					 pd_usleep(SLEEP_TIME);
+					status = SS_FIRMWARE_TIMEOUT;
+					PD_DEBUG("ch7036: LHFM_get_edid- block [%d] - getting [%d]- 16 bytes - wj=[0x%x]\n",k1,i+1,wj);
+					while (wj++< (2*LHFM_TIMEOUT)) {
+						I2CWrite(p_ch7xxx_context,0x03, 0x00);
+						pd_usleep(SLEEP_TIME);
 
-					 reg = I2CRead(p_ch7xxx_context,0x4F);
+						reg = I2CRead(p_ch7xxx_context,0x4F);
 
-					 if(reg == LHFM_GET_EDID) {
-						 reg = I2CRead(p_ch7xxx_context,0x50);
-						 if (!(LHFM_RET_ERROR & reg)) {
+						if(reg == LHFM_GET_EDID) {
+							reg = I2CRead(p_ch7xxx_context,0x50);
+							if (!(LHFM_RET_ERROR & reg)) {
 								I2CWrite(p_ch7xxx_context,0x03, 0x01);
 								for (ie=0; ie<16; ie++) edid[j+ie] = I2CRead(p_ch7xxx_context,es_map[ie] );
-
-
 								break;
-						 }
-						 else {
-
-							return SS_FIRMWARE_ERR;
-						 }
-					 }
+							}
+							else
+								return SS_FIRMWARE_ERR;
 
 
+						}
 
+					} //while
 
-				 }
+					status = SS_SUCCESS;
 
-				status = SS_SUCCESS;
-			}
+				}//nested for
 
-			(*ebn)++;
-		  }
+				(*ebn)++;
 
-		}
+			} //outermost for
 
 
+		} //if- case: there are more than 1 blocks
 
-	 }
+	} //else - case:  mcu is ready to serve host request
 
 	return status;
 
@@ -449,28 +355,23 @@ int LHFM_load_firmware(DEV_CONTEXT* p_ch7xxx_context)
 	unsigned fs1;
 	unsigned char ch;
 
+	PD_DEBUG("ch7036: LHFM_load_firmware- firmware size [0x%.8X]\n",lhfm_size);
 
 	I2CWrite(p_ch7xxx_context,0x03, 0x04);
-
 	ch = 0x29 | I2CRead(p_ch7xxx_context,0x52);
 	I2CWrite(p_ch7xxx_context,0x52, ch & 0xFB);
 
 
-
 	I2CWrite(p_ch7xxx_context,0x5B, 0x9E);
-
 	I2CWrite(p_ch7xxx_context,0x5B, 0xB3);
 
-
 	I2CWrite(p_ch7xxx_context,0x03, 0x04);
-
 	I2CWrite(p_ch7xxx_context,0x03, 0x07);
 
+	for (fs1=0; fs1<lhfm_size; fs1++)
+		I2CWrite(p_ch7xxx_context, 0x07, lhfm_array[fs1]);
 
-	for (fs1=0; fs1<lhfm_size; fs1++) {
 
-		I2CWrite(p_ch7xxx_context, 0x07, lhfm_array[fs1]);
-	}
 
 	I2CWrite(p_ch7xxx_context, 0x03, 0x03);
 	ch = I2CRead(p_ch7xxx_context,0x74);
@@ -485,15 +386,81 @@ int LHFM_load_firmware(DEV_CONTEXT* p_ch7xxx_context)
 		I2CWrite(p_ch7xxx_context, 0x52, ch | 0x24);
 	}
 
-
 	I2CWrite(p_ch7xxx_context, 0x03, 0x00);
 
-
 	return 0;
 }
-
+#if 0
 void ch7036_dump( char *s, int size, unsigned char *regdata)
 {
+	char temp[18];
+    int ch;
+
+    int i,j, size1;
+
+    temp[16] = '?';
+    temp[17] = '\n';
+
+	PD_DEBUG("\n");
+    PD_DEBUG("+--------------------------------------------------------------------+\n");
+    PD_DEBUG("|%s |\n",s);
+    PD_DEBUG("+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-----------------+\n");
+    PD_DEBUG("|  | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| A| B| C| D| E| F|                 |\n");
+    PD_DEBUG("++++--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+-----------------+\n");
+
+    size1 = size % 16;
+    size = size/16;
+
+    for (i=0; i<size; i++) {
+
+
+       PD_DEBUG("|%02x>", 0xFF & i*16);
+
+
+	   for (j=0; j<16; j++) {
+           ch = regdata[i*16+j];
+           PD_DEBUG("%02X|", ch);
+
+#if 0
+
+
+		   if( (ch >= 0x30 && ch <= 0x39) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x41 && ch <= 0x5C) )
+				temp[j]='.';
+		   else
+			   temp[j]=(char)ch;
+#endif
+
+        }
+
+	   PD_DEBUG("\n");
+	}
+
+	if (size1) {
+
+        PD_DEBUG( "|%02x>", 0xFF & size*16);
+
+		for (j=0; j<size1; j++) {
+           ch = regdata[size*16+j];
+           PD_DEBUG("%02X|", ch);
+#if 0
+
+			if( (ch >= 0x30 && ch <= 0x39) || (ch >= 0x61 && ch <= 0x7A) || (ch >= 0x41 && ch <= 0x5C) )
+				temp[j]='.';
+		   else
+			   temp[j]=(char)ch;
+#endif
+
+        }
+		for (j=size1; j<16; j++) {
+
+           PD_DEBUG("   ");
+
+        }
+
+	}
+
+	PD_DEBUG("\n");
 
     return;
 }
+#endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.h
index 0a30f1a..1dc77ee 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_fw.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_fw.h
-* @version 1.1.4
+* @version 1.2.2
 *-----------------------------------------------------------------------------
 */
 
@@ -32,11 +32,12 @@
 #include "ch7036_typedef.h"
 
 
-#include <linux/kernel.h>
+//#include <linux/kernel.h>
 
 #define	CFG_CAP_EDID	0x01
 #define CFG_CAP_HDCP	0x02
 
+typedef unsigned char ch7036_attr_table_index_t;
 
 
 typedef struct _FW7036_CFG {
@@ -55,50 +56,18 @@ typedef struct _FW7036_CFG {
 #define LHFM_GET_EDID			0x01
 #define LHFM_GET_MODEINFO		0x03
 #define LHFM_GET_VGA_MODEINFO	0x33
-
 #define LHFM_HDMI_ONOFF		0x04
-
-
 #define LHFM_REQUEST		0x40
 #define LHFM_RET_ERROR		0x80
 
 int LHFM_get_version(DEV_CONTEXT* p_ch7xxx_context,struct _FW7036_CFG* cfg);
 
-
-
-
-
-ch7036_status_t LHFM_get_hdmi_hpd(DEV_CONTEXT* p_ch7xxx_context,uint8 *hpd);
 void LHFM_enable_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
 ch7036_status_t LHFM_get_crt_hpd(DEV_CONTEXT* p_ch7xxx_context);
-
-
-
 int LHFM_hdmi_onoff(int turnon);
-
-
-
-
-
-
 ch7036_status_t LHFM_get_hdmi_modeinfo(DEV_CONTEXT* p_ch7xxx_context,unsigned char *minfo);
-
-
-
-
-
-
 ch7036_status_t LHFM_get_edid(DEV_CONTEXT* p_ch7xxx_context,unsigned char*edid, unsigned char* ebn, unsigned char flag);
-
-
-
-
-
-
 int LHFM_load_firmware(DEV_CONTEXT* pDevContext);
-
-
-void test_fw(DEV_CONTEXT* p_ch7xxx_context,int oper);
 void ch7036_dump( char *s, int size, unsigned char *regdata);
 
 #define GET_VER					0x01
@@ -112,7 +81,9 @@ void ch7036_dump( char *s, int size, unsigned char *regdata);
 #define CH7036_HDMI_DDC			0
 #define CH7036_VGA_DDC			0x80
 
-#define MAX_EDID_BLOCKS			4
+#define MAX_EDID_BLOCKS			2
+
+#define MAX_I2C_BLOCK_SIZE		32
 
 
 
@@ -138,6 +109,7 @@ void ch7036_dump( char *s, int size, unsigned char *regdata);
 #define EDID_CEA_REVISION                     0x81
 #define EDID_CEA_DETAILED_TIMING_DATA_OFFSET  0x82
 #define EDID_CEA_VIDEO_DATA_BLOCK             0x84
+#define EDID_CEA_DATA_BLOCK					  0x84
 
 #define EDID_CEA_VIDEO_DATA_BLOCK_2           0x96
 #define EDID_CEA_VIDEO_DATA_BLOCK_3           0xA8
@@ -147,9 +119,15 @@ void ch7036_dump( char *s, int size, unsigned char *regdata);
 
 #define EDID_SPACE_INDEX_START                0x18
 
+
+
+
+
 typedef struct {
     unsigned char  is_supported;
-    char* mode_name;
+    char mode_name[13];
+	unsigned long index[3];
+
 }established_timings_t, *p_established_timings;
 
 typedef struct {
@@ -186,32 +164,50 @@ typedef struct {
 	unsigned char flags;
 }dtd_t, *p_dtd;
 
-typedef struct edid_blk {
 
+typedef struct monitor_range {
 
-	unsigned char						is_edid;
-	unsigned char						ebn;
-	unsigned char						edidblk[512];
+	unsigned char  hrate_min;
+	unsigned char  hrate_max;
+	unsigned char  vrate_min;
+	unsigned char  vrate_max;
 
-	established_timings_t				etiming_I[8];
-	established_timings_t				etiming_II[8];
-	established_timings_t				etiming_man;
+	unsigned long  pclk_max;
 
-	standard_timings_t					stiming[8];
+}monitor_range_t;
 
-	unsigned char						supported_modes[15];
 
-} ch7036_edid_blk_t;
+typedef struct detailed_timing_block {
+	unsigned long data_tag;
+	OUT_FMT		dtiming;
+} dtblks_t;
 
 
-extern ch7036_edid_blk_t crt_edid;
-extern ch7036_edid_blk_t hdvi_edid;
+typedef struct edid_blk {
 
 
+	unsigned char						is_edid;
+	unsigned char						is_preferred_timing;
 
+	unsigned char						ebn;
+	unsigned char						edidblk[EDID_SIZE];
 
+	established_timings_t				*etiming_I;
+	established_timings_t				*etiming_II;
+	established_timings_t				*etiming_man;
 
+	standard_timings_t					stiming[8];
 
+	standard_timings_t					stiming_x[6];
+	monitor_range_t						rtiming;
+
+	dtblks_t							dtblk[4];
+
+
+	unsigned char						supported_modes[15];
+	ch7036_attr_table_index_t			modes[MAX_ATTR_LIST_SIZE];
+
+} ch7036_edid_blk_t;
 
 
 #endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.c
index f057952..a26f866 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.c
@@ -21,11 +21,14 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_iic.c
-* @version 1.1.4
+* @version 1.2.4
 *-----------------------------------------------------------------------------
 */
 
 
+
+
+
 #include "ch7036_iic.h"
 #include "ch7036_def_regmap.h"
 
@@ -35,14 +38,6 @@ static uint8 g_nCurRegmap[REG_PAGE_NUM][REG_NUM_PER_PAGE];
 
 int g_verbose = 0;
 
-
-
-
-void SetPower(DEV_CONTEXT* pDevContext);
-
-
-
-
 void DeviceReset(DEV_CONTEXT* pDevContext)
 {
 
@@ -119,42 +114,6 @@ void DeviceSetup(DEV_CONTEXT* pDevContext)
 }
 
 
-#if 0
-void SetPower(DEV_CONTEXT* pDevContext)
-{
-	uint8 page =0;
-	uint8 index;
-	uint32 reg_id, end;
-
-
-
-	reg_id = (uint32)HDMI_PD;
-	end = (uint32)MUL_ID_END;
-
-	I2CWrite(pDevContext,0x03, page);
-
-	while (reg_id < end)
-	{
-		if (page != g_MultiRegTable[reg_id].PageIndex)
-		{
-			page = g_MultiRegTable[reg_id ].PageIndex;
-			I2CWrite(pDevContext,0x03, page);
-		}
-		index = g_MultiRegTable[reg_id ].LowRegIndex;
-		I2CWrite(pDevContext,index, g_nCurRegmap[page][index]);
-		reg_id++;
-	}
-
-	I2CWrite(pDevContext,0x03, 0);
-	I2CWrite(pDevContext,0x1C, g_nCurRegmap[0][0x1C]);
-	I2CWrite(pDevContext,0x1D, g_nCurRegmap[0][0x1D]);
-
-}
-#endif
-
-
-
-
 uint8 iic_read(uint8 index)
 {
 	return g_nCurRegmap[g_nCurPage][index];
@@ -200,13 +159,13 @@ uint32 iic_read_ex(MULTI_REG_ID reg_id)
 	oldpage = iic_read(0x03);
 	iic_write(0x03, g_MultiRegTable[i].PageIndex);
 
-	if(-1 != g_MultiRegTable[i].TopRegIndex)
+	if(NOOP_INDEX != g_MultiRegTable[i].TopRegIndex)
 		n0 = iic_read(g_MultiRegTable[i].TopRegIndex);
 
-	if(-1 != g_MultiRegTable[i].HighRegIndex)
+	if(NOOP_INDEX != g_MultiRegTable[i].HighRegIndex)
 		n1 = iic_read(g_MultiRegTable[i].HighRegIndex);
 
-	if(-1 != g_MultiRegTable[i].MiddleRegIndex)
+	if(NOOP_INDEX != g_MultiRegTable[i].MiddleRegIndex)
 		n2 = iic_read(g_MultiRegTable[i].MiddleRegIndex);
 
 	n3 = iic_read(g_MultiRegTable[i].LowRegIndex);
@@ -287,7 +246,7 @@ void iic_write_ex(MULTI_REG_ID reg_id, uint32 value)
 	iic_write(g_MultiRegTable[i].LowRegIndex, (uint8)n1);
 	value_local >>= g_MultiRegTable[i].LowEndBit - g_MultiRegTable[i].LowStartBit + 1;
 
-	if(-1 != g_MultiRegTable[i].MiddleRegIndex)
+	if(NOOP_INDEX != g_MultiRegTable[i].MiddleRegIndex)
 	{
 		mask = 1;
 		mask <<= g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1;
@@ -301,7 +260,7 @@ void iic_write_ex(MULTI_REG_ID reg_id, uint32 value)
 		iic_write(g_MultiRegTable[i].MiddleRegIndex, (uint8)n2);
 		value_local >>= g_MultiRegTable[i].MiddleEndBit - g_MultiRegTable[i].MiddleStartBit + 1;
 
-		if(-1 != g_MultiRegTable[i].HighRegIndex)
+		if(NOOP_INDEX != g_MultiRegTable[i].HighRegIndex)
 		{
 			mask = 1;
 			mask <<= g_MultiRegTable[i].HighEndBit - g_MultiRegTable[i].HighStartBit + 1;
@@ -315,7 +274,7 @@ void iic_write_ex(MULTI_REG_ID reg_id, uint32 value)
 			iic_write(g_MultiRegTable[i].HighRegIndex, (uint8)n3);
 			value_local >>= g_MultiRegTable[i].HighEndBit - g_MultiRegTable[i].HighStartBit + 1;
 
-			if(-1 != g_MultiRegTable[i].TopRegIndex)
+			if(NOOP_INDEX != g_MultiRegTable[i].TopRegIndex)
 			{
 				mask = 1;
 				mask <<= g_MultiRegTable[i].TopEndBit - g_MultiRegTable[i].TopStartBit +1;
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.h
index ebfb06b..fd168db 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_iic.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_iic.h
-* @version 1.1.4
+* @version 1.2.2
 *-----------------------------------------------------------------------------
 */
 
@@ -38,22 +38,12 @@ uint8 I2CRead(DEV_CONTEXT* pDevContext, uint8 index);
 void I2CWrite(DEV_CONTEXT* pDevContext, uint8 index, uint8 value);
 
 void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 len);
-
-
 void DeviceReset(DEV_CONTEXT* pDevContext);
-
-
 void DeviceSetup(DEV_CONTEXT* pDevContext);
 
-
-
-
-
 uint8 iic_read(uint8 index);
 void iic_write(uint8 index, uint8 value);
 void iic_reset(void);
-
-
 uint32 iic_read_ex(MULTI_REG_ID reg_id);
 void iic_write_ex(MULTI_REG_ID reg_id, uint32 reg_val);
 
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c
index b3e3331..210cb20 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.c
@@ -21,17 +21,26 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_intf.c
-* @version 1.1.4
+* @version 1.2.5
 *-----------------------------------------------------------------------------
 */
 
+
 #include "ch7036_intf.h"
 #include "ch7036_attr.h"
-#include "ch7036_fw.h"
 
 
+#ifdef T_LINUX
+	#include "lvds/lvds.h"
+#else
+	#include "lvds.h"
+#endif
+
 
+ch7036_status_t ch7036_get_hdmi_hpd(ch7036_device_context_t* p_ctx, uint8 *hpd);
 
+unsigned long ch7036_invis_6x4_modes_table_size[3] = {2,3,5};
+unsigned long ch7036_invis_8x6_7x4_table_size[3] = {3,5,6};
 
 OUT_FMT hdmi_timing_table[OUT_HDMI_END] = {
 
@@ -40,17 +49,17 @@ OUT_FMT hdmi_timing_table[OUT_HDMI_END] = {
     {1,     25250,  1, {800,   640, 16,  96, 525,  480, 10,  2, 60, SCANTYPE_PROGRESSIVE} },
     {2,     27000,  1, {858,   720, 16,  62, 525,  480,  9,  6, 59, SCANTYPE_PROGRESSIVE} },
     {2,     27027,  1, {858,   720, 16,  62, 525,  480,  9,  6, 60, SCANTYPE_PROGRESSIVE} },
+	{17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
 
     {4,     74176,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 59, SCANTYPE_PROGRESSIVE} },
     {4,     74250,  2, {1650, 1280, 110, 40, 750,  720,  5,  5, 60, SCANTYPE_PROGRESSIVE} },
     {5,     74176,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 59, SCANTYPE_INTERLACED} },
     {5,     74250,  2, {2200, 1920, 88,  44, 1125, 1080, 2,  5, 60, SCANTYPE_INTERLACED} },
-
-
-   {16,    148350,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
+	{16,    148350,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
+//   {16,    148352,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 59, SCANTYPE_PROGRESSIVE} },
    {16,    148500,  2, {2200, 1920, 88,  44, 1125, 1080, 4,  5, 60, SCANTYPE_PROGRESSIVE} },
 
-   {17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
+//   {17,     27000,  1, {864,  720,  12,  64, 625,  576,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
    {19,     74250,  2, {1980, 1280, 440, 40, 750,  720,  5,  5, 50, SCANTYPE_PROGRESSIVE} },
 
    {20,     74250,  2, {2640, 1920, 528, 44, 1125, 1080, 2, 5, 50, SCANTYPE_INTERLACED} },
@@ -136,7 +145,9 @@ OUT_FMT dvi_timing_table[OUT_DVI_END] = {
 };
 
 
-OUT_FMT ch_vga_timing_table[OUT_CRT_END] = {
+
+
+OUT_FMT ch7036_crt_timing_table[OUT_CRT_END] = {
 
 
    {100,    31500,  1, {832,   640, 32,  64,  445,  400, 1,  3,  85, SCANTYPE_PROGRESSIVE}  },
@@ -210,18 +221,19 @@ OUT_FMT ch_vga_timing_table[OUT_CRT_END] = {
 };
 
 
+
+
+
 uint8 I2CRead(DEV_CONTEXT* pDevContext,uint8 index)
 {
 
 	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
 	pd_reg_t reg_list[2];
 
-
-
 	reg_list[0].reg = (i2c_reg_t)index;
 	reg_list[1].reg = PD_REG_LIST_END;
 
-	p_ctx->p_callback->read_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC_FW);
+	p_ctx->p_callback->read_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
 
 	return (uint8)(reg_list[0].value);
 }
@@ -238,7 +250,7 @@ void I2CWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8 value)
 
 	reg_list[1].reg = PD_REG_LIST_END;
 
-	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC_FW);
+	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
 
 	return;
 }
@@ -247,11 +259,10 @@ void I2CWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8 value)
 void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 len)
 {
 	ch7036_device_context_t *p_ctx= pDevContext->pd_context;
-	pd_reg_t reg_list[33];
+	pd_reg_t reg_list[MAX_I2C_BLOCK_SIZE +1];
 	uint16 i=0;
 
 
-
 	for(i=0;i<len;i++) {
 		reg_list[i].reg = (i2c_reg_t)index;
 		reg_list[i].value = (i2c_reg_t)value[i];
@@ -259,7 +270,7 @@ void I2CBlockWrite(DEV_CONTEXT* pDevContext,uint8 index, uint8* value, uint16 le
 
 	reg_list[len].reg = PD_REG_LIST_END;
 
-	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC_FW);
+	p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context, reg_list,PD_REG_DDC);
 
 	return;
 }
@@ -287,42 +298,8 @@ ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx)
 	ch7036_status_t status = SS_SUCCESS;
 
 	PD_DEBUG("ch7036_intf: ch7036_device_config()\n");
-#if 0
-	printk ("p_ch_ctx->DeviceID = 0x%X\n", p_ch_ctx->DeviceID);
-	printk ("p_ch_ctx->pInput_Info->timing->ht = 0x%X\n", p_ch_ctx->pInput_Info->timing.ht);
-	printk ("p_ch_ctx->pInput_Info->timing->ha = 0x%X\n", p_ch_ctx->pInput_Info->timing.ha);
-	printk ("p_ch_ctx->pInput_Info->timing->ho = 0x%X\n", p_ch_ctx->pInput_Info->timing.ho);
-	printk ("p_ch_ctx->pInput_Info->timing->hw = 0x%X\n", p_ch_ctx->pInput_Info->timing.hw);
-	printk ("p_ch_ctx->pInput_Info->timing->vt = 0x%X\n", p_ch_ctx->pInput_Info->timing.vt);
-	printk ("p_ch_ctx->pInput_Info->timing->va = 0x%X\n", p_ch_ctx->pInput_Info->timing.va);
-	printk ("p_ch_ctx->pInput_Info->timing->vo = 0x%X\n", p_ch_ctx->pInput_Info->timing.vo);
-	printk ("p_ch_ctx->pInput_Info->timing->vw = 0x%X\n", p_ch_ctx->pInput_Info->timing.vw);
-	printk ("p_ch_ctx->pInput_Info->timing->hz = 0x%X\n", p_ch_ctx->pInput_Info->timing.hz);
-	printk ("p_ch_ctx->pInput_Info->timing->stype = 0x%X\n", p_ch_ctx->pInput_Info->timing.stype);
-	printk ("p_ch_ctx->pInput_Info->rx_clk_khz = 0x%X\n", p_ch_ctx->pInput_Info->rx_clk_khz);
-	printk ("p_ch_ctx->pInput_Info->pixel_fmt = 0x%X\n", p_ch_ctx->pInput_Info->pixel_fmt);
-	printk ("p_ch_ctx->pInput_Info->hs_pol = 0x%X\n", p_ch_ctx->pInput_Info->hs_pol);
-	printk ("p_ch_ctx->pInput_Info->vs_pol = 0x%X\n", p_ch_ctx->pInput_Info->vs_pol);
-	printk ("p_ch_ctx->pInput_Info->de_pol = 0x%X\n", p_ch_ctx->pInput_Info->de_pol);
-	printk ("p_ch_ctx->pInput_Info->data_ch_pol = 0x%X\n", p_ch_ctx->pInput_Info->data_ch_pol);
-	printk ("p_ch_ctx->pInput_Info->data_ch_invert = 0x%X\n", p_ch_ctx->pInput_Info->data_ch_invert);
-	printk ("p_ch_ctx->pInput_Info->audio_type = 0x%X\n", p_ch_ctx->pInput_Info->audio_type);
-	printk ("p_ch_ctx->pInput_Info->i2s_pol = 0x%X\n", p_ch_ctx->pInput_Info->i2s_pol);
-	printk ("p_ch_ctx->pInput_Info->i2s_len = 0x%X\n", p_ch_ctx->pInput_Info->i2s_len);
-	printk ("p_ch_ctx->pInput_Info->i2s_fmt = 0x%X\n", p_ch_ctx->pInput_Info->i2s_fmt);
-
-	printk ("\n\n");
-
-	printk ("p_ch_ctx->pOutput_Info->channel = 0x%X\n", p_ch_ctx->pOutput_Info->channel );
-	printk ("p_ch_ctx->pOutput_Info->uclk_khz = 0x%X\n", p_ch_ctx->pOutput_Info->uclk_khz );
-	printk ("p_ch_ctx->pOutput_Info->ds_percent_h = 0x%X\n", p_ch_ctx->pOutput_Info->ds_percent_h );
-	printk ("p_ch_ctx->pOutput_Info->ds_percent_v = 0x%X\n", p_ch_ctx->pOutput_Info->ds_percent_v );
-	printk ("p_ch_ctx->pOutput_Info->rotate = 0x%X\n", p_ch_ctx->pOutput_Info->rotate );
-	printk ("p_ch_ctx->pOutput_Info->h_flip = 0x%X\n", p_ch_ctx->pOutput_Info->h_flip );
-	printk ("p_ch_ctx->pOutput_Info->v_flip = 0x%X\n", p_ch_ctx->pOutput_Info->v_flip );
-	printk ("p_ch_ctx->pOutput_Info->h_position = 0x%X\n", p_ch_ctx->pOutput_Info->h_position );
-	printk ("p_ch_ctx->pOutput_Info->v_position = 0x%X\n", p_ch_ctx->pOutput_Info->v_position );
-#endif
+
+
 	if(!DeviceConfig(p_ch_ctx))
 	{
 		p_ctx->last_emsg = GetLastErrorMessage();
@@ -356,7 +333,7 @@ ch7036_status_t ch7036_device_set_power(ch7036_device_context_t* p_ctx, unsigned
 	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
 	ch7036_status_t status = SS_SUCCESS;
 
-	PD_DEBUG("ch7036_intf: ch7036_device_set_power()- channel [%ld]\n", channel);
+	PD_DEBUG("ch7036_intf: ch7036_device_set_power()- channel [%x]\n", channel);
 
 	if(!DeviceSetPower(p_ch_ctx,channel))
 	{
@@ -374,17 +351,13 @@ ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx)
 
 	DEV_CONTEXT* p_ch_ctx = p_ctx->p_ch7xxx_context;
 
-	/*unsigned fs1;*/
-	/*uint8 ch;*/
 	ch7036_status_t status = SS_UNSUCCESSFUL;
 
 	PD_DEBUG("ch7036: ch7036_load_firmware()\n");
 
 
 	if(LHFM_load_firmware(p_ch_ctx) == -1) {
-
-		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading FAILED\n");
-		p_ctx->last_emsg = GetLastErrorMessage();
+		PD_DEBUG("ch7036_load_firmware: LHFM_load_firmware()- firmware loading FAILED...\n");
 
 	}
 	else  {
@@ -395,10 +368,13 @@ ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx)
 
 	return status;
 
-
 }
 
 
+
+
+
+
 ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx)
 {
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
@@ -413,7 +389,6 @@ ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t*
 	if (status == SS_SUCCESS) {
 
 		PD_DEBUG("HDMI_Modes=%02X. Vesa_Modes=%02x\r\n", p_hedid->supported_modes[13], p_hedid->supported_modes[14]);
-		ch7036_dump("Prefered Mode Timing", 13, p_hedid->supported_modes);
 
 
 	}
@@ -428,244 +403,392 @@ ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t*
 }
 
 
-ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx)
+
+ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx, uint32 channel)
 {
 
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
 	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
 	ch7036_status_t status = SS_UNSUCCESSFUL;
-	/*uint8 ebn;*/
 
-	/*int i;*/
+#ifdef T_CH7036_EDID_DUMP
+	uint8 ebn;
+	int i;
+#endif
 
 	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
 	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
 
-	/*ch7036_attr_list_header_t* p_list_header;*/
 
 	unsigned char* hedidblk = p_hedid->edidblk;
 	unsigned char* cedidblk = p_cedid->edidblk;
 
 
 
+	switch (channel) {
 
-	if((p_ctx->hpd & 0x22) == 0) {
+		case CHANNEL_LVDS_HDMI:
+		case CHANNEL_HDMI:
 
-		p_ctx->hpd &= 0xCC;
-		p_hedid->is_edid =0;
-		p_cedid->is_edid =0;
-		p_hedid->ebn = 0;
-		p_cedid->ebn = 0;
 
+			status = LHFM_get_edid(p_ch7xxx_context,hedidblk, &(p_hedid->ebn), CH7036_HDMI_DDC);
 
-		return status;
+			if(status == SS_SUCCESS) {
 
-	}
+				PD_DEBUG("ch7036_read_edid()-hdmi-dvi hpd status- attached, hdmi-dvi edid read is a SUCCESS\n");
+				PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_hedid->ebn);
 
+				p_hedid->is_edid = 1;
+				if(p_hedid->ebn == 1)
+					pOutput_Info->hdmi_fmt.is_dvi_mode =1;
 
-	if( (p_ctx->hpd & 0x20) == 0x20  ) {
+				else
+					pOutput_Info->hdmi_fmt.is_dvi_mode =0;
 
 
-		status = LHFM_get_edid(p_ch7xxx_context,hedidblk, &(p_hedid->ebn), CH7036_HDMI_DDC);
 
-		if(status == SS_SUCCESS) {
+#ifdef T_CH7036_EDID_DUMP
 
-			PD_DEBUG("ch7036_read_edid()- attached, hdmi-dvi edid read is a SUCCESS\n");
-			PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_hedid->ebn);
+				if (p_hedid->ebn <= MAX_EDID_BLOCKS) {
+					for (i=0; i<p_hedid->ebn; i++)
+						ch7036_dump("HDMI-DVI EDID Data", 128, &hedidblk[i*128]);
 
-			p_hedid->is_edid = 1;
-			if(p_hedid->ebn == 1)
-				pOutput_Info->hdmi_fmt.is_dvi_mode =1;
-			else
-				pOutput_Info->hdmi_fmt.is_dvi_mode =0;
-		}
+				}
 
+#endif
 
-		else {
+			}
+
+			else {
 				p_hedid->is_edid = 0;
-				PD_DEBUG("ch7036_read_edid()- attached, hdmi-dvi edid read is UNSUCCESSFUL\n");
 
-		}
+				status = SS_UNSUCCESSFUL;
 
-	}
+			}
 
+			break;
 
+		case CHANNEL_LVDS_VGA:
+		case CHANNEL_VGA:
 
-	else  {
-		PD_DEBUG("ch7036_read_edid()- hdmi HPD status has-or has NOT-  changed, and not attached- no edid needed...\n");
-		p_hedid->is_edid =0;
+			I2CWrite(p_ch7xxx_context,0x03, 0x01);
+			I2CWrite(p_ch7xxx_context,0x0F, I2CRead(p_ch7xxx_context,0x0F) & 0x7F);
+			pd_usleep(200);
 
-	}
+			status = LHFM_get_edid(p_ch7xxx_context,cedidblk, &(p_cedid->ebn), CH7036_VGA_DDC);
+			if (status== SS_SUCCESS) {
+				p_cedid->is_edid =1;
+				PD_DEBUG("ch7036_read_edid()- crt hpd status- attached, crt edid read is a SUCCESS\n");
+				PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_cedid->ebn);
 
+#ifdef T_CH7036_EDID_DUMP
+				if (p_cedid->ebn <= MAX_EDID_BLOCKS)
+					for (i=0; i<p_cedid->ebn; i++)
+						ch7036_dump("VGA EDID Data", 128, &cedidblk[i*128]);
 
 
+#endif
 
+			}
+			else {
+				p_cedid->is_edid =0;
 
-	if( (p_ctx->hpd & 0x02) == 0x02) {
-		status = LHFM_get_edid(p_ch7xxx_context,cedidblk, &(p_cedid->ebn), CH7036_VGA_DDC);
-		if (status== SS_SUCCESS ) {
-			p_cedid->is_edid =1;
-			PD_DEBUG("ch7036_read_edid()- attached, crt edid read is a SUCCESS\n");
-			PD_DEBUG("ch7036_read_edid()- number of blocks read [%x]\n", p_cedid->ebn);
+				status = SS_UNSUCCESSFUL;
+			}
+
+
+			break;
+
+		default:
+			break;
 
-		}
-		else {
-			p_cedid->is_edid =0;
-			PD_DEBUG("ch7036_read_edid()- crt edid read is UNSUCCESSFUL\n");
-		}
 
-	}
-	else {
-		PD_DEBUG("ch7036_read_edid()- crt HPD status has-or has NOT-  changed, and not attached- no edid needed...\n");
-		p_cedid->is_edid =0;
 	}
 
-	if( (p_hedid->is_edid == 0) && (p_cedid->is_edid ==0) )
-		return SS_UNSUCCESSFUL;
-	else
-		return SS_SUCCESS;
+
+	return status;
 }
 
+ch7036_status_t ch7036_get_hdmi_hpd(ch7036_device_context_t* p_ctx, uint8 *hpd)
+{
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	ch7036_status_t status= SS_SUCCESS;
+	unsigned char reg, reg_hpdpw;
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x03);
+	reg = I2CRead(p_ch7xxx_context,0x25);
+
+	I2CWrite(p_ch7xxx_context,0x03, 0x04);
+	reg_hpdpw = I2CRead(p_ch7xxx_context,0x51);
+
+#ifdef T_CONFIG_PLB
+	if(!(reg & 0x10) && (reg_hpdpw & 0x80) ){
+		reg= 0x10;
+	}
+#endif
+
+	switch (reg & 0x10) {
+		case 0x10:
+			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)
+				*hpd = 0x01;
+			else
+				*hpd = 0x81;
+			break;
+		case 0x00:
+			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)
+				*hpd = 0x80;
+			else
+				*hpd = 0x00;
+			break;
+	}
+
 
+	PD_DEBUG("ch7036: ch7036_get_hdmi_hpd- exit...*hpd [0x%x]\n",*hpd);
+
+	return status;
+
+}
 ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx)
 {
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
 	uint8 reg;
-	ch7036_status_t status;
+	ch7036_status_t status = SS_SUCCESS;
+	ch7036_status_t status_hdmi, status_crt;
+
+	ch7036_edid_blk_t * p_hedid = (ch7036_edid_blk_t *)(p_ctx->hedid);
+
+	uint8 hpd = 0;
 
-	uint8 hpd;
-	/*uint8 ebn;*/
 
 
 	I2CWrite(p_ch7xxx_context,0x03, 0x04);
 	reg = I2CRead(p_ch7xxx_context,0x52);
+
 	reg = reg & 0xEF;
 	I2CWrite(p_ch7xxx_context,0x52, reg);
 
 
+	I2CWrite(p_ch7xxx_context,0x03, 0x0);
+	reg = I2CRead(p_ch7xxx_context,0x07);
+
+	reg = reg & 0x70;
+	I2CWrite(p_ch7xxx_context,0x07, reg);
+
 	I2CWrite(p_ch7xxx_context,0x03, 0x01);
 	reg = I2CRead(p_ch7xxx_context,0x0F);
+
 	reg = reg & 0x7F;
 	I2CWrite(p_ch7xxx_context,0x0F, reg);
 
+	I2CWrite(p_ch7xxx_context,0x0E, I2CRead(p_ch7xxx_context,0x0E) & 0x7F);
+
+	PD_DEBUG("ch7036_get_attached_device()- enter- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
 
+	status_hdmi = ch7036_get_hdmi_hpd(p_ctx,&hpd);
 	LHFM_enable_crt_hpd(p_ch7xxx_context);
+	status_crt = LHFM_get_crt_hpd(p_ch7xxx_context);
 
+	PD_DEBUG("ch7036_get_attached_device()- enter- pOutput_Info->channel = [0x%x]\n", pOutput_Info->channel);
 
+	if(p_ctx->man_sel_out==1) { //manual selection
 
-	status = LHFM_get_hdmi_hpd(p_ch7xxx_context, &hpd);
 
+		if( (status_crt == SS_SUCCESS) || ( (hpd & 0x01)== 1 ) ) {
 
+			switch (pOutput_Info->channel) {
+				case CHANNEL_LVDS_DVI:
+				case CHANNEL_DVI:
+				case CHANNEL_LVDS_HDMI:
+				case CHANNEL_HDMI:
 
-	if(status == SS_SUCCESS) {
 
+					if( (status_crt == SS_SUCCESS) && ( (hpd & 0x01)== 0 ) ) {
 
-		if( hpd == 0x81 ) {
-			if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)  {
-				p_ctx->hpd = ((p_ctx->hpd  & 0x0F) & (~CH7036HPD_HDVI_STATUS_CHANGED)) | CH7036HPD_HDVI_ATTACHED | CH7036HPD_HDVI_HPD_STATUS;
-				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
-			}
-			else {
+						p_ctx->hpd = 0x16; //bit 4=1 to indicate SS_DISPLAY_CHOICE_NOT_ALLOWED,  check edid and parse it
+						status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
 
-				p_ctx->hpd = (p_ctx->hpd  & 0x0F) | CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED | CH7036HPD_HDVI_HPD_STATUS;
-				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's HIGH\n");
-			}
-		}
-		else if (hpd ==0x80) {
-			if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )  {
-				p_ctx->hpd = (p_ctx->hpd  & 0x0F) & (~ CH7036HPD_HDVI_STATUS_CHANGED) & (~CH7036HPD_HDVI_ATTACHED) & (~CH7036HPD_HDVI_HPD_STATUS);
-			PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status not changed since last query and it's LOW\n");
-			}
-			else {
-				/* This line sets the upper 4 bits of p_ctx->hpd
-				 * HDVI_STATUS_CHANGED - is the logic still required?*/
-				p_ctx->hpd = (p_ctx->hpd  & 0x0F) | (CH7036HPD_HDVI_STATUS_CHANGED & (~CH7036HPD_HDVI_ATTACHED) & (~CH7036HPD_HDVI_HPD_STATUS));
-				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's LOW\n");
-			}
+					}
+					else {
+
+						if (!p_ctx->init_done || ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x02) != 0x02 )
+							p_ctx->hpd = 0x60;
+						else
+							p_ctx->hpd = ( ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x02) == 0x02)?0xA0:0x60;
+
+						status = SS_SUCCESS;
+					}
+
+					break;
+
+				case CHANNEL_LVDS_VGA:
+				case CHANNEL_VGA:
+
+
+					if((status_crt != SS_SUCCESS) && ((hpd & 0x01)==1 ) ) {
+
+						if(!p_ctx->init_done) {
+							p_ctx->hpd = 0x06;
+							status = SS_SUCCESS;
+
+						}else {
+							p_ctx->hpd = (hpd & 0x80)?0x70:0x30;
+							status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
+						}
+
+					}
+					else {
+
+						if ( (!p_ctx->init_done) || ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x04) != 0x04 )//at init, need to read edid, and parse it
+							p_ctx->hpd = 0x06;
+						else {
+							p_ctx->hpd = ( ((p_ctx->prev_outchannel & pOutput_Info->channel) & 0x04) == 0x04)?0x0A:0x06;
+
+						}
+
+						status = SS_SUCCESS;
+					}
+
+					break;
+			} //switch
+
+			if(status == SS_DISPLAY_CHOICE_NOT_ALLOWED)
+				PD_DEBUG("ch7036_get_attached_device()- manual selection- display choice is not allowed...\n");
 
-		}
-		else if (hpd == 0x01) {
-			p_ctx->hpd = ((p_ctx->hpd  & 0x0F) & (~CH7036HPD_HDVI_STATUS_CHANGED)) | CH7036HPD_HDVI_ATTACHED | CH7036HPD_HDVI_HPD_STATUS;
-			PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
 		}
 		else {
-			p_ctx->hpd &= 0x0F;
-			PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's LOW\n");
-		}
+
+			if (!p_ctx->init_done) {
+				p_ctx->hpd = 0x06;
+				status = SS_SUCCESS;
+
+			}else {
+
+				PD_DEBUG("ch7036_get_attached_device()- manual selection- none is connected- not allowed...\n");
+
+				status = SS_DISPLAY_CHOICE_NOT_ALLOWED;
+				p_ctx->hpd = 0x50;
+
+			}
 
 
+		}
 
-		PD_DEBUG("ch7036: ch7036_get_attached_device()- SUCCESS- hdmi hpd [0x%x]\n", hpd);
+		PD_DEBUG("ch7036_get_attached_device()- manual selection- exit- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
+		PD_DEBUG("ch7036_get_attached_device()- exit- pOutput_Info->channel = [0x%x]\n", pOutput_Info->channel);
 
+		I2CWrite(p_ch7xxx_context,0x03, 0x03);
+		reg = I2CRead(p_ch7xxx_context,0x25);
 
+		PD_DEBUG("ch7036_get_attached_device()- manual selection- exit...HPD_MCU [0x%x]\n",reg);
 
+		return status;
 	}
-	else {
-		PD_DEBUG("ch7036: ch7036_get_attached_device()- NOT SUCCESS- hdmi hpd [0x%x]\n", hpd);
-		PD_DEBUG("status: [%s]\n",status == SS_FIRMWARE_TIMEOUT?"timeout!":"firmware_error!");
 
+	//auto detection
 
-		if ( (!p_ctx->init_done) &&  (hpd == 0x86) )  {
+	if(status_hdmi == SS_SUCCESS) {
 
-			p_ctx->hpd |= CH7036HPD_HDVI_ATTACHED;
-			PD_DEBUG("ch7036_get_attached_device()- special case when status is unsuccessful, it's attached...\n");
+			if( hpd == 0x81 ) {
+				if(p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)  {
 
-		}
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED);
 
-		else
-			p_ctx->hpd &= ~CH7036HPD_HDVI_ATTACHED;
+					ch7036_get_hdvi_display_modes_supported(p_ctx);
 
+					if (
+						((pOutput_Info->hdmi_fmt.is_dvi_mode== 0) && (p_hedid->supported_modes[13] == 0) )||
+						((pOutput_Info->hdmi_fmt.is_dvi_mode== 1) && (p_hedid->supported_modes[13] > 0))
+					) {
 
+						p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED);
+						PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed [HDMI<->DVI] since last query and it's HIGH\n");
 
-		PD_DEBUG("ch7036_get_attached_device()- not attached\n");
-		PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
-	}
+					}
+					else
+						PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
+				}
+				else {
+
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED | CH7036HPD_HDVI_ATTACHED);
+					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's HIGH\n");
+				}
+			}
+			else if (hpd ==0x80) {
+				if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )  {
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~ CH7036HPD_HDVI_STATUS_CHANGED) & (~CH7036HPD_HDVI_ATTACHED)) ;
+					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status not changed since last query and it's LOW\n");
+				}
+				else {
+
+					p_ctx->hpd = (p_ctx->hpd  & 0x9F) | (CH7036HPD_HDVI_STATUS_CHANGED & (~CH7036HPD_HDVI_ATTACHED)) ;
+					PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status changed since last query and it's LOW\n");
+				}
+
+			}
+			else if (hpd == 0x01) {
+
+				p_ctx->hpd = (p_ctx->hpd  & 0x9F) & ((~CH7036HPD_HDVI_STATUS_CHANGED) | CH7036HPD_HDVI_ATTACHED);
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's HIGH\n");
+			}
+			else {
+
+				p_ctx->hpd &= 0x9F;
+				PD_DEBUG("ch7036_get_attached_device()- hdvi HPD status has not changed since last query and it's LOW\n");
+			}
 
 
 
+			PD_DEBUG("ch7036: ch7036_get_attached_device()- SUCCESS- hdmi hpd [0x%x]\n", hpd);
 
+	}
+	else {
 
-	status = LHFM_get_crt_hpd(p_ch7xxx_context);
 
+		if ( (!p_ctx->init_done) &&  (hpd == 0x86) )  {
 
-	if(status == SS_SUCCESS) {
-		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED )== CH7036HPD_CRT_ATTACHED) {
+			p_ctx->hpd |= CH7036HPD_HDVI_ATTACHED;
 
-				p_ctx->hpd = ((p_ctx->hpd  & 0xF0) & (~CH7036HPD_CRT_STATUS_CHANGED) ) | CH7036HPD_CRT_ATTACHED | CH7036HPD_CRT_HPD_STATUS;
-				PD_DEBUG("ch7036_get_attached_device()- crt HPD status has NOT changed since last query and it's attached\n");
-				PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
 		}
+
 		else {
+			p_ctx->hpd &= ~CH7036HPD_HDVI_ATTACHED;
 
-			p_ctx->hpd = (p_ctx->hpd  & 0xF0) | CH7036HPD_CRT_STATUS_CHANGED | CH7036HPD_CRT_ATTACHED | CH7036HPD_CRT_HPD_STATUS;
+		}
 
-			PD_DEBUG("ch7036_get_attached_device()- crt HPD status has changed since last query and it's attached\n");
-			PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+	}
 
-		}
+	if(status_crt == SS_SUCCESS) {
 
+		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED )== CH7036HPD_CRT_ATTACHED)
+			p_ctx->hpd = (p_ctx->hpd  & 0xF9) & ((~CH7036HPD_CRT_STATUS_CHANGED)  | CH7036HPD_CRT_ATTACHED);
+
+		else
+			p_ctx->hpd = ((p_ctx->hpd  & 0xF9) | ( CH7036HPD_CRT_STATUS_CHANGED | CH7036HPD_CRT_ATTACHED));
 
 	}
 	else  {
 
 		if( (p_ctx->hpd & CH7036HPD_CRT_ATTACHED ) == 0 ) {
-			p_ctx->hpd = p_ctx->hpd & 0xF8;
-			PD_DEBUG("ch7036_get_attached_device()- crt HPD not changed, connected to ground- not attached\n");
-			PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
-		}
-		else {
+			p_ctx->hpd &= 0xF9;
 
-			p_ctx->hpd = (p_ctx->hpd & 0xF8) |  CH7036HPD_CRT_STATUS_CHANGED;
-			PD_DEBUG("ch7036_get_attached_device()- crt HPD status changed, connected to ground- not attached, LOW\n");
-			PD_DEBUG("ch7036_get_attached_device()- p_ctx-hpd [0x%x]\n",p_ctx->hpd);
+			if( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED)== 0  )
+				p_ctx->hpd |= 0x06;
 
 		}
+		else  {
 
+			if ( (p_ctx->hpd & CH7036HPD_HDVI_ATTACHED) ==0 )
+				p_ctx->hpd &= 0xFB;
+			else
+				p_ctx->hpd = (p_ctx->hpd & 0xF9) |  CH7036HPD_CRT_STATUS_CHANGED;
+		}
 
 	}
 
-
+	PD_DEBUG("ch7036_get_attached_device()- auto detection - exit- p_ctx->hpd= [0x%x]\n", p_ctx->hpd);
 	return SS_SUCCESS;
 }
 
@@ -682,16 +805,12 @@ void ch7036_reset(ch7036_device_context_t* p_ctx)
 
 void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx)
 {
-	uint8 reg=0x00;
-	PD_DEBUG("ch7036: ch7036_reset_datapath()- enter\n");
 
+	PD_DEBUG("ch7036: ch7036_reset_datapath()-enter\n");
     I2CWrite(p_ch_ctx,0x03, 0x04);
-	reg = I2CRead(p_ch_ctx,0x52);
-	reg = reg & 0xFE;
-
-	I2CWrite(p_ch_ctx,0x52, reg);
-
+	I2CWrite(p_ch_ctx,0x52, 0x2E);
 
+	pd_usleep(50);
 	I2CWrite(p_ch_ctx,0x52, 0x2F);
 
 	return;
@@ -699,15 +818,17 @@ void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx)
 
 void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx)
 {
-	uint8 reg=0x00;
+
+	PD_DEBUG("ch7036: ch7036_reset_mcu()-enter\n");
 
     I2CWrite(p_ch_ctx,0x03, 0x04);
-	reg = I2CRead(p_ch_ctx,0x52);
-	reg = reg & 0xFB;
-	I2CWrite(p_ch_ctx,0x52, reg);
+	I2CWrite(p_ch_ctx,0x52, 0x2B);
 
+	pd_usleep(50);
 	I2CWrite(p_ch_ctx,0x52, 0x2F);
 
+
+	PD_DEBUG("ch7036: ch7036_reset_mcu()-exit-\n");
 	return;
 }
 
@@ -720,7 +841,7 @@ void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx, INPUT_INFO* pI
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
 	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
 
-	pd_timing_t * p_current_mode = p_ctx->native_dtd;
+	pd_timing_t * p_current_mode = &(p_ctx->native_dtd);
 	uint8 audio_id = AUDIO_SPDIF;
 	PD_DEBUG("ch7036_intf: ch7036_set_input_timing_info()-\n");
 
@@ -752,7 +873,7 @@ void ch7036_set_input_timing_info(ch7036_device_context_t *p_ctx, INPUT_INFO* pI
 
 
 
-	pInput_Info->pixel_fmt = PIXEL_FMT_18BIT;
+	pInput_Info->pixel_fmt = ((lvds_context_t *)p_ctx->internal_lvds)->panel_depth == 18?PIXEL_FMT_18BIT:3;
 
 
 	pInput_Info->data_ch_pol = POL_NO_INV;
@@ -781,7 +902,8 @@ void ch7036_set_output_timing_info(ch7036_device_context_t *p_ctx, OUTPUT_INFO*
 
 	PD_DEBUG("ch7036: ch7036_set_output_timing_info()\n");
 
-	PD_DEBUG("ch7036_set_output_timing_info()- p_ctx = %X \n", p_ctx);
+
+	PD_DEBUG("ch7036_set_output_timing_info()- output channel from pd context[%u]\n",pOutput_Info->channel);
 
 
 	pOutput_Info->lvds_fmt.channel_swap = LVDS_CHANNEL_SWAP_DEF;
@@ -802,9 +924,7 @@ void ch7036_set_output_timing_info(ch7036_device_context_t *p_ctx, OUTPUT_INFO*
 
 		if(!(pOutput_Info->hdmi_fmt.is_dvi_mode))
 		{
-
-
-			PD_DEBUG("ch7036_set_output_timing_info- hdmi mode index is [%x]\n",p_ctx->hdmi_mode_index);
+			PD_DEBUG("ch7036_set_output_timing_info- hdmi mode index is [0x%x]\n",p_ctx->hdmi_mode_index);
 			pOutput_Info->hdmi_fmt.format_index = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].fmt_index;
 			pOutput_Info->hdmi_fmt.aspect_ratio = (uint8)hdmi_timing_table[p_ctx->hdmi_mode_index].aspect;
 
@@ -842,16 +962,16 @@ void ch7036_set_output_timing_info(ch7036_device_context_t *p_ctx, OUTPUT_INFO*
 
 
 
-		PD_DEBUG("ch7036_set_output_timing_info- crt mode index is [%ld]\n",p_ctx->crt_mode_index);
-		pOutput_Info->timing.ht = ch_vga_timing_table[p_ctx->crt_mode_index].timing.ht;
-		pOutput_Info->timing.ha = ch_vga_timing_table[p_ctx->crt_mode_index].timing.ha;
-		pOutput_Info->timing.ho = ch_vga_timing_table[p_ctx->crt_mode_index].timing.ho;
-		pOutput_Info->timing.hw = ch_vga_timing_table[p_ctx->crt_mode_index].timing.hw;
-		pOutput_Info->timing.vt = ch_vga_timing_table[p_ctx->crt_mode_index].timing.vt;
-		pOutput_Info->timing.va = ch_vga_timing_table[p_ctx->crt_mode_index].timing.va;
-		pOutput_Info->timing.vo = ch_vga_timing_table[p_ctx->crt_mode_index].timing.vo;
-		pOutput_Info->timing.vw = ch_vga_timing_table[p_ctx->crt_mode_index].timing.vw;
-		pOutput_Info->uclk_khz = ch_vga_timing_table[p_ctx->crt_mode_index].clk_freq;
+		PD_DEBUG("ch7036_set_output_timing_info- crt mode index is [0x%x]\n",p_ctx->crt_mode_index);
+		pOutput_Info->timing.ht = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ht;
+		pOutput_Info->timing.ha = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ha;
+		pOutput_Info->timing.ho = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.ho;
+		pOutput_Info->timing.hw = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.hw;
+		pOutput_Info->timing.vt = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vt;
+		pOutput_Info->timing.va = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.va;
+		pOutput_Info->timing.vo = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vo;
+		pOutput_Info->timing.vw = ch7036_crt_timing_table[p_ctx->crt_mode_index].timing.vw;
+		pOutput_Info->uclk_khz = ch7036_crt_timing_table[p_ctx->crt_mode_index].clk_freq;
 
 
 	} else
@@ -913,3 +1033,960 @@ void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx, PREFER_INFO*
 
 
 }
+
+
+ch7036_status_t ch7036_parse_standard_edid(ch7036_device_context_t* p_ctx, uint32 channel)
+{
+	uint8 i, index = 0;
+
+	ch7036_edid_blk_t* p_edid = (ch7036_edid_blk_t *)p_ctx->cedid;
+	unsigned char* p_edidblk = p_edid->edidblk;
+
+
+	OUT_FMT* p_table = ch7036_crt_timing_table;
+	TIMING* p_timing;
+
+	unsigned char j=0;
+
+
+
+
+
+	established_timings_t *p_etiming_I = p_edid->etiming_I;
+	established_timings_t *p_etiming_II = p_edid->etiming_II;
+
+
+
+	standard_timings_t	*stiming = p_edid->stiming;
+	ch7036_attr_table_index_t* p_modes =  p_edid->modes;
+
+	unsigned long idx = 2;
+
+
+	PD_DEBUG("ch7036_parse_stardard_edid() channel [0x%x] - enter...\n", channel);
+
+
+	if(channel == CHANNEL_LVDS_HDMI) {
+
+		p_edid = (ch7036_edid_blk_t *)p_ctx->hedid;
+		p_edidblk = p_edid->edidblk;
+		p_etiming_I = p_edid->etiming_I;
+		p_etiming_II = p_edid->etiming_II;
+
+		stiming = p_edid->stiming;
+		p_modes =  p_edid->modes;
+
+
+		if (p_edid->ebn > 1) {
+			idx = 1;
+			p_table = hdmi_timing_table;
+		}
+		else {
+			idx = 0;
+			p_table = dvi_timing_table;
+			channel = 7;
+		}
+
+
+	}
+
+
+	while (index < MAX_ATTR_LIST_SIZE)
+		p_modes[index++] = FALSE;
+
+
+	if (p_edidblk[EDID_EXTENSION_FLAG] == 0x00 ) {
+
+
+		ch7036_parse_standard_timing(p_edid,0);
+
+
+		ch7036_parse_established_timing(p_ctx, p_edid);
+
+
+
+		ch7036_parse_detailed_descriptor_blocks(p_ctx, p_edid);
+
+
+
+		for(i=0; i<8;i++) {
+
+
+			index=0;
+			while (index < MAX_ATTR_LIST_SIZE ) {
+				if(p_modes[index]== TRUE) {
+					index++;
+					continue;
+				}
+				p_timing = &(p_table[index].timing);
+
+				if ( (p_edid->dtblk[j]).data_tag & 0x00FFFFFF ) {
+					OUT_FMT* p_dtd = &((p_edid->dtblk[j]).dtiming);
+
+					if( (p_dtd->timing.ha == p_timing->ha) && (p_dtd->timing.va == p_timing->va) && (p_dtd->timing.hz >= p_timing->hz) ) {
+						p_modes[index] = TRUE;
+						j= j> 3?3:j+1;
+
+						PD_DEBUG("ch7036_parse_standard_edid()- detailed timing mode supported- index [%d] name [%s]...\n",index,ch7036_get_mode_name(channel,index) );
+
+					}
+
+				}
+
+
+				if( (stiming[i].ha == p_timing->ha) && (stiming[i].va == p_timing->va) && (stiming[i].refresh_rate >= p_timing->hz) ) {
+					p_modes[index] = TRUE;
+					PD_DEBUG("ch7036_parse_standard_edid()- std_timing mode supported- index [%d] name [%s]...\n",index,ch7036_get_mode_name(channel,index) );
+				}
+
+				index++;
+
+			}
+
+		}
+
+
+		for(i=0;i<4;i++) {
+			if ( (p_edid->dtblk[i]).data_tag == 0xFA000000) {
+				;
+				continue;
+			}
+		}
+
+
+
+		for(i=0; i<8;i++) {
+
+
+
+			if( (p_etiming_I[i].is_supported == TRUE) && (p_etiming_I[i].index[idx] != OUT_CRT_END) ) {
+				p_modes[p_etiming_I[i].index[idx]] = TRUE;
+				PD_DEBUG("ch7036_parse_standard_edid()- et1 mode supported- index [%d] name [%s]...\n",p_etiming_I[i].index[idx],p_etiming_I[i].mode_name);
+				continue;
+
+			}
+
+
+			if( (i==7) && (channel ==7) && (p_etiming_I[i].is_supported == TRUE) ) {
+				p_modes[p_etiming_I[i].index[idx]] = TRUE;
+				PD_DEBUG("ch7036_parse_standard_edid()- et1 mode supported- index [%d] name [%s]...\n",p_etiming_I[i].index[idx],p_etiming_I[i].mode_name);
+			}
+
+
+		}
+
+		for(i=0; i<8;i++) {
+
+			if( (p_etiming_II[i].is_supported == TRUE) && (p_etiming_II[i].index[idx] != OUT_CRT_END) ) {
+				p_modes[p_etiming_II[i].index[idx]] = TRUE;
+				PD_DEBUG("ch7036_parse_standard_edid()- et2 mode supported- index [%d] name [%s]...\n",p_etiming_II[i].index[idx],p_etiming_II[i].mode_name);
+				continue;
+
+			}
+
+		}
+
+
+
+	}
+	else {
+		PD_DEBUG("ch7036_parse_standard_edid()- vga/dvi has more than one 128 byte block\n");
+	}
+
+
+	PD_DEBUG("ch7036_parse_stardard_edid()-channel [0x%x] - exit...\n", channel);
+
+	return SS_SUCCESS;
+
+}
+
+void ch7036_parse_detailed_descriptor_blocks(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid)
+{
+	unsigned long *monitor_descriptor;
+	unsigned char* p_ebuf, *p_st;
+	unsigned char* p_edidblk = p_edid->edidblk;
+	unsigned char i;
+	OUT_FMT* p_dt;
+
+
+	p_ebuf = &(p_edidblk[EDID_DETAILED_TIMING_DESCRIPTION_1]);
+
+	PD_DEBUG("parse_detailed_descriptor_blocks()- enter...\n");
+
+	for(i=0;i<4;i++) {
+
+		monitor_descriptor = (unsigned long *) p_ebuf;
+
+		if((*monitor_descriptor) & 0x00FFFFFF ) {
+
+
+			p_dt = &(p_edid->dtblk[i].dtiming);
+			ch7036_parse_detailed_timing(p_dt, p_ebuf);
+
+		}
+
+		else {
+
+			p_st = p_ebuf;
+			p_st +=5;
+
+			switch (*monitor_descriptor) {
+				case 0xFA000000:
+					ch7036_parse_standard_timing(p_edid,p_st);
+					break;
+
+				case 0xFD000000:
+					(p_edid->rtiming).vrate_min = *p_st;
+					(p_edid->rtiming).vrate_max = *(p_st+1);
+					(p_edid->rtiming).hrate_min = *(p_st+2);
+					(p_edid->rtiming).hrate_max = *(p_st+3);
+					(p_edid->rtiming).pclk_max = (unsigned long)(*(p_st+4))*10000L;
+
+
+					break;
+
+				case 0xFC000000:
+				case 0xFF000000:
+				default:
+					break;
+			}
+		}
+
+		(p_edid->dtblk[i]).data_tag = *monitor_descriptor;
+
+		p_ebuf += 18;
+	}
+
+	return;
+}
+
+void ch7036_parse_detailed_timing(OUT_FMT *p_dt, unsigned char* p_ebuf)
+{
+
+	unsigned short blanking;
+
+	PD_DEBUG("ch7036_parse_detailed_descriptor_timing()- enter...\n");
+
+
+	p_dt->clk_freq = ((uint32)(p_ebuf[1]<<8) | p_ebuf[0]) * 10;
+
+	p_dt->timing.ha = ((uint16)(p_ebuf[4] & 0xF0) << 4) | p_ebuf[2];
+
+	PD_DEBUG("ch7036_parse_detailed_timing() byte 3 [%x] byte 5 [%x]\n",p_ebuf[2],p_ebuf[4]);
+
+	blanking = ((uint16)(p_ebuf[4] & 0x0F) << 8) | p_ebuf[3];
+	p_dt->timing.ht = p_dt->timing.ha + blanking;
+
+	p_dt->timing.va = ((uint16)(p_ebuf[7] & 0xF0) << 4) | p_ebuf[5];
+
+	PD_DEBUG("ch7036_parse_detailed_timing() byte 6 [%x] byte 8 [%x]\n",p_ebuf[5],p_ebuf[7]);
+
+	blanking = ((uint16)(p_ebuf[7] & 0x0F) << 8) | p_ebuf[6];
+	p_dt->timing.vt = p_dt->timing.va + blanking;
+
+	PD_DEBUG("ch7036_parse_detailed_timing()- pclk [%d] Khz ha [%d] va [%d] ht [%d] vt [%d]\n",p_dt->clk_freq,p_dt->timing.ha,p_dt->timing.va,p_dt->timing.ht,p_dt->timing.vt);
+
+	p_dt->timing.hz = 	(((p_dt->clk_freq / p_dt->timing.ht) + 1 ) * 1000) / p_dt->timing.vt;
+
+	p_dt->timing.stype = (p_ebuf[17] & 0x80)?0:1;
+
+	PD_DEBUG("ch7036_parse_detailed_timing()- refresh [%d] scantype [%d]\n",
+		p_dt->timing.hz,p_dt->timing.stype);
+
+	return;
+}
+
+
+
+void ch7036_parse_standard_timing(ch7036_edid_blk_t* p_edid, unsigned char* p_addtional_st)
+{
+	standard_timings_t *stiming = p_edid->stiming;
+	unsigned char i, max=8;
+
+	unsigned char* p_edidblk = &(p_edid->edidblk[EDID_STANDARD_TIMINGS]);
+
+
+	PD_DEBUG("ch7036_parse_standard_timing()- enter\n");
+
+	if(p_addtional_st) {
+		p_edidblk = p_addtional_st;
+		stiming = p_edid->stiming_x;
+		max = 6;
+	}
+
+	for(i = 0; i < max; stiming++,i++) {
+
+
+		if( (*p_edidblk) == 0x01 &&  *(p_edidblk+1) == 0x01)
+			continue;
+
+		stiming->ha = ((*p_edidblk) + 31) << 3 ;
+
+		stiming->refresh_rate = (*(p_edidblk + 1) & 0x3F) + 60;
+
+		switch(*(p_edidblk +1) >> 6) {
+
+		   case 0:
+			   stiming->va =  (stiming->ha *10) >> 4;
+			   break;
+		   case 1:
+			   stiming->va =  (stiming->ha *3) >> 2;
+			   break;
+		   case 2:
+			   stiming->va =  (stiming->ha << 2) / 5;
+			   break;
+		   case 3:
+			   stiming->va =  (stiming->ha* 9) >>4;
+			   break;
+		   default:
+			   break;
+		}
+
+		p_edidblk +=2;
+
+		PD_DEBUG("ch7036_parse_standard_timing()- ha [%d] va [%d] refresh [%d]\n",stiming->ha,stiming->va,stiming->refresh_rate);
+
+	}
+
+	return;
+}
+
+
+
+
+void ch7036_parse_established_timing(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid)
+{
+
+	unsigned char* p_edidblk = p_edid->edidblk;
+
+
+
+	established_timings_t *p_etiming_I = p_edid->etiming_I;
+	established_timings_t *p_etiming_II = p_edid->etiming_II;
+	established_timings_t *p_etiming_man = p_edid->etiming_man;
+
+	unsigned char i=0;
+	unsigned char et1, et2;
+
+	PD_DEBUG("ch7036_parse_established_timing()- enter...\n");
+
+	et1 = p_edidblk[EDID_ESTABLISHED_TIMINGS_1];
+	et2 = p_edidblk[EDID_ESTABLISHED_TIMINGS_2];
+
+
+
+	for(i=0; i<8;i++) {
+	  p_etiming_I[i].is_supported = FALSE;
+	  p_etiming_II[i].is_supported = FALSE;
+	}
+
+
+
+	p_etiming_man->is_supported = FALSE;
+
+
+	for(i=0;i<8;i++) {
+
+
+
+		if(et1 & 0x01) {
+			p_etiming_I[i].is_supported = TRUE;
+
+		}
+
+
+		if(et2 & 0x01) {
+			p_etiming_II[i].is_supported = TRUE;
+
+		}
+
+		et1 >>=  1;
+		et2 >>=  1;
+
+	}
+
+
+
+	if (p_edidblk[EDID_MANUFACTURERS_RESERVED_TIMINGS] & 0x80) {
+
+		p_etiming_man->is_supported = TRUE;
+
+	}
+
+
+	return;
+
+}
+
+
+ch7036_status_t ch7036_parse_cea_edid(ch7036_device_context_t* p_ctx)
+{
+	uint8 tag, blk_size =0;
+	uint8 index = 0;
+
+	uint16 count;
+
+	uint8*  p_buff;
+
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+	unsigned char* p_edidblk = p_hedid->edidblk;
+	ch7036_attr_table_index_t* p_modes =  p_hedid->modes;
+
+
+	PD_DEBUG("ch7036_parse_cea_edid()- enter...\n");
+
+	while (index < MAX_ATTR_LIST_SIZE )
+		p_modes[index++] = FALSE;
+
+
+	if(p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET] == 0 ||  p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET] > 124) {
+		PD_DEBUG("ch7036_parse_cea_edid()- invalid data block size [%d]\n", p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET]);
+		return SS_UNSUCCESSFUL;
+	}
+
+
+
+	PD_DEBUG("ch7036_parse_cea_edid()- CEA revision [0x%x]...\n",p_edidblk[EDID_CEA_REVISION]);
+
+	if(p_edidblk[EDID_CEA_TAG] == 0x02 && p_edidblk[EDID_CEA_REVISION] == 0x03)
+	{
+
+		p_buff = &(p_edidblk[EDID_CEA_DATA_BLOCK]);
+
+
+
+		count=4 ;
+		for(; count < p_edidblk[EDID_CEA_DETAILED_TIMING_DATA_OFFSET]; p_buff += blk_size) {
+
+			blk_size = (*p_buff) & 0x1F;
+			tag = (*p_buff) & 0xE0;
+
+			PD_DEBUG("ch7036_parse_cea_edid()- data type [0x%x] block_size [%d]\n", tag, blk_size);
+
+			p_buff++;
+			switch (tag) {
+
+				case 0x20:
+
+					break;
+
+				case 0x40:
+					ch7036_parse_cea_video_data_block(blk_size, p_buff, p_hedid);
+					break;
+
+				case 0x60:
+					break;
+
+				case 0x80:
+					break;
+
+				default:
+					break;
+
+			}
+
+			count += (blk_size + 1);
+
+
+		}
+
+	}
+
+
+	PD_DEBUG("ch7036_parse_cea_edid()- exit...\n");
+
+	return SS_SUCCESS;
+
+
+}
+
+
+void ch7036_parse_cea_video_data_block(uint8 blk_size, uint8* p_buff, ch7036_edid_blk_t* p_edid)
+{
+	uint8 i, index;
+
+	ch7036_attr_table_index_t* p_modes =  p_edid->modes;
+
+	for(i=1; i <= blk_size; i++, p_buff++ ) {
+
+			index=0;
+
+			PD_DEBUG("ch7036_parse_cea_video_data_block()- HDMI display video code [0x%x]\n",(*p_buff) & 0x7F);
+
+			while (index < OUT_HDMI_END) {
+
+
+				if( p_modes[index] == TRUE  ) {
+					index++;
+					continue;
+				}
+
+
+				if( ((*p_buff) & 0x7F) == hdmi_timing_table[index].fmt_index  ) {
+
+					p_modes[index] = TRUE;
+					PD_DEBUG("ch7036_parse_cea_video_data_block()- mode supported: global table index [%d] name [%s]...\n",index, ch7036_get_mode_name(CHANNEL_LVDS_HDMI,index) );
+
+					if( hdmi_timing_table[index-1].fmt_index == hdmi_timing_table[index].fmt_index) {
+
+						break;
+					}
+
+				}
+
+				index++;
+
+			}
+	}
+
+	return;
+}
+
+
+ch7036_status_t ch7036_parse_edid(ch7036_device_context_t* p_ctx)
+{
+
+
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+
+	ch7036_edid_blk_t* p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
+	ch7036_edid_blk_t* p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
+
+	unsigned char* p_edidblk=0;
+	ch7036_attr_table_index_t* p_modes = 0;
+	pd_attr_t  *p_attr = NULL ;
+	int RESET =1;
+
+	PD_DEBUG("ch7036_parse_edid()- enter...\n");
+
+
+	//hpd checking schemes
+	if(p_ctx->hpd == 0)
+		return SS_SUCCESS;
+
+
+	if (
+		( (pOutput_Info->channel & 0x02) &&  (p_ctx->hpd & 0x80) )||
+		( (pOutput_Info->channel & 0x04) &&  (p_ctx->hpd & 0x08) )
+		)
+		//parsing is already done
+		return SS_SUCCESS;
+
+
+	switch (pOutput_Info->channel) {
+		case CHANNEL_LVDS_HDMI:
+		case CHANNEL_HDMI:
+			if(p_hedid->is_edid) {
+				p_edidblk = p_hedid->edidblk;
+
+				p_hedid->is_preferred_timing = (p_edidblk[EDID_FEATURE_SUPPORT] >> 1) & 0x1;
+
+
+				if(pOutput_Info->hdmi_fmt.is_dvi_mode == 0) {
+					p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+					ch7036_parse_cea_edid(p_ctx);
+				}
+				else {
+					p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DVI_OUT_MODE, 0);
+					ch7036_parse_standard_edid(p_ctx, CHANNEL_LVDS_HDMI);
+				}
+
+
+
+				p_ctx->hpd |= 0x80; //don't parse again next time
+
+			}
+			else {
+
+				PD_DEBUG("ch7036_parse_edid()- hdmi edid read failed or never done...use default...\n");
+				ch7036_set_edid_display_supported_attr( (void *)p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_ctx->downscaled,p_hedid->modes,RESET);
+				p_ctx->hpd &= 0x7F; //allow to enter parsing block again
+
+			}
+
+			p_modes = p_hedid->modes;
+
+			break;
+
+		case CHANNEL_LVDS_VGA:
+		case CHANNEL_VGA:
+			if(p_cedid->is_edid) {
+				p_edidblk = p_cedid->edidblk;
+
+				p_cedid->is_preferred_timing = (p_edidblk[EDID_FEATURE_SUPPORT] >> 1) & 0x1;
+				p_attr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
+
+				ch7036_parse_standard_edid(p_ctx, CHANNEL_LVDS_VGA);
+				p_ctx->hpd |= 0x08;
+			}
+			else {
+				PD_DEBUG("ch7036_parse_edid()- vga edid read failed or never done...use default...\n");
+				ch7036_set_edid_display_supported_attr( (void *)p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_ctx->downscaled,p_cedid->modes,RESET);
+				p_ctx->hpd &= 0x7F; //allow to enter parsing block again
+			}
+			p_modes = p_cedid->modes;
+
+			break;
+		default:
+			//there is no separate DVI display channel, or LVDS edid reading at this time
+			//DVI display option should already be mapped to HDMI channel
+			p_edidblk = 0;
+
+	}
+
+	if(p_edidblk) {
+
+		ch7036_set_edid_display_supported_attr( (void *)p_attr,0,p_ctx->downscaled,p_modes,0);
+
+	}
+
+	PD_DEBUG("ch7036_parse_edid()- exit...\n");
+
+	return SS_SUCCESS;
+}
+
+
+void ch7036_alter_display_table(int all, void *p_table,unsigned char* p_modes, void* val,unsigned long* p_invis,unsigned char is_invis,unsigned char is_6x4)
+{
+	pd_attr_t  *p_attr;
+	unsigned long i,j;
+
+
+	PD_DEBUG("ch7036_alter_display_table()-enter...\n");
+
+	if(all) {
+		unsigned long* num_attrs = (unsigned long *)val;
+		for(i=0;i<3;i++) { //all 3 tables: hdmi, dvi, vga
+
+			p_attr = pd_get_attr((pd_attr_t *)p_table, *num_attrs, PD_ATTR_ID_HDMI_OUT_MODE+i, 0);
+			if(is_6x4)
+				p_attr++;
+			else
+				p_attr= p_attr + ch7036_invis_6x4_modes_table_size[i] + 1; //1 is to skip header
+
+
+			for(j=0; j < *p_invis;j++) {
+				if(is_invis)
+					p_attr->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+				else
+					p_attr->flags  &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+
+				p_attr++;
+			}
+			p_invis++; //now, grab dvi, then vga table size
+
+
+		}
+
+	}
+	else {
+		unsigned long id= 0,k;
+		p_attr = (pd_attr_t *)p_table;
+		id = p_attr->id;
+
+		if(is_6x4) {
+			p_attr++;
+			j=0;
+		}
+		else {
+			p_attr= p_attr + ch7036_invis_6x4_modes_table_size[id - PD_ATTR_ID_HDMI_OUT_MODE] + 1; //point to the first 7x4 entry
+			j= ch7036_invis_6x4_modes_table_size[id - PD_ATTR_ID_HDMI_OUT_MODE];
+		}
+		p_invis = p_invis + (id - PD_ATTR_ID_HDMI_OUT_MODE);
+		k= *p_invis + j;
+
+		for(; j < k;j++) {
+			if(is_invis) {
+				p_attr->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+				p_modes[j]=FALSE;
+			}
+
+			p_attr++;
+		}
+
+	}
+}
+
+
+ch7036_status_t ch7036_set_edid_display_supported_attr(void *p_table, unsigned long num_attrs, unsigned char* p_downscaled, unsigned char* p_modes, int is_reset)
+{
+
+	pd_list_attr_t *p_hdr = (pd_list_attr_t *)p_table;
+	pd_attr_t *p_entry = (pd_attr_t *)p_table;
+
+	uint8 i=0;
+
+#ifdef T_SHOW_EDID_DISPLAY_ATTR
+	pd_list_entry_attr_t *list_entry;
+#endif
+
+	PD_DEBUG("ch7036_set_edid_display_supported_attr()-enter... is_reset status = [%d]\n", is_reset);
+
+	if(is_reset) {
+		while (i < MAX_ATTR_LIST_SIZE ) {
+			p_modes[i++] = TRUE;
+		}
+
+
+
+		//special handling for 1080i/p @ 59Hz
+		p_entry = pd_get_attr((pd_attr_t *)p_table, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
+		p_entry++;
+		p_entry = p_entry + OUT_HDMI_1920x1080I_59;
+		p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+		p_entry += 2;
+		p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+
+	}
+	else {
+
+		PD_DEBUG("ch7036_set_edid_display_supported_attr()-start to build edid display mode list...\n");
+
+		p_entry++;
+
+		for (i = 0; i < p_hdr->num_entries ; ++i,++p_entry) {
+			if(
+				(p_modes[i] == FALSE) ||
+				//1080 i/p @ 59 Hz
+				((p_hdr->id == PD_ATTR_ID_HDMI_OUT_MODE) && (i == OUT_HDMI_1920x1080I_59 || i== OUT_HDMI_1920x1080P_59) ) ){
+
+				p_entry->flags  |= PD_ATTR_FLAG_USER_INVISIBLE;
+				continue;
+			}
+
+
+			p_entry->flags  &= ~PD_ATTR_FLAG_USER_INVISIBLE;
+
+		}
+
+
+	}
+
+	//special handling for 8x6,7x4,6x4-
+	ch7036_alter_display_table(is_reset,p_table,p_modes,(void *)&num_attrs,ch7036_invis_6x4_modes_table_size,*p_downscaled,1);
+	p_downscaled++;
+	ch7036_alter_display_table(is_reset,p_table,p_modes,(void *)&num_attrs,ch7036_invis_8x6_7x4_table_size,*p_downscaled,0);
+
+#ifdef T_SHOW_EDID_DISPLAY_ATTR
+
+	list_entry = (pd_list_entry_attr_t *)(p_table);
+
+	for (i = 0,++list_entry; i < p_hdr->num_entries; ++i, ++list_entry)
+		PD_DEBUG("ch7036 : ch7036_set_edid_display_supported_attr : \n"
+				  "list entry[%hhu]=%s, id=%lu, "
+					  "value=%lu, flags=0x%x \n",
+					  i, list_entry->name, list_entry->id,
+					  list_entry->value, (unsigned char)list_entry->flags);
+#endif
+
+
+	return SS_SUCCESS;
+}
+
+
+uint8 * ch7036_get_mode_name(uint32 channel, uint8 index)
+{
+	uint8* str = "Name String Is Not Yet Converted";
+
+	switch (channel) {
+
+		case CHANNEL_LVDS_HDMI:
+			switch (index) {
+				case OUT_HDMI_640x480P_59:
+					return ("OUT_HDMI_640x480P_59");
+				case OUT_HDMI_640x480P_60:
+					return ("OUT_HDMI_640x480P_60");
+				case OUT_HDMI_720x480P_59:
+					return ("OUT_HDMI_720x480P_59");
+				case OUT_HDMI_720x480P_60:
+					return ("OUT_HDMI_720x480P_60");
+				case OUT_HDMI_1280x720P_59:
+					return ("OUT_HDMI_1280x720P_59");
+				case OUT_HDMI_1280x720P_60:
+					return ("OUT_HDMI_1280x720P_60");
+				case OUT_HDMI_1920x1080I_59:
+					return ("OUT_HDMI_1920x1080I_59");
+				case OUT_HDMI_1920x1080I_60:
+					return ("OUT_HDMI_1920x1080I_60");
+				case OUT_HDMI_1920x1080P_59:
+					return ("OUT_HDMI_1920x1080P_59");
+				case OUT_HDMI_1920x1080P_60:
+					return ("OUT_HDMI_1920x1080P_60");
+
+
+			}
+			break;
+
+		case CHANNEL_LVDS_VGA:
+
+			switch (index) {
+
+				case OUT_CRT_640x400_85:
+					return ("OUT_CRT_640x400_85");
+
+				case OUT_CRT_640x480_60:
+					return ("OUT_CRT_640x480_60");
+				case OUT_CRT_640x480_72:
+					return ("OUT_CRT_640x480_72");
+				case OUT_CRT_640x480_75:
+					return ("OUT_CRT_640x480_75");
+				case OUT_CRT_640x480_85:
+					return ("OUT_CRT_640x480_85");
+
+				case OUT_CRT_720x400_85:
+					return ("OUT_CRT_720x400_85");
+
+				case OUT_CRT_800x600_56:
+					return ("OUT_CRT_800x600_56");
+				case OUT_CRT_800x600_60:
+					return ("OUT_CRT_800x600_60");
+				case OUT_CRT_800x600_72:
+					return ("OUT_CRT_800x600_72");
+				case OUT_CRT_800x600_75:
+					return ("OUT_CRT_800x600_75");
+
+				case OUT_CRT_800x600_85:
+					return ("OUT_CRT_800x600_85");
+
+				case OUT_CRT_1024x768_60:
+					return ("OUT_CRT_1024x768_60");
+				case OUT_CRT_1024x768_70:
+					return ("OUT_CRT_1024x768_70");
+				case OUT_CRT_1024x768_75:
+					return ("OUT_CRT_1024x768_75");
+				case OUT_CRT_1024x768_85:
+					return ("OUT_CRT_1024x768_85");
+
+				case OUT_CRT_1152x864_75:
+					return ("OUT_CRT_1152x864_75");
+
+				case OUT_CRT_1280x768_60:
+					return ("OUT_CRT_1280x768_60");
+				case OUT_CRT_1280x768_75:
+					return ("OUT_CRT_1280x768_75");
+				case OUT_CRT_1280x768_85:
+					return ("OUT_CRT_1280x768_85");
+
+				case OUT_CRT_1280x960_60:
+					return ("OUT_CRT_1280x960_60");
+				case OUT_CRT_1280x960_85:
+					return ("OUT_CRT_1280x960_85");
+
+				case OUT_CRT_1280x1024_60:
+					return ("OUT_CRT_1280x1024_60");
+				case OUT_CRT_1280x1024_75:
+					return ("OUT_CRT_1280x1024_75");
+				case OUT_CRT_1280x1024_85:
+					return ("OUT_CRT_1280x1024_85");
+
+				case OUT_CRT_1360x768_60:
+					return ("OUT_CRT_1360x768_60");
+
+				case OUT_CRT_1400x1050_60:
+					return ("OUT_CRT_1400x1050_60");
+				case OUT_CRT_1400x1050_75:
+					return ("OUT_CRT_1400x1050_75");
+
+				case OUT_CRT_1440x900_60:
+					return ("OUT_CRT_1440x900_60");
+
+				case OUT_CRT_1440x1050_60:
+					return ("OUT_CRT_1440x1050_60");
+
+				case OUT_CRT_1600x900_60:
+					return ("OUT_CRT_1600x900_60");
+
+				case OUT_CRT_1600x1200_60:
+					return ("OUT_CRT_1600x1200_60");
+
+				case OUT_CRT_1920x1080_60:
+					return ("OUT_CRT_1920x1080_60");
+
+			}
+			break;
+
+		default:
+			switch (index) {
+				case OUT_DVI_640x480_60:
+					return ("OUT_DVI_640x480_60");
+				case OUT_DVI_640x480_72:
+					return ("OUT_DVI_640x480_72");
+
+				case OUT_DVI_720x400_70:
+					return ("OUT_DVI_720x400_70");
+
+				case OUT_DVI_800x600_56:
+					return ("OUT_DVI_800x600_56");
+				case OUT_DVI_800x600_60:
+					return ("OUT_DVI_800x600_60");
+				case OUT_DVI_800x600_72:
+					return ("OUT_DVI_800x600_72");
+				case OUT_DVI_800x600_75:
+					return ("OUT_DVI_800x600_75");
+
+				case OUT_DVI_1024x768_60:
+					return ("OUT_DVI_1024x768_60");
+				case OUT_DVI_1024x768_70:
+					return ("OUT_DVI_1024x768_70");
+				case OUT_DVI_1024x768_75:
+					return ("OUT_DVI_1024x768_75");
+
+				case OUT_DVI_1152x864_60:
+					return ("OUT_CRT_1152x864_60");
+
+				case OUT_DVI_1280x720_60:
+					return ("OUT_DVI_1280x720_60");
+
+				case OUT_DVI_1280x800_60:
+					return ("OUT_DVI_1280x800_60");
+
+				case OUT_DVI_1280x960_60:
+					return ("OUT_DVI_1280x960_60");
+
+				case OUT_DVI_1280x1024_60:
+					return ("OUT_DVI_1280x1024_60");
+				case OUT_DVI_1280x1024_75:
+					return ("OUT_DVI_1280x1024_75");
+
+				case OUT_DVI_1360x768_60:
+					return ("OUT_DVI_1360x768_60");
+
+				case OUT_DVI_1366x768_60:
+					return ("OUT_DVI_1366x768_60");
+
+				case OUT_DVI_1400x1050_60:
+					return ("OUT_DVI_1400x1050_60");
+				case OUT_DVI_1400x1050_75:
+					return ("OUT_DVI_1400x1050_75");
+
+				case OUT_DVI_1440x900_60:
+					return ("OUT_DVI_1440x900_60");
+
+				case OUT_DVI_1440x1050_60:
+					return ("OUT_DVI_1440x1050_60");
+
+				case OUT_DVI_1600x900_60:
+					return ("OUT_DVI_1600x900_60");
+
+				case OUT_DVI_1600x1200_60:
+					return ("OUT_DVI_1600x1200_60");
+
+				case OUT_DVI_1680x1050_60:
+					return ("OUT_DVI_1680x1050_60");
+
+				case OUT_DVI_1920x1080_60:
+					return ("OUT_DVI_1920x1080_60");
+			}
+			break;
+
+
+	}
+
+
+	return str;
+
+}
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.h
index fb4cf46..0efb4da 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_intf.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_intf.h
-* @version 1.1.4
+* @version 1.2.5
 *-----------------------------------------------------------------------------
 */
 
@@ -30,7 +30,6 @@
 #ifndef _CH7036_INTF_H_
 #define _CH7036_INTF_H_
 
-#include <linux/kernel.h>
 
 #include <config.h>
 #include <igd_pd.h>
@@ -42,9 +41,17 @@
 #include "ch7036_iic.h"
 #include "ch7036.h"
 
+#include "ch7036_fw.h"
+
 
 #include "config_.h"
 
+#ifdef T_LINUX
+#include "asm/div64.h"
+#endif
+
+
+#define internal_lvds_context_t lvds_context_t
 
 typedef unsigned char i2c_reg_t;
 
@@ -69,6 +76,8 @@ typedef unsigned char i2c_reg_t;
 #define DEF_LVDS_TXDRV_CTRL				0
 #define DITHER_ENABLE					0
 #define DITHER_BYPASS					1
+#define MODE_6x4_BYPASS					0
+#define MODE_8x6_7x4_BYPASS				1
 
 
 typedef struct {
@@ -86,24 +95,15 @@ typedef struct {
 
 typedef unsigned char ch7036_hpd_t;
 
+#define CH7036HPD_RESERVED1						0x01  //force port status inquiry bit
+#define CH7036HPD_CRT_ATTACHED					0x02
+#define CH7036HPD_CRT_STATUS_CHANGED			0x04
+#define CH7036HPD_CRT_EDID_PARSING_STATUS		0x08
 
-#define CH7036HPD_CRT_HPD_STATUS		0x01
-#define CH7036HPD_CRT_ATTACHED			0x02
-#define CH7036HPD_CRT_STATUS_CHANGED	0x04
-
-
-#define CH7036HPD_HDVI_HPD_STATUS		0x10
-#define CH7036HPD_HDVI_ATTACHED			0x20
-#define CH7036HPD_HDVI_STATUS_CHANGED	0x40
-
-
-
-typedef struct ch7036_s3_state {
-	unsigned long pwr_state;
-	pd_timing_t cur_timing;
-} ch7036_s3_state_t;
-
-
+#define CH7036HPD_RESERVED2						0x10 //incorrect display choice bit
+#define CH7036HPD_HDVI_ATTACHED					0x20
+#define CH7036HPD_HDVI_STATUS_CHANGED			0x40
+#define CH7036HPD_HDVI_EDID_PARSING_STATUS		0x80
 
 
 typedef struct _ch7036_device_context {
@@ -128,8 +128,11 @@ typedef struct _ch7036_device_context {
 
 	pd_timing_t					*p_lvds_table;
 
-	pd_timing_t					*native_dtd;
-	pd_timing_t					*p_cur_mode;
+
+
+
+	pd_timing_t					native_dtd;
+
 
 	unsigned short				fp_width;
 	unsigned short				fp_height;
@@ -142,19 +145,20 @@ typedef struct _ch7036_device_context {
 	unsigned char				init_done;
 
 
-	uint8						req_ddc;
-	uint8						lvds_only;
+
+
 	uint8						use_firmware;
 
 	ch7036_hpd_t				hpd;
+	uint8						man_sel_out;  //auto or manually select display output channel
 
 	uint32						prev_outchannel;
 
 	void*						fw;
 	void*						cedid;
 	void*						hedid;
-
-
+	uint8						downscaled[2];
+	uint8						dwnscal_bypass; //1: remove 8x6,&7x4 when downscaling, 0: keep them
 
 	uint32						last_emsg;
 
@@ -163,6 +167,21 @@ typedef struct _ch7036_device_context {
 
 
 
+#if 0
+#define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) lvds_open params
+#define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) lvds_post_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) lvds_set_mode params
+#define PD_INTERNAL_LVDS_MODULE_SET_POWER(name, params) lvds_set_power params
+#define PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(name, params) lvds_init_device params
+#define PD_INTERNAL_LVDS_MODULE_CLOSE(name, params) lvds_close params
+#define PD_INTERNAL_LVDS_MODULE_GET_ATTRIBUTES(name, params) lvds_get_attrs params
+#define PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(name, params) lvds_set_attrs params
+#define PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(name, params) lvds_get_timing_list params
+
+#endif
+
+
+
 #define PD_INTERNAL_LVDS_MODULE_OPEN(name, params) internal_lvds_open params
 #define PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(name, params) internal_lvds_post_set_mode params
 #define PD_INTERNAL_LVDS_MODULE_SET_MODE(name, params) internal_lvds_set_mode params
@@ -179,6 +198,7 @@ typedef struct _ch7036_device_context {
 
 
 
+
 ch7036_status_t ch7036_device_prepare(ch7036_device_context_t* p_ctx);
 ch7036_status_t ch7036_device_config(ch7036_device_context_t* p_ctx);
 ch7036_status_t ch7036_device_start(ch7036_device_context_t* p_ctx);
@@ -193,24 +213,31 @@ void ch7036_set_prefer_timing_info(ch7036_device_context_t *p_ctx,PREFER_INFO* p
 
 ch7036_status_t ch7036_load_firmware(ch7036_device_context_t* p_ctx);
 ch7036_status_t ch7036_get_attached_device(ch7036_device_context_t* p_ctx);
-ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_read_edid(ch7036_device_context_t* p_ctx, uint32 channel);
 ch7036_status_t ch7036_get_hdvi_display_modes_supported(ch7036_device_context_t* p_ctx);
 
 
+uint8 * ch7036_get_mode_name(uint32 channel, uint8 index);
+//void ch7036_reset_edid_supported_modes(unsigned char *p_modes);
+ch7036_status_t ch7036_parse_edid(ch7036_device_context_t* p_ctx);
+ch7036_status_t ch7036_parse_cea_edid(ch7036_device_context_t* p_ctx);
+void ch7036_parse_cea_video_data_block(uint8 blk_size, uint8* p_buff, ch7036_edid_blk_t* p_edid);
+ch7036_status_t ch7036_set_edid_display_supported_attr(void *p_table, unsigned long num_attrs, unsigned char* p_downscaled, unsigned char* p_modes,int is_reset);
+void ch7036_alter_display_table(int all, void *p_table,unsigned char* p_modes, void* val,unsigned long* p_invis,unsigned char is_invis,unsigned char is_6x4);
+
+ch7036_status_t ch7036_parse_standard_edid(ch7036_device_context_t* p_ctx, uint32 channel);
 
+void ch7036_parse_standard_timing(ch7036_edid_blk_t* p_edid, unsigned char* p_addtional_st);
 
+void ch7036_parse_established_timing(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid);
+void ch7036_parse_detailed_descriptor_blocks(ch7036_device_context_t* p_ctx, ch7036_edid_blk_t* p_edid);
+void ch7036_parse_detailed_timing(OUT_FMT *p_dt, unsigned char* p_ebuf);
 
 
 void ch7036_reset_mcu(DEV_CONTEXT* p_ch_ctx);
 void ch7036_reset_datapath(DEV_CONTEXT* p_ch_ctx);
 void ch7036_reset(ch7036_device_context_t* p_ctx);
 
-
-
 extern uint32 GetLastErrorMessage(void);
 
-
-
-
-
 #endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_pm.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_pm.c
index 311905d..4429bce 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_pm.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_pm.c
@@ -21,14 +21,13 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_pm.c
-* @version 1.1.4
+* @version 1.2.4
 *-----------------------------------------------------------------------------
 */
 
 
-#include "ch7036_typedef.h"
-#include "ch7036_iic.h"
 
+#include "ch7036_intf.h"
 
 
 
@@ -42,10 +41,11 @@ void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
 	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
 	uint8 reg=0x00;
 
-
+	PD_DEBUG("ch7036: ch7036_set_power_lvds()-enter...channel [%lu]\n", pOutput_Info->channel);
 	if(pOutput_Info->channel & CHANNEL_LVDS)
 	{
 
+
 		I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		reg = I2CRead(p_ch7xxx_context,0x1A);
 		reg = reg & 0xEF;
@@ -56,7 +56,8 @@ void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
 	  if(((pOutput_Info->channel & CHANNEL_HDMI)==0x00)&&
 		 ((pOutput_Info->channel & CHANNEL_VGA) == 0x00))
 	    {
-		 reg = reg | 0x80;
+
+			reg = reg | 0x80;
 	    }
 		 I2CWrite(p_ch7xxx_context,0x11, reg);
 
@@ -79,8 +80,12 @@ void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
         I2CWrite(p_ch7xxx_context,0x0A, reg);
 
 
+		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) | 0x80 );
+
 
 		if((pOutput_Info->channel & CHANNEL_HDMI) == 0x00 && (pOutput_Info->channel & CHANNEL_VGA) == 0x00){
+
+
 		 I2CWrite(p_ch7xxx_context,0x03, 0x00);
 		 reg = I2CRead(p_ch7xxx_context,0x07);
 		 reg = reg | 0x02;
@@ -108,21 +113,26 @@ void ch7036_set_power_lvds(DEV_CONTEXT* p_ch7xxx_context)
 	{
 
 
+
         I2CWrite(p_ch7xxx_context,0x03, 0x00);
+
+		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F );
+
 		reg = I2CRead(p_ch7xxx_context,0x0A);
 		reg = reg | 0x08;
         I2CWrite(p_ch7xxx_context,0x0A, reg);
 
 		if((pOutput_Info->channel & CHANNEL_HDMI) == 0x00 && (pOutput_Info->channel & CHANNEL_VGA)==0x00)
 		{
-		 I2CWrite(p_ch7xxx_context,0x03, 0x04);
-		 reg = I2CRead(p_ch7xxx_context,0x63);
-		 reg = reg | 0xFC;
-		 I2CWrite(p_ch7xxx_context,0x63, reg);
 
-		 reg = I2CRead(p_ch7xxx_context,0x64);
-		 reg = reg | 0x01;
-		 I2CWrite(p_ch7xxx_context,0x64, reg);
+			I2CWrite(p_ch7xxx_context,0x03, 0x04);
+			reg = I2CRead(p_ch7xxx_context,0x63);
+			reg = reg | 0xFC;
+			I2CWrite(p_ch7xxx_context,0x63, reg);
+
+			reg = I2CRead(p_ch7xxx_context,0x64);
+			reg = reg | 0x01;
+			I2CWrite(p_ch7xxx_context,0x64, reg);
 		}
 
 		I2CWrite(p_ch7xxx_context,0x03, 0x04);
@@ -151,10 +161,11 @@ void ch7036_set_power_hdmi(DEV_CONTEXT* p_ch7xxx_context)
 	INPUT_INFO* pInput_Info = p_ch7xxx_context->pInput_Info;
 	uint8 reg=0x00;
 
-
+	PD_DEBUG("ch7036: ch7036_set_power_hdmi()-enter...channel [%lu]\n", pOutput_Info->channel);
    if(pOutput_Info->channel  & CHANNEL_HDMI)
    {
 
+
         I2CWrite(p_ch7xxx_context,0x03, 0x04);
 		reg = I2CRead(p_ch7xxx_context,0x52);
 		reg = reg & 0xEF;
@@ -229,13 +240,6 @@ void ch7036_set_power_hdmi(DEV_CONTEXT* p_ch7xxx_context)
 		I2CWrite(p_ch7xxx_context,0x07, reg);
 
 
-
-
-
-
-
-
-
 		I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		reg = I2CRead(p_ch7xxx_context,0x16);
 		reg = reg & 0xF7;
@@ -264,24 +268,12 @@ void ch7036_set_power_hdmi(DEV_CONTEXT* p_ch7xxx_context)
 
 
 
-
-
-
-
-
-
-
    }else {
 
 
-
-
-
-
-
-
 	   if((pOutput_Info->channel  & CHANNEL_VGA) == 0x00){
 
+
         I2CWrite(p_ch7xxx_context,0x03, 0x00);
 		reg = I2CRead(p_ch7xxx_context,0x0A);
 		reg = reg | 0x20;
@@ -332,11 +324,6 @@ void ch7036_set_power_hdmi(DEV_CONTEXT* p_ch7xxx_context)
 		}
 
 
-
-
-
-
-
 		I2CWrite(p_ch7xxx_context,0x03, 0x00);
 		reg = I2CRead(p_ch7xxx_context,0x07);
 		reg = reg | 0x40;
@@ -345,10 +332,6 @@ void ch7036_set_power_hdmi(DEV_CONTEXT* p_ch7xxx_context)
 
 
 
-
-
-
-
 		if((pOutput_Info->channel  & CHANNEL_LVDS) == 0x00)
 		{
 		 I2CWrite(p_ch7xxx_context,0x03, 0x01);
@@ -391,27 +374,17 @@ void ch7036_set_power_crt(DEV_CONTEXT* p_ch7xxx_context)
 	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
 	uint8 reg=0x00;
 
-
+	PD_DEBUG("ch7036: ch7036_set_power_crt()-enter...channel [%lu]\n", pOutput_Info->channel);
 	if(pOutput_Info->channel & CHANNEL_VGA)
 	 {
 
+
 	   I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		reg = I2CRead(p_ch7xxx_context,0x11);
 		reg = reg & 0x7F;
 	    I2CWrite(p_ch7xxx_context,0x11, reg);
 
 
-
-
-
-
-
-
-
-
-
-
-
 		I2CWrite(p_ch7xxx_context,0x03, 0x00);
 		reg = I2CRead(p_ch7xxx_context,0x0A);
 		reg = reg & 0xDF;
@@ -454,6 +427,8 @@ void ch7036_set_power_crt(DEV_CONTEXT* p_ch7xxx_context)
 
 	}else if((pOutput_Info->channel & CHANNEL_VGA) == 0x00){
 
+
+
 		I2CWrite(p_ch7xxx_context,0x03, 0x00);
 
 		 reg = I2CRead(p_ch7xxx_context,0x08);
@@ -463,6 +438,9 @@ void ch7036_set_power_crt(DEV_CONTEXT* p_ch7xxx_context)
 
 
 		if((pOutput_Info->channel & CHANNEL_HDMI)==0x00){
+
+
+
 	     I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		 reg = I2CRead(p_ch7xxx_context,0x11);
 		 reg = reg | 0x80;
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c
index e40fdc4..1d33f50 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.c
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_port.c
-* @version 1.1.4
+* @version 1.2.5
 *-----------------------------------------------------------------------------
 */
 
@@ -29,13 +29,17 @@
 #include <linux/kernel.h>
 
 #include "ch7036_port.h"
-#include "ch7036_fw.h"
-#include "lvds/lvds.h"
 
 
+#ifdef T_LINUX
+	#include "lvds/lvds.h"
+#else
+	#include "lvds.h"
+#endif
+
 
 
-static pd_version_t  g_ch7036_version = {1, 0, 0, 0};
+static pd_version_t  g_ch7036_version = {1, 2, 5, 0};
 static unsigned long g_ch7036_dab_list[] = {0xEC,PD_DAB_LIST_END};
 
 
@@ -69,12 +73,9 @@ static pd_driver_t	 g_ch7036_drv = {
 };
 
 
-
-ch7036_edid_blk_t crt_edid;
-ch7036_edid_blk_t hdvi_edid;
-
-
-
+extern established_timings_t et_I[8];
+extern established_timings_t et_II[8];
+extern established_timings_t et_man;
 
 
 int PD_MODULE_INIT(ch7036_init, (void *handle))
@@ -104,6 +105,7 @@ int PD_MODULE_EXIT(ch7036_exit, (void))
 unsigned long ch7036_validate(unsigned long cookie)
 {
 	PD_DEBUG("ch7036: ch7036_validate()\n");
+
 	return cookie;
 }
 
@@ -111,51 +113,68 @@ unsigned long ch7036_validate(unsigned long cookie)
 int ch7036_open(pd_callback_t *p_callback, void **pp_context)
 {
 	uint8 device_ID;
-	/*uint8 reg;*/
-	ch7036_device_context_t* p_ctx = NULL;
+	ch7036_device_context_t* p_ctx;
 	DEV_CONTEXT* p_ch7xxx_context;
 
-	/*uint8 page, n;*/
+	ch7036_edid_blk_t *p_edid1, *p_edid2;
+
 
 	int ret;
 
 
-	PD_DEBUG("ch7036: ch7036_open()\n");
 
-	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_internal_lvds_open,(p_callback, pp_context));
+	PD_DEBUG("ch7036: ch7036_open()- enter- ch7036 pd release- major [%x] minor [%x] patch [%x]\n",
+		g_ch7036_version.major,g_ch7036_version.minor,g_ch7036_version.patch);
+
+	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_lvds_open,(p_callback, pp_context));
 	if ( ret != PD_SUCCESS)
 	{
-		if (p_ctx != NULL) {
-			pd_free(p_ctx->fw);
-			pd_free(p_ctx);
-		}
+
+
+		PD_ERROR("ch7036: ch7036_open: EXIT#1\n");
 		return ret;
 	}
 
-
 	p_ctx = pd_malloc(sizeof(ch7036_device_context_t));
 	if (p_ctx == NULL) {
+		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed\n");
 		goto exit6;
 	}
 
 	pd_memset(p_ctx, 0, sizeof(ch7036_device_context_t));
 
+	/* per EMGD request */
+	p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid;
+	p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid;
+
+
 	p_ctx->fw = (FW7036_CFG *)(pd_malloc(sizeof(FW7036_CFG)));
 
-	if (p_ctx == NULL) {
+	if (p_ctx->fw == NULL) {
 		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating FW7036_CFG struct\n");
 		goto exit5;
 	}
 
-
-	if (p_ctx == NULL || *pp_context == NULL || p_callback == NULL) {
-		goto exit5;
+#if 0
+	ret = PD_INTERNAL_LVDS_MODULE_OPEN(ch7036_lvds_open,(p_callback, pp_context));
+	if ( ret != PD_SUCCESS)
+	{
+		pd_free(p_ctx->fw);
+		pd_free(p_ctx);
+		return ret;
 	}
+#endif
 
 	p_ctx->internal_lvds = *pp_context;
 
 	p_ctx->p_callback = p_callback;
 
+#ifdef LVDS_ONLY
+	*pp_context = (void *)p_ctx;
+	return (PD_SUCCESS);
+#endif
+
+
 
 	p_ctx->p_ch7xxx_context = pd_malloc(sizeof(DEV_CONTEXT));
 	if (p_ctx->p_ch7xxx_context == NULL) {
@@ -168,6 +187,7 @@ int ch7036_open(pd_callback_t *p_callback, void **pp_context)
 	p_ch7xxx_context->pd_context = (void *)p_ctx;
 
 
+
 	I2CWrite(p_ch7xxx_context,0x03, 0x04);
 
 	device_ID = I2CRead(p_ch7xxx_context,0x50);
@@ -175,7 +195,6 @@ int ch7036_open(pd_callback_t *p_callback, void **pp_context)
 	PD_DEBUG("ch7036: ch7036_open()- read device ID= 0x%.2X\n", device_ID);
 
 
-
 	if(device_ID != 0x56)
 	{
 		PD_DEBUG("ch7036: ch7036_open()- device is NOT found...\n");
@@ -199,33 +218,107 @@ int ch7036_open(pd_callback_t *p_callback, void **pp_context)
 
 	}
 
-
 	p_ch7xxx_context->DeviceID = device_ID;
 
-
-	p_ctx->hpd = 0;
+	ch7036_reset(p_ctx);
+	pd_usleep(50);
 
 	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   {
 		p_ctx->use_firmware =0;
 		p_ctx->cedid = NULL;
 		p_ctx->hedid = NULL;
 
-
 	}
 	else {
 		p_ctx->use_firmware =1;
-		p_ctx->cedid = (ch7036_edid_blk_t *)&crt_edid;
-		p_ctx->hedid = (ch7036_edid_blk_t *)&hdvi_edid;
+
+
+		p_ctx->cedid = (ch7036_edid_blk_t *)pd_malloc(sizeof(ch7036_edid_blk_t));
+
+		if (p_ctx->cedid == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating ch7036_edid_blk_t struct for crt");
+			goto exit3;
+		}
+
+		p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid ;
+
+		p_edid1->etiming_I = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+		if (p_edid1->etiming_I == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct I for crt");
+			pd_free(p_ctx->cedid);
+			goto exit3;
+		}
+		p_edid1->etiming_II = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+		if (p_edid1->etiming_II == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct II for crt");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_ctx->cedid);
+			goto exit3;
+		}
+
+		p_ctx->hedid = (ch7036_edid_blk_t *)pd_malloc(sizeof(ch7036_edid_blk_t));
+
+		if (p_ctx->hedid == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating ch7036_edid_blk_t struct for hdvi");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+
+			goto exit3;
+		}
+
+		p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid ;
+
+		p_edid2->etiming_I = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+		if (p_edid2->etiming_I == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct I for crt");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+			pd_free(p_ctx->hedid);
+
+			goto exit3;
+		}
+
+		p_edid2->etiming_II = (established_timings_t *)pd_malloc(8 * sizeof(established_timings_t));
+
+		if (p_edid2->etiming_II == NULL) {
+			PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating established_timings_t struct for hdvi");
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+			pd_free(p_edid2->etiming_I);
+
+			pd_free(p_ctx->hedid);
+
+			goto exit3;
+		}
+
 
 	}
 
 
+	pd_memset(p_edid1->etiming_I, 0, 8 *
+			sizeof(established_timings_t));
+	pd_memset(p_edid1->etiming_II, 0, 8 *
+			sizeof(established_timings_t));
+
+	pd_memset(p_edid2->etiming_I, 0, 8 *
+			sizeof(established_timings_t));
+	pd_memset(p_edid2->etiming_II, 0, 8 *
+			sizeof(established_timings_t));
+
+
+
+
+
+
 
 	p_ch7xxx_context->pInput_Info = pd_malloc(sizeof(INPUT_INFO));
 	if (p_ch7xxx_context->pInput_Info == NULL) {
 		PD_ERROR("ch7036: Error ! ch7036_open: pd_malloc() failed allocating INPUT_INFO struct");
 
-		goto exit3;
+		goto exit23;
 	}
 
 	p_ch7xxx_context->pOutput_Info = pd_malloc(sizeof(OUTPUT_INFO));
@@ -253,29 +346,42 @@ int ch7036_open(pd_callback_t *p_callback, void **pp_context)
 		goto exit1;
 	}
 
-	ch7036_initialize_device(p_ctx);
 
+	ch7036_initialize_device(p_ctx);
 
 	g_ch7036_drv.type = PD_DISPLAY_LVDS_INT;
 
 
 	*pp_context = (void *)p_ctx;
 
+	PD_DEBUG("ch7036: ch7036_open: EXIT w/ SUCCESS...ch7036 pd release- major [%x] minor [%x] patch [%x]\n",
+		g_ch7036_version.major,g_ch7036_version.minor,g_ch7036_version.patch);
 	return (PD_SUCCESS);
 
 exit1:
 	pd_free(p_ch7xxx_context->pOutput_Info);
 exit2:
 	pd_free(p_ch7xxx_context->pInput_Info);
+
+exit23:
+	pd_free(p_edid1->etiming_I);
+	pd_free(p_edid1->etiming_II);
+	pd_free(p_ctx->cedid);
+	pd_free(p_edid2->etiming_I);
+	pd_free(p_edid2->etiming_II);
+	pd_free(p_ctx->hedid);
+
 exit3:
 	p_ch7xxx_context->pd_context=NULL;
 	pd_free(p_ch7xxx_context);
 exit4:
-	pd_free(p_ctx->internal_lvds);
+
+	p_ctx->internal_lvds = NULL;
 	pd_free(p_ctx->fw);
 exit5:
 	pd_free(p_ctx);
 exit6:
+	PD_ERROR("ch7036: ch7036_open: EXIT- PD_ERR_NOMEM\n");
 	return PD_ERR_NOMEM;
 }
 
@@ -283,12 +389,20 @@ exit6:
 int ch7036_init_device(void *p_context)
 {
 	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
+	int ret;
 
 	PD_DEBUG("ch7036: ch7036_init_device()-enter\n");
 
 	p_ctx->init_done = 1;
+	ret= PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(ch7036_lvds_init_device, (p_ctx->internal_lvds));
 
-	return (PD_INTERNAL_LVDS_MODULE_INIT_DEVICE(ch7036_init_device, (p_ctx->internal_lvds)));
+	p_ctx->prev_outchannel = pOutput_Info->channel;
+	PD_DEBUG("ch7036: ch7036_init_device()-p_ctx->prev_outchannel = pOutput_Info->channel = [0x%x]\n",pOutput_Info->channel);
+
+	PD_DEBUG("ch7036: ch7036_init_device()-exit\n");
+	return ret;
 
 }
 
@@ -309,7 +423,6 @@ int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 	PD_DEBUG("ch7036: ch7036_set_mode()-enter\n");
 
 
-
 	if (!p_ctx || !p_mode) {
 		return (PD_ERR_NULL_PTR);
 	}
@@ -318,10 +431,11 @@ int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 	{
 		return (PD_ERR_NULL_PTR);
 	}
+
 	PD_DEBUG("ch7036_set_mode: requested width = %u height = %u\n",
 		p_mode->width, p_mode->height);
 
-
+#ifndef LVDS_ONLY
 	if (
 		(p_ctx->fp_width && (p_mode->width > p_ctx->fp_width)) ||
 		(p_ctx->fp_height && (p_mode->height > p_ctx->fp_height))
@@ -329,26 +443,29 @@ int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 		return PD_ERR_MODE_NOTSUPP;
 	}
 
+	if( (p_ctx->fp_width == 640) && (p_ctx->fp_height == 480) ) {
+		p_ctx->downscaled[MODE_6x4_BYPASS] = 0;
+	}
+	else {
+		p_ctx->downscaled[MODE_6x4_BYPASS] = 1;
+		if( (!p_ctx->dwnscal_bypass) || ((p_ctx->fp_width <= 800) && (p_ctx->fp_height <= 600) )  )
+			p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 0;
+		else
+			p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 1;
 
-	p_ctx->p_cur_mode = p_mode;
-
+	}
 
 	if(pOutput_Info->channel  == CHANNEL_LVDS_HDMI_VGA_OFF) {
 
-		pOutput_Info->channel = ch7036_get_output_channel(p_ctx);
+		pOutput_Info->channel = p_ctx->prev_outchannel; //restore output channel before temp. power down
 		channel_on =1;
 	}
 
 
+	if (pOutput_Info->channel == CHANNEL_LVDS) {
 
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI;	//force both channel on before setting in/out timing
 
-	if(pOutput_Info->channel == CHANNEL_LVDS && p_ctx->use_firmware ) {
-		pOutput_Info->channel = CHANNEL_LVDS_HDMI;
-		p_ctx->req_ddc =1;
-	}
-	if (pOutput_Info->channel == CHANNEL_LVDS) {
-		pOutput_Info->channel = CHANNEL_LVDS_HDMI;
-		p_ctx->lvds_only =1;
 	}
 
 
@@ -359,7 +476,7 @@ int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 
 	if(ch7036_device_prepare(p_ctx)== SS_UNSUCCESSFUL)
 	{
-		PD_DEBUG("ch7036_set_mode: ch7036_device_prepare()- NOT SUCCESS\n");
+		PD_DEBUG("ch7036_set_mode: ch7036_device_prepare()- NOT SUCCESS... ERROR CODE [%lu]\n", p_ctx->last_emsg);
 		return PD_ERR_UNSUCCESSFUL;
 	}
 
@@ -368,14 +485,19 @@ int ch7036_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 
 	if(ch7036_device_config(p_ctx) == SS_UNSUCCESSFUL)
 	{
-		PD_DEBUG("ch7036_set_mode: ch7036_device_config()- NOT SUCCESS\n");
+		PD_DEBUG("ch7036_set_mode: ch7036_device_config()- NOT SUCCESS...ERROR CODE [%lu]\n", p_ctx->last_emsg);
 		return PD_ERR_UNSUCCESSFUL;
 	}
 
-	if(channel_on)
-		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF;
+	if(channel_on) {
+
+		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF; //now, power down if it's tmp. powered up
+
+	}
+
+#endif
 
-	ret = PD_INTERNAL_LVDS_MODULE_SET_MODE(ch7036_internal_lvds_set_mode,(p_ctx->internal_lvds,p_mode,flags));
+	ret = PD_INTERNAL_LVDS_MODULE_SET_MODE(ch7036_lvds_set_mode,(p_ctx->internal_lvds,p_mode,flags));
 	if(ret != PD_SUCCESS)
 		return ret;
 
@@ -391,16 +513,17 @@ void ch7036_update_position(ch7036_device_context_t *p_ctx, OUTPUT_INFO* pOutput
 
 
 	if(pOutput_Info->channel & CHANNEL_HDMI) {
-
 		pOutput_Info->h_position = DEFAULT_POSITION;
 		pOutput_Info->v_position = DEFAULT_POSITION;
 
 	}
-	else {//pOutput_Info->channel & CHANNEL_VGA; CHANNEL_LVDS would never come here
 
-			pOutput_Info->h_position =  pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HPOSITION,
+	else { //pOutput_Info->channel & CHANNEL_VGA; note that CHANNEL_LVDS would never come here
+
+			pOutput_Info->h_position = (uint16)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_HPOSITION,
 					PD_GET_ATTR_LIST)->current_value;
-			pOutput_Info->v_position = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_VPOSITION,
+
+			pOutput_Info->v_position = (uint16)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_VPOSITION,
 					PD_GET_ATTR_LIST)->current_value;
 
 	}
@@ -420,10 +543,9 @@ int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
 	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
 	OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;
-
 	int ret;
-	/*uint8 page, n;*/
-	pd_list_entry_attr_t  *list_entry;
+
+
 
 
 
@@ -436,11 +558,12 @@ int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
 		return (PD_ERR_NULL_PTR);
 	}
 
-	list_entry = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
-	ch7036_set_output_channel(p_ctx,(uint32)(list_entry->value));
+#ifndef LVDS_ONLY
 
 
-	PD_DEBUG("ch7036_post_set_mode- current output channel is [%x]\n",pOutput_Info->channel);
+
+	ch7036_set_output_channel(p_ctx, p_ctx->prev_outchannel);
+	PD_DEBUG("ch7036_post_set_mode- now, current pOutput_Info->channel is [%x]\n",pOutput_Info->channel);
 
 	if(ch7036_device_start(p_ctx) == SS_UNSUCCESSFUL)
 	{
@@ -450,34 +573,29 @@ int ch7036_post_set_mode(void *p_context, pd_timing_t *p_mode,
 
 
 
-	p_ctx->req_ddc = 0;
-	p_ctx->lvds_only = 0;
-
-#if 0
-	if(p_ctx->req_ddc && pOutput_Info->channel == CHANNEL_LVDS_HDMI && p_ctx->use_firmware) {
-
-		pOutput_Info->channel = CHANNEL_LVDS;
-		p_ctx->req_ddc = 0;
-	}
 
-	if (p_ctx->lvds_only  && pOutput_Info->channel == CHANNEL_LVDS_HDMI) {
-		pOutput_Info->channel = CHANNEL_LVDS;
-		p_ctx->lvds_only = 0;
-	}
 
 #endif
 
-	ret = PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(ch7036_post_set_mode,(p_ctx->internal_lvds,p_mode,flags));
 
+	ret = PD_INTERNAL_LVDS_MODULE_POST_SET_MODE(ch7036_lvds_post_set_mode,(p_ctx->internal_lvds,p_mode,flags));
+
+#ifndef LVDS_ONLY
 	if(ret != PD_SUCCESS)
 		return ret;
 	else
 	{
+
 		ch7036_reset_datapath(p_ch7xxx_context);
 		pd_usleep(50);
+
+
 		ch7036_device_set_power(p_ctx, pOutput_Info->channel);
+
+		p_ctx->prev_outchannel = pOutput_Info->channel;
 	}
 
+#endif
 
 	return PD_SUCCESS;
 }
@@ -490,20 +608,76 @@ int ch7036_close(void *p_context)
 {
 
 	ch7036_device_context_t* p_ctx  = (ch7036_device_context_t*)p_context;
+	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
+	ch7036_edid_blk_t *p_edid1, *p_edid2;
+
+	p_edid1 = (ch7036_edid_blk_t *)p_ctx->cedid;
+	p_edid2 = (ch7036_edid_blk_t *)p_ctx->hedid;
+
 
 	PD_DEBUG("ch7036: ch7036_close()\n");
 
-	PD_INTERNAL_LVDS_MODULE_CLOSE(ch7036_internal_lvds_close, (p_ctx->internal_lvds));
+#ifndef LVDS_ONLY
+
+	ch7036_set_power(p_context, PD_POWER_MODE_D3);
+#endif
+
+	PD_INTERNAL_LVDS_MODULE_CLOSE(ch7036_lvds_close, (p_ctx->internal_lvds));
 
 	if (p_ctx!= NULL)
 	{
 
-		pd_free(p_ctx->p_ch7xxx_context->pInput_Info);
-		pd_free(p_ctx->p_ch7xxx_context->pOutput_Info);
-		pd_free(p_ctx->p_ch7xxx_context->pPrefer_Info);
-		pd_free(p_ctx->p_ch7xxx_context);
-		pd_free(p_ctx->p_ch7036_attr_table);
+		if(p_ctx->p_ch7xxx_context) {
+
+			pd_free(p_ch7xxx_context->pInput_Info);
+			p_ch7xxx_context->pInput_Info = NULL;
+
+			pd_free(p_ch7xxx_context->pOutput_Info);
+			p_ch7xxx_context->pOutput_Info = NULL;
+
+			pd_free(p_ch7xxx_context->pPrefer_Info);
+			p_ch7xxx_context->pPrefer_Info = NULL;
+
+			pd_free(p_ctx->p_ch7xxx_context);
+			p_ch7xxx_context = NULL;
+		}
+
+
+		if(p_edid1) {
+			pd_free(p_edid1->etiming_I);
+			pd_free(p_edid1->etiming_II);
+			pd_free(p_ctx->cedid);
+
+			p_edid1->etiming_I=NULL;
+			p_edid1->etiming_II=NULL;
+			p_ctx->cedid = NULL;
+
+		}
+		if(p_edid2) {
+			pd_free(p_edid2->etiming_I);
+			pd_free(p_edid2->etiming_II);
+			pd_free(p_ctx->hedid);
+
+			p_edid2->etiming_I=NULL;
+			p_edid2->etiming_II=NULL;
+			p_ctx->hedid = NULL;
+
+		}
+
+		if ( p_ctx->p_ch7036_attr_table) {
+			pd_free(p_ctx->p_ch7036_attr_table);
+			p_ctx->p_ch7036_attr_table = NULL;
+			p_ctx->ch7036_num_attrs = 0;
+		}
+
+		if(p_ctx->fw) {
+			pd_free(p_ctx->fw);
+			p_ctx->fw = NULL;
+		}
+
+
 		pd_free(p_ctx);
+		p_ctx = NULL;
 	}
 
 	return PD_SUCCESS;
@@ -515,42 +689,59 @@ int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
 {
 	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	/*OUTPUT_INFO* pOutput_Info = p_ch7xxx_context->pOutput_Info;*/
 
-	int ret = 1;
-//	int i;
-//	pd_timing_t * p_table;
-//	internal_lvds_context_t * p_lvds = (internal_lvds_context_t *)(p_ctx->internal_lvds);
+	int ret = 0;
+
+
+#ifndef T_PANEL_NATIVE_DTD
+	int i;
+	pd_timing_t * p_table;
+	lvds_context_t * p_lvds = (lvds_context_t *)(p_ctx->internal_lvds);
+
+#endif
+
+	pd_port_status_t port_status;
+
+
 
 	PD_DEBUG("ch7036: ch7036_get_timing_list()-enter\n");
 
 	if (p_ch7xxx_context->DeviceID != 0x56)
 	{
-		return (PD_ERR_NULL_PTR);
+		return (PD_ERR_NODEV);
+	}
+
+#ifdef LVDS_ONLY
+	PD_DEBUG("NUHAIRI: p_ctx->internal_lvds = %lu\n", p_ctx->internal_lvds);
+	if (p_ctx->internal_lvds != NULL){
+		PD_DEBUG("NUHAIRI: p_ctx->internal_lvds = %lu\n", p_ctx->internal_lvds);
+		return PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
 	}
+	return PD_SUCCESS;
+#endif
+
 
 
 	if ( (g_ch7036_drv.type & PD_DISPLAY_LVDS_INT) || (g_ch7036_drv.type & PD_DISPLAY_LVDS_LHDV) )
 	{
-		ret = PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_internal_lvds_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
-		PD_ERROR("ch7036: ch7036_get_timing_list()- ret = %X\n", ret);
-
+		ret = PD_INTERNAL_LVDS_MODULE_GET_TIMING_LIST(ch7036_lvds_get_timing_list, (p_ctx->internal_lvds,p_in_list,pp_out_list));
 
+		if(((lvds_context_t *)(p_ctx->internal_lvds))->native_dtd == 0 )
+			return PD_ERR_NO_TIMINGS;
 
 		p_ctx->p_lvds_table = *pp_out_list;
 
 #ifdef T_PANEL_NATIVE_DTD
 
 
+		pd_memcpy(&(p_ctx->native_dtd),((lvds_context_t *)(p_ctx->internal_lvds))->native_dtd,sizeof(pd_timing_t));
 
-		p_ctx->native_dtd = ((internal_lvds_context_t *)(p_ctx->internal_lvds))->native_dtd;
-		p_ctx->fp_width = ((internal_lvds_context_t *)(p_ctx->internal_lvds))->fp_width;
-		p_ctx->fp_height = ((internal_lvds_context_t *)(p_ctx->internal_lvds))->fp_height;
+		p_ctx->fp_width = ((lvds_context_t *)(p_ctx->internal_lvds))->fp_width;
+		p_ctx->fp_height = ((lvds_context_t *)(p_ctx->internal_lvds))->fp_height;
 
 		if( (p_ctx->fp_width == 0) || (p_ctx->fp_height == 0) )
-		{	PD_ERROR("ch7036: ch7036_get_timing_list()- ret = PD_ERR_NO_TIMINGS\n" );
 			return PD_ERR_NO_TIMINGS ;
-		}
+
 #else
 
 		for(i=0,p_table = *pp_out_list;i< 30;i++)
@@ -560,7 +751,9 @@ int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
 					(p_table->refresh == 60) )
 				{
 
-					p_ctx->native_dtd =  p_table;
+
+
+					pd_memcpy(&(p_ctx->native_dtd),p_table,sizeof(pd_timing_t));
 					p_ctx->fp_width = p_table->width;
 					p_ctx->fp_height = p_table->height;
 
@@ -571,7 +764,8 @@ int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
 
 			}
 
-			p_lvds->native_dtd = p_ctx->native_dtd;
+
+			pd_memcpy(p_lvds->native_dtd,&(p_ctx->native_dtd),sizeof(pd_timing_t));
 			p_lvds->fp_width = p_ctx->fp_width;
 			p_lvds->fp_height = p_ctx->fp_height;
 
@@ -579,7 +773,17 @@ int ch7036_get_timing_list(void *p_context, pd_timing_t *p_in_list,
 
 	}
 
-	PD_ERROR("ch7036: ch7036_get_timing_list()- return ret=%X;\n", ret);
+
+
+	if ( !p_ctx->init_done) {
+		PD_DEBUG("ch7036: ch7036_get_timing_list()-init is not done- inquire port status...\n");
+		ch7036_get_port_status((void *)p_ctx, &port_status);
+
+	}
+
+
+	ch7036_parse_edid(p_ctx);
+
 	return ret;
 
 }
@@ -590,15 +794,11 @@ int ch7036_get_attributes(void *p_context, unsigned long *p_num_attr,
 	pd_attr_t **pp_list)
 {
 	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-	/*int ret;*/
+
+
 
 	PD_DEBUG("ch7036: ch7036_get_attributes()-enter\n");
 
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NULL_PTR);
-	}
 
 
 	if (!p_ctx || !p_num_attr || !pp_list) {
@@ -626,38 +826,33 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 
 	pd_port_status_t port_status;
 
-
 	pd_attr_t        *p_curr, *p_attr;
 	int ret;
-	unsigned long i;
+	unsigned long i,temp=0;
+	uint32 temp_chan;
+	ch7036_status_t status;
 
-	PD_DEBUG("ch7036: ch7036_set_attributes()-enter: num_attrs=%u\n", num_attrs);
 
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NULL_PTR);
-	}
+	PD_DEBUG("ch7036: ch7036_set_attributes()-enter: num_attrs=%u\n", num_attrs);
 
 
-	ret = PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(ch7036_set_attrs, (p_ctx->internal_lvds,num_attrs,p_list));
+	ret = PD_INTERNAL_LVDS_MODULE_SET_ATTRIBUTES(ch7036_lvds_set_attrs, (p_ctx->internal_lvds,num_attrs,p_list));
 
 
 
 	if(ret != PD_SUCCESS)
 		return ret;
 
-
-
-	#ifdef LVDS_ONLY
+#ifdef LVDS_ONLY
 		return PD_SUCCESS;
-	#endif
+#endif
 
 
 	if (!p_ctx->init_done) {
 
 		PD_DEBUG("ch7036: ch7036_set_attributes()- at bootup...\n");
 
-		PD_DEBUG("ch7036: ch7036_set_attributes()- p_ctx->hpd [%x}\n", p_ctx->hpd);
+		PD_DEBUG("ch7036: ch7036_set_attributes()- p_ctx->hpd [%x]\n", p_ctx->hpd);
 
 		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_DISPLAY, 0);
 		if (p_attr && (p_attr->flags & PD_ATTR_FLAG_VALUE_CHANGED) ) {
@@ -667,8 +862,8 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 				PD_GET_ATTR_LIST)->current_value
 			= p_attr->current_value;
 
-		}
 
+		}
 
 
 		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_HDMI_OUT_MODE, 0);
@@ -705,6 +900,8 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 		}
 
 
+
+
 		p_attr = pd_get_attr(p_list, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
 		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, num_attrs, PD_ATTR_ID_CRT_OUT_MODE, 0);
 
@@ -742,33 +939,26 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 			continue;
 
 
-
-		if (p_attr->name == NULL)
-		{
-			continue;
-		}
-		if ((p_attr->id != PD_ATTR_ID_DISPLAY)
-			&& (p_attr->id != PD_ATTR_ID_HDMI_OUT_MODE)
-			&& (p_attr->id != PD_ATTR_ID_DVI_OUT_MODE)
-			&& (p_attr->id != PD_ATTR_ID_CRT_OUT_MODE)
-			&& (p_attr->id != PD_ATTR_ID_HPOSITION)
-			&& (p_attr->id != PD_ATTR_ID_VPOSITION)
-
-			&& (p_attr->id != PD_ATTR_ID_HSCALE)
-			&& (p_attr->id !=  PD_ATTR_ID_VSCALE)
-			&& (p_attr->id !=  PD_ATTR_ID_HSCALE_CRT)
-			&& (p_attr->id !=  PD_ATTR_ID_VSCALE_CRT)
-			&& (p_attr->id !=  PD_ATTR_ID_DITHER_BYPASS)
-			&& (p_attr->id !=  PD_ATTR_ID_LOAD_FIRMWARE)
-			&& (p_attr->id !=  PD_ATTR_ID_REFRESH))
-		{
+		if( (p_attr->id == 0x1A) || (p_attr->id == 0x1B) ||
+			(p_attr->id == 0x3C) || (p_attr->id == 0x46) ||
+			(p_attr->id == 0x47) )
 			continue;
-		}
+
+#if 0
 
 		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
 				PD_GET_ATTR_LIST);
+#endif
+
+
+		p_curr = pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,p_attr->id,
+				0);
+		PD_DEBUG("ch7036_set_attributes(): attribute changed is of type [%ld] name [%s] id [%ld]\n",p_attr->type, p_attr->name, p_attr->id);
+
+		PD_DEBUG("ch7036_set_attributes():current value [%ld] requested value [%ld]\n",p_curr->current_value, p_attr->current_value);
 
 
+		temp = p_curr->current_value;
 		p_curr->current_value = p_attr->current_value;
 		switch (p_attr->id) {
 			case PD_ATTR_ID_DISPLAY:
@@ -776,24 +966,117 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 				list_item = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs,PD_ATTR_ID_DISPLAY,
 							PD_GET_ATTR_LIST_ENTRY);
 
-				if(list_item->value & CHANNEL_DVI) {
+				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+
+				if(list_item->value == CHANNEL_AUTO_DETECT) {
+					p_ctx->man_sel_out = 0;
+
+					if(p_ctx->init_done) {
+						p_ctx->hpd |= CH7036HPD_RESERVED1; //force port status inquiry
+						ch7036_get_port_status((void *)p_ctx, &port_status);
 
-					pOutput_Info->hdmi_fmt.is_dvi_mode=1;
-					list_item->value = (list_item->value & 0xF7) | CHANNEL_HDMI;
+					}
+					break;
 				}
+				//end of CHANNEL_AUTO_DETECT, manual selection of display output begins
+
 
+				p_ctx->man_sel_out = 1;
 
-				ch7036_set_output_channel(p_ctx,(uint32)list_item->value);
+				//1- save a copy
+				temp_chan = p_ctx->prev_outchannel;
+				p_ctx->prev_outchannel = pOutput_Info->channel;
 
-				if (pOutput_Info->channel == CHANNEL_LVDS)
+				PD_DEBUG("ch7036_set_attributes():current list item value [0x%x]\n",list_item->value);
 
+				//2- get requested output channel- assume it's allowed
 
-					ch7036_set_power((void *)p_ctx,PD_POWER_MODE_D0);
+				if(list_item->value & CHANNEL_DVI) {
+					pOutput_Info->channel = (list_item->value & 0x01) | CHANNEL_HDMI;
+				}
 				else
-					p_attr->flags |= PD_ATTR_FLAG_SETMODE;
+					pOutput_Info->channel = list_item->value;
+
+				PD_DEBUG("ch7036_set_attributes():current output channel value [0x%x]\n",pOutput_Info->channel);
+
+				//3- check requested selection vs what is available
+				status = ch7036_get_attached_device(p_ctx); //manual mode- verify its selection and correct if needed
+
+				//4- NOT allowed display choice- also include when none is connected
+				if( status == SS_DISPLAY_CHOICE_NOT_ALLOWED) {  //restore previous states
+					PD_DEBUG("ch7036_set_attributes(): display choice is not allowed- restore prev. states...\n");
+
+					p_ctx->hpd &= 0xEF;	 //reset
+
+					if(p_ctx->init_done){
+						pOutput_Info->channel = p_ctx->prev_outchannel;
+						p_ctx->prev_outchannel = temp_chan;
+						p_curr->current_value = temp;
+						//when system is restarted right after this point, need to provide main driver w/ a valid
+						//restored choice
+						p_attr->current_value = p_curr->current_value;
+						if(p_curr->current_value==1)
+							p_ctx->man_sel_out = 0;
+
+					}
+					else { //at installation, when init is not done, if manual choice is not valid, revert to auto
+
+						p_curr->current_value = 1;
+						p_ctx->man_sel_out = 0;
+
+						if (pOutput_Info->channel & CHANNEL_HDMI) //DVI mapped to CHANNEL_HDMI
+						{
+							pOutput_Info->channel = (pOutput_Info->channel & 0x01) | CHANNEL_VGA;
+							p_ctx->prev_outchannel = pOutput_Info->channel;
+
+						}
+						else { //VGA
+							pOutput_Info->channel = (pOutput_Info->channel & 0x01) | CHANNEL_HDMI;
+							p_ctx->prev_outchannel = pOutput_Info->channel;
+						}
+
+
+					}
 
+					PD_DEBUG("ch7036_set_attributes(): p_curr->current_value is: [%x]\n",p_curr->current_value);
+					if(p_ctx->hpd == 0x50) {//none is attached
+						pOutput_Info->channel &= CHANNEL_LVDS;
+						p_ctx->prev_outchannel = pOutput_Info->channel;
+					}
 
 
+				}
+				PD_DEBUG("ch7036_set_attributes(): now- output display channel is: value [%ld]\n",pOutput_Info->channel);
+
+
+				//special case channel CHANNEL_xxx_HDMI:
+				//incoming dvi format => convert to hdmi format- or- incoming hdmi format => convert to dvi format
+				if( ( (pOutput_Info->hdmi_fmt.is_dvi_mode==1) && ((list_item->value & 0x02) == CHANNEL_HDMI) ) ||
+					( (pOutput_Info->hdmi_fmt.is_dvi_mode==0) && ((list_item->value & 0x08) == CHANNEL_DVI) )
+					)
+					p_ctx->hpd |= 0x40; //request edid read again to update hdmi/dvi format accordingly
+
+
+				//base on 'new' attached info, read edid and set proper display output channel, including DVI
+				//case: manual selection w/ hpd change
+				if(p_ctx->hpd & 0x44) 	{
+					ch7036_alter_display_channel(p_ctx);
+				}
+
+				if( (pOutput_Info->channel & 0x04) == CHANNEL_VGA || p_curr->current_value==1  /* Coerced Auto Detect */ )
+					break;
+
+				//case:
+				//channel CHANNEL_xxx_HDMI- update list item xxx_DVI or xxx_HDMI accordingly
+				if((pOutput_Info->channel & CHANNEL_HDMI) && (pOutput_Info->hdmi_fmt.is_dvi_mode==1) )
+					p_curr->current_value = (pOutput_Info->channel & 0x01) == CHANNEL_LVDS?3:6;//lvds-dvi:dvi
+
+				else
+					if((pOutput_Info->channel & CHANNEL_HDMI) && (pOutput_Info->hdmi_fmt.is_dvi_mode==0) )
+						p_curr->current_value = (pOutput_Info->channel & 0x01) == CHANNEL_LVDS?2:5;//lvds-hdmi:hdmi
+
+				PD_DEBUG("ch7036_set_attributes(): after alter channel- output display channel is: value [%ld]\n",pOutput_Info->channel);
+
 				break;
 
 			case PD_ATTR_ID_HDMI_OUT_MODE:
@@ -820,23 +1103,30 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
 				break;
 
-			case PD_ATTR_ID_HPOSITION:
+			case PD_ATTR_ID_HPOSITION: //these attributes are for vga only
 			case PD_ATTR_ID_VPOSITION:
-				if(pOutput_Info->channel & CHANNEL_HDMI)
-					p_curr->current_value = DEFAULT_POSITION;
-				else {
-					if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
-						p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
-					else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
-						p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
-				}
+
+				PD_DEBUG("ch7036_set_attributes(): set vga h/v position...\n");
+
+				//save vga h/v attribute context
+				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+
+
+				if( pOutput_Info->channel & CHANNEL_HDMI)
+					break;
 
 				if (p_attr->id == PD_ATTR_ID_HPOSITION)
 					pOutput_Info->h_position = (uint16)(p_curr->current_value);
 				else
 					pOutput_Info->v_position = (uint16)(p_curr->current_value);
-				PD_DEBUG("ch7036_set_attributes(): updated position is: value [%d]\n",p_curr->current_value);
+
 				ch7036_set_position(p_ctx, (uint8)p_attr->id, (uint16)(p_curr->current_value));
+
+				PD_DEBUG("ch7036_set_attributes(): updated and set vga position: value [%d]\n",p_curr->current_value);
+
 				break;
 			case PD_ATTR_ID_HSCALE:
 			case PD_ATTR_ID_VSCALE:
@@ -853,7 +1143,7 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, (uint8)p_curr->current_value);
 				else
 					ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, (uint8)p_curr->current_value);
-				PD_DEBUG("ch7036_set_attributes(): updated scale value is: value [%ld]\n",p_curr->current_value);
+				PD_DEBUG("ch7036_set_attributes(): updated scale value is: value [%lu]\n",p_curr->current_value);
 
 				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
 
@@ -861,103 +1151,129 @@ int ch7036_set_attributes(void *p_context, unsigned long num_attrs,
 			case PD_ATTR_ID_DITHER_BYPASS:
 
 
-				PD_DEBUG("ch7036_set_attributes(): updated quality enhance value is: value [%ld]\n",p_curr->current_value);
+				PD_DEBUG("ch7036_set_attributes(): updated quality enhance value is: value [%lu]\n",p_curr->current_value);
 				ch7036_set_quality_enhancement(p_ctx,(uint8)p_curr->current_value);
 				break;
 
+			case PD_ATTR_ID_DITHER:
+				p_ctx->dither_select = (uint8)p_curr->current_value;
+				PD_DEBUG("ch7036_set_attributes(): updated dither select value is: value [%lu]\n",p_curr->current_value);
+				ch7036_set_dither(p_ctx);
+
+				break;
+
+			case PD_ATTR_ID_TEXT_FILTER:
+
+				if(p_curr->current_value > ((pd_range_attr_t *)p_curr)->max)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->max;
+				else if (p_curr->current_value < ((pd_range_attr_t *)p_curr)->min)
+					p_curr->current_value = ((pd_range_attr_t *)p_curr)->min;
+
+				PD_DEBUG("ch7036_set_attributes(): update text tuning value...\n");
+				ch7036_set_text_enhancement (p_ctx, (uint8) p_curr->current_value);
+
+				break;
+
 			case PD_ATTR_ID_LOAD_FIRMWARE:
-				PD_DEBUG("ch7036_set_attributes(): updated [load-firmware] value is: value [%ld]\n",p_curr->current_value);
-#if 0
-				if(p_curr->current_value)
-					p_ctx->use_firmware =1;
-				else
-					p_ctx->use_firmware =0;
-#endif
+				PD_DEBUG("ch7036_set_attributes(): updated [reload-firmware] value is: value [%lu]\n",p_curr->current_value);
+
+				break;
+
+			case PD_ATTR_ID_DWNSCAL_BYPASS:
+				PD_DEBUG("ch7036_set_attributes(): updated [dwnscal_bypass] value is: value [%lu]\n",p_curr->current_value);
+				if(p_curr->current_value ) {
+					p_ctx->dwnscal_bypass = 1;
+					p_ctx->downscaled[MODE_8x6_7x4_BYPASS]=1;
+				}
+				else {
+					p_ctx->dwnscal_bypass = 0;
+					p_ctx->downscaled[MODE_8x6_7x4_BYPASS]=0;
+				}
+
 				break;
 
 			case PD_ATTR_ID_REFRESH:
-				PD_DEBUG("ch7036_set_attributes(): refresh value is: value [%ld]\n",p_curr->current_value);
+				PD_DEBUG("ch7036_set_attributes(): refresh value is: value [%lu]\n",p_curr->current_value);
 
-				ch7036_get_port_status((void *)p_ctx, &port_status);
-				p_attr->flags |= PD_ATTR_FLAG_SETMODE;
-				if(p_curr->current_value ) {
-					p_curr->current_value= 0;
+				if(p_curr->current_value )
+						p_curr->current_value= 0;
+
+				if(p_ctx->init_done && !p_ctx->man_sel_out ) {
+
+						p_ctx->hpd |= CH7036HPD_RESERVED1; //force port status inquiry- edid read bit
+
+						ch7036_get_port_status((void *)p_ctx, &port_status);
+
+						p_attr->flags |= PD_ATTR_FLAG_SETMODE;
 
 				}
 				break;
 
 			default:
 
-				PD_DEBUG("ch7036_set_attr(): unhandled attr name[%s]id[%ld]curr_index[%ld]\n",p_attr->name, p_attr->id,p_attr->current_value);
+				PD_DEBUG("ch7036_set_attr(): unhandled attr name[%s]id[%ld]curr_index[%lu]\n",p_attr->name, p_attr->id,p_attr->current_value);
 				break;
 
 		}
 
-
 	}
 
+	PD_DEBUG("ch7036: ch7036_set_attributes()-p_ctx->man_sel_out at exit [0x%x]\n",p_ctx->man_sel_out);
 
+	PD_DEBUG("ch7036: ch7036_set_attributes()-p_ctx->hpd at exit [0x%x]\n",p_ctx->hpd);
 
 	PD_DEBUG("ch7036: ch7036_set_attributes()-exit\n");
 
 	return ret;
 }
 
-
-
-
 int ch7036_set_power(void *p_context, unsigned long state)
 {
 	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
 	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
 
 
-	pd_list_entry_attr_t  *list_entry;
 	int ret;
 
 
 	PD_DEBUG("ch7036: ch7036_set_power()-enter: requested state=%x\n", state);
 
+#ifdef LVDS_ONLY
+	return	PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_set_power, (p_ctx->internal_lvds,state));
+#endif
+
 	if (!p_ctx)
 		return PD_ERR_NULL_PTR;
 
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NULL_PTR);
-	}
-
 	if (state > PD_POWER_MODE_D3)
 		return PD_ERR_INVALID_POWER;
 
 	if (state != PD_POWER_MODE_D0) {
 
-
+		if(pOutput_Info->channel != CHANNEL_LVDS_HDMI_VGA_OFF)
+			p_ctx->prev_outchannel = pOutput_Info->channel; //store current output channel before temporarily powered down
 		pOutput_Info->channel = CHANNEL_LVDS_HDMI_VGA_OFF;
 
-		#ifndef LVDS_ONLY
-		ch7036_device_set_power(p_ctx,CHANNEL_LVDS_HDMI_VGA_OFF);
-		#endif
 
-		ret = PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_internal_lvds_set_power, (p_ctx->internal_lvds,state));
+		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
+
+		ret = PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_lvds_set_power, (p_ctx->internal_lvds,state));
 
 
 	}
 	else {
 
 
-		list_entry = (pd_list_entry_attr_t *)pd_get_attr(p_ctx->p_ch7036_attr_table, p_ctx->ch7036_num_attrs, PD_ATTR_ID_DISPLAY, PD_GET_ATTR_LIST_ENTRY);
-		ch7036_set_output_channel(p_ctx,(uint32)(list_entry->value));
+		ch7036_set_output_channel(p_ctx,p_ctx->prev_outchannel); //restore previous output channel
 
 		PD_DEBUG("ch7036: ch7036_set_power()- p->ctx-hpd [0x%x]\n",p_ctx->hpd);
 		PD_DEBUG("ch7036: ch7036_set_power()- requested output channel- [%x]\n", pOutput_Info->channel);
 
 
-		PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_internal_lvds_set_power, (p_ctx->internal_lvds,state));
+		PD_INTERNAL_LVDS_MODULE_SET_POWER(ch7036_lvds_set_power, (p_ctx->internal_lvds,state));
 
-		#ifndef LVDS_ONLY
 		ch7036_device_set_power(p_ctx,pOutput_Info->channel);
-		#endif
+
 	}
 
 
@@ -974,6 +1290,9 @@ int ch7036_get_power(void *p_context, unsigned long *p_state)
 
 	PD_DEBUG("ch7036: ch7036_get_power()\n");
 
+#ifdef LVDS_ONLY
+	return PD_INTERNAL_LVDS_MODULE_GET_POWER(ch7036_get_power, (p_ctx->internal_lvds,p_state));
+#endif
 
 	*p_state = p_ctx->pwr_state;
 
@@ -982,32 +1301,44 @@ int ch7036_get_power(void *p_context, unsigned long *p_state)
 
 int ch7036_save(void *p_context, void **state, unsigned long flags)
 {
-
 	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
-
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
 
 	PD_DEBUG("ch7036: ch7036_save()\n");
 
+#ifdef LVDS_ONLY
 
-	p_ctx->prev_outchannel = ch7036_get_output_channel(p_context);
+	return PD_INTERNAL_LVDS_MODULE_SAVE(ch7036_save,(p_ctx->internal_lvds, state, flags));
+#endif
 
+	//in Linux, when being called @ init, it incorrectly assigned unintialized global attribute value to prev outchannel
+	//p_ctx->prev_outchannel = ch7036_get_output_channel(p_context);
+	//fixed
+	p_ctx->prev_outchannel = pOutput_Info->channel;
 
 
 	*state = NULL;
 
 	return PD_SUCCESS;
-
 }
 
+
+
 int ch7036_restore(void *p_context, void *state, unsigned long flags)
 {
-
 	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)p_context;
+
 	unsigned long i;
 
 
+
 	PD_DEBUG("ch7036: ch7036_restore()\n");
 
+#ifdef LVDS_ONLY
+
+	return PD_INTERNAL_LVDS_MODULE_RESTORE(ch7036_restore,(p_ctx->internal_lvds, state, flags));
+#endif
+
 
 	if (ch7036_load_firmware(p_ctx) != SS_SUCCESS)   {
 		PD_DEBUG("ch7036: ch7036_restore()-  load fw is NOT a SUCCESS\n");
@@ -1019,15 +1350,15 @@ int ch7036_restore(void *p_context, void *state, unsigned long flags)
 	}
 
 
+
 	if(p_ctx->prev_outchannel == CHANNEL_LVDS_HDMI) {
 
 		ch7036_set_output_channel(p_context, p_ctx->prev_outchannel);
-		ch7036_set_mode(p_context, p_ctx->native_dtd, 0);
-		ch7036_post_set_mode(p_context, p_ctx->native_dtd, 0);
+		ch7036_set_mode(p_context, &(p_ctx->native_dtd), 0);
+		ch7036_post_set_mode(p_context, &(p_ctx->native_dtd), 0);
 	}
 
 
-
 	for(i=0;i<p_ctx->ch7036_num_attrs;i++) {
 
 		if( p_ctx->p_ch7036_attr_table[i].id == PD_ATTR_ID_REFRESH ) {
@@ -1051,45 +1382,75 @@ int ch7036_restore(void *p_context, void *state, unsigned long flags)
 int ch7036_get_port_status(void *context, pd_port_status_t *port_status)
 {
 	ch7036_device_context_t *p_ctx = (ch7036_device_context_t *)context;
-//	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
-//	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
-
+	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
 
+#if 0
+	FW7036_CFG* fv = (FW7036_CFG*) p_ctx->fw;
+	int ret;
+#endif
 
 	port_status->display_type = PD_DISPLAY_LVDS_INT;
 	port_status->connected    = PD_DISP_STATUS_UNKNOWN;
 
-	PD_DEBUG("ch7036: ch7036_get_port_status()-enter..\n");
 
+	PD_DEBUG("ch7036: ch7036_get_port_status()-enter... p_ctx->hpd [%x]\n", p_ctx->hpd);
 
-	if(p_ctx->use_firmware) {
+#if 0
+	PD_DEBUG("Get LHFM Version Information.\r\n");
+	ret = LHFM_get_version(p_ch7xxx_context, fv);
+	if (0==ret) {
+		PD_DEBUG("Ma_ver=%d, mi_ver=%d, did=%02X, rid= %02X, capability=%s\r\n",
+			fv->ver_major, fv->ver_minor, fv->did, fv->rid, (fv->capbility & 0x2) ? "EDID+HDCP" : "EDID");
+	}
+	else {
+		PD_DEBUG("--- failed!\r\n");
+		PD_DEBUG("status: [%s]\n",ret ==-1?"timeout!":"firmware_error!");
+	}
+#endif
 
-		ch7036_get_attached_device(p_ctx);
 
-		if(p_ctx ->hpd & 0x22)
-			port_status->connected = PD_DISP_STATUS_ATTACHED;
+#ifdef LVDS_ONLY
 
+	return PD_INTERNAL_LVDS_MODULE_GET_PORT_STATUS(ch7036_get_port_status,(p_ctx->internal_lvds, port_status));
+#endif
 
-		ch7036_alter_display_list(p_ctx);
+	if(! (p_ctx->hpd & CH7036HPD_RESERVED1) ) {
+		//note: main driver check port status several times, this block is to speed things up a little
+		if ((p_ctx->init_done) && (pOutput_Info->channel == p_ctx->prev_outchannel ) ) {
+			if(p_ctx ->hpd & 0x22)
+				port_status->connected = PD_DISP_STATUS_ATTACHED;
+			PD_DEBUG("ch7036: ch7036_get_port_status()-output channel UNCHANGED- exit. p_ctx->hpd [%x]\n", p_ctx->hpd);
+			return PD_SUCCESS;
+		}
 
 	}
 
+	if(p_ctx->use_firmware) {
+
+		ch7036_get_attached_device(p_ctx);
+		if(p_ctx ->hpd & 0x22)
+			port_status->connected = PD_DISP_STATUS_ATTACHED;
+
+		ch7036_alter_display_channel(p_ctx);
+
+		}
 
-	PD_DEBUG("ch7036: ch7036_get_port_status()-exit. p_ctx->hpd [%x}\n", p_ctx->hpd);
 
+	p_ctx->hpd &= 0xEE;
 
+	PD_DEBUG("ch7036: ch7036_get_port_status()-exit. p_ctx->hpd [%x]\n", p_ctx->hpd);
 	return PD_SUCCESS;
-
 }
 
 
+
+
 int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
 {
 	DEV_CONTEXT* p_ch7xxx_context = p_ctx->p_ch7xxx_context;
 	OUTPUT_INFO* pOutput_Info = (p_ctx->p_ch7xxx_context)->pOutput_Info;
 	PREFER_INFO* pPrefer_Info = p_ch7xxx_context->pPrefer_Info;
-	//pd_attr_t *p_attr;
-	uint8 reg;
+	uint8 reg; //,i=0;
 
 	ch7036_edid_blk_t* p_hedid;
 	ch7036_edid_blk_t* p_cedid ;
@@ -1098,49 +1459,38 @@ int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
 	PD_DEBUG("ch7036: ch7036_initialize_device()- ENTER...\n");
 
 
-	if (p_ch7xxx_context->DeviceID != 0x56)
-	{
-		return (PD_ERR_NULL_PTR);
-	}
 	p_ctx->init_done = 0;
+	p_ctx->hpd = 0;
 
+	p_ctx->downscaled[MODE_6x4_BYPASS] = 1;
+	p_ctx->downscaled[MODE_8x6_7x4_BYPASS] = 1;
+	p_ctx->dwnscal_bypass = 1;
+
+	if(p_ctx->use_firmware) {
 
-	if(p_ctx->hedid) {
 		p_hedid = (ch7036_edid_blk_t *)p_ctx->hedid;
 		p_cedid = (ch7036_edid_blk_t *)p_ctx->cedid;
 
-		p_cedid->is_edid = 0;
-		p_hedid->is_edid = 0;
-		p_cedid->ebn = 0;
-		p_hedid->ebn = 0;
-
-	}
-
-
-
-	pOutput_Info->hdmi_fmt.is_dvi_mode = 0;
-
-	pOutput_Info->channel = CHANNEL_LVDS | CHANNEL_HDMI;
-	p_ctx->req_ddc = 0;
-	p_ctx->lvds_only = 0;
 
-	PD_DEBUG("ch7036: ch7036_initialize_device()- set output channel to [%ld]\n",pOutput_Info->channel);
 
+		pd_memcpy(p_cedid->etiming_I,et_I,8* sizeof(established_timings_t));
+		pd_memcpy(p_cedid->etiming_II,et_II,8* sizeof(established_timings_t));
 
 
-	pOutput_Info->h_position = DEFAULT_POSITION;
-	pOutput_Info->v_position = DEFAULT_POSITION;
+		p_cedid->etiming_man = &et_man;
 
 
-	p_ctx->dither_select = DITHER_18_TO_18;
 
-	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, HDMI_DEFAULT_UNDERSCAN);
-	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, HDMI_DEFAULT_UNDERSCAN);
+		pd_memcpy(p_hedid->etiming_I,et_I,8* sizeof(established_timings_t));
+		pd_memcpy(p_hedid->etiming_II,et_II,8* sizeof(established_timings_t));
 
-	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
+		p_hedid->etiming_man = &et_man;
 
 
-	if(p_ctx->use_firmware) {
+		p_cedid->is_edid = 0;
+		p_hedid->is_edid = 0;
+		p_cedid->ebn = 0;
+		p_hedid->ebn = 0;
 
 
 		I2CWrite(p_ch7xxx_context,0x03, 0x04);
@@ -1149,16 +1499,48 @@ int ch7036_initialize_device(ch7036_device_context_t *p_ctx)
 		I2CWrite(p_ch7xxx_context,0x52, reg);
 
 
+		I2CWrite(p_ch7xxx_context,0x03, 0x0);
+		reg = I2CRead(p_ch7xxx_context,0x07);
+		reg = reg & 0x70;
+		I2CWrite(p_ch7xxx_context,0x07, reg);
+
+		I2CWrite(p_ch7xxx_context,0x4E, I2CRead(p_ch7xxx_context,0x4E) & 0x7F);
+
 		I2CWrite(p_ch7xxx_context,0x03, 0x01);
 		reg = I2CRead(p_ch7xxx_context,0x0F);
 		reg = reg & 0x7F;
 		I2CWrite(p_ch7xxx_context,0x0F, reg);
 
+		I2CWrite(p_ch7xxx_context,0x03, 0x03);
+		reg = I2CRead(p_ch7xxx_context,0x6E);
+		reg = reg & 0xBF;
+		I2CWrite(p_ch7xxx_context,0x6E, reg | 0x40);
 
-		ch7036_get_attached_device(p_ctx);
 
 	}
 
 
+	pOutput_Info->hdmi_fmt.is_dvi_mode = 0;
+
+	pOutput_Info->channel = CHANNEL_LVDS | CHANNEL_HDMI;
+
+
+
+	PD_DEBUG("ch7036: ch7036_initialize_device()- default output channel is [%u]\n",pOutput_Info->channel);
+
+
+
+	pOutput_Info->h_position = DEFAULT_POSITION;
+	pOutput_Info->v_position = DEFAULT_POSITION;
+
+
+	p_ctx->dither_select = DITHER_18_TO_18;
+	p_ctx->man_sel_out= 0;
+
+	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_HSCALE, HDMI_DEFAULT_UNDERSCAN);
+	ch7036_set_scaling (pOutput_Info,PD_ATTR_ID_VSCALE, HDMI_DEFAULT_UNDERSCAN);
+
+	ch7036_set_prefer_timing_info(p_ctx,pPrefer_Info);
+
 	return PD_SUCCESS;
 }
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.h
index 78e33d3..64ea9a5 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_port.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_port.h
-* @version 1.1.4
+* @version 1.2.2
 *-----------------------------------------------------------------------------
 */
 
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.c b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.c
index 80993a5..62d5a36 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.c
@@ -21,200 +21,202 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_reg_table.c
-* @version 1.1.4
+* @version 1.2.2
 *-----------------------------------------------------------------------------
 */
 
 
+
 #include "ch7036_reg_table.h"
 
 
 
+
 MULTI_REG g_MultiRegTable[MUL_ID_END] =
 {
-	{BASE_FLAG,       -1,  0, 0,	-1,  0, 0,	-1,  3, 6,	-1,   0, 7,		0},
-
-	{HTI,		      -1,  0, 0,	-1,  0, 0,	0x0B,3, 6,	0x0D, 0, 7,		0},
-	{VTI,		      -1,  0, 0,	-1,  0, 0,	0x11,3, 5,	0x13, 0, 7,		0},
-	{HAI,		      -1,  0, 0,	-1,  0, 0,	0x0B,0, 2,	0x0C, 0, 7,		0},
-	{VAI,		      -1,  0, 0,	-1,  0, 0,	0x11,0, 2,	0x12, 0, 7,		0},
-	{HOI,		      -1,  0, 0,	-1,  0, 0,	0x0E,0, 2,	0x0F, 0, 7,		0},
-	{VOI,		      -1,  0, 0,	-1,  0, 0,	0x14,0, 2,	0x15, 0, 7,		0},
-	{HWI,		      -1,  0, 0,	-1,  0, 0,	0x0E,3, 5,	0x10, 0, 7,		0},
-	{VWI,		      -1,  0, 0,	-1,  0, 0,	0x14,3, 5,	0x16, 0, 7,		0},
-	{RCLK,            -1,  0, 0,	0x0F,0, 1,  0x14,0, 7,  0x15, 0, 7,     4},
-	{DITHER_SEL1_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x57, 7, 7,		4},
-	{DITHER_SEL0_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x57, 6, 6,		4},
-	{HSYNCP_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x41, 6, 6,		1},
-	{VSYNCP_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x41, 5, 5,		1},
-	{NP_INV0_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 4, 4,		4},
-	{NP_INV1_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 3, 3,		4},
-	{NP_INV2_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 2, 2,		4},
-	{NP_INV3_SPP,     -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 1, 1,		4},
-	{LVDS_IN_ORDER,	  -1,  0, 0,	-1,	 0, 0,  -1,  0, 0,  0x5F, 0, 0,		4},
-
-	{LVDS0_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5E, 5, 7,		4},
-	{LVDS1_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5E, 2, 4,		4},
-	{LVDS2_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,	 0, 0,  0x5F, 7, 7,		4},
-	{LVDS3_SEQ_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5F, 4, 6,		4},
-	{LVDSCLK_SEQ_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5F, 1, 3,		4},
-	{HSYNC_CNT_TH_SPP,-1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 5, 6,		4},
-	{PRBS_SET_SEL_SPP,-1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 1, 1,		4},
-	{LVDS0_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 4, 4,		4},
-    {LVDS1_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 3, 3,		4},
-	{LVDS2_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 2, 2,		4},
-	{LVDS3_POL_SPP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 1, 1,		4},
-	{LVDSCLK_POL_SPP, -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x59, 0, 0,		4},
-
-	{HTO,			  -1,  0, 0,	-1,  0, 0,	0x1F,3, 6,	0x21, 0, 7,		0},
-	{VTO,			  -1,  0, 0,	-1,  0, 0,	0x25,3, 5,	0x27, 0, 7,		0},
-	{HAO,			  -1,  0, 0,	-1,  0, 0,	0x1F,0, 2,	0x20, 0, 7,		0},
-	{VAO,			  -1,  0, 0,	-1,  0, 0,	0x25,0, 2,	0x26, 0, 7,		0},
-	{HOO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x54,0, 2,	0x55, 0, 7,		0},
-	{VOO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x57,0, 2,	0x58, 0, 7,		0},
-	{HWO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x54,3, 5,	0x56, 0, 7,		0},
-	{VWO_HDMI,	      -1,  0, 0,	-1,  0, 0,	0x57,3, 5,	0x59, 0, 7,		0},
-	{HPO_I,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 5, 5,		0},
-	{VPO_I,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 4, 4,		0},
-	{DEPO_I,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 3, 3,		0},
-	{HPO_O,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 4, 4,		0},
-	{VPO_O,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 3, 3,		0},
-	{DEPO_O,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 5, 5,		0},
-
-	{HD_DVIB,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 2, 2,		0},
-	{INTLC,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 5, 5,		0},
-	{HD_LV_POL,       -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4C, 5, 5,		0},
-	{HD_LV_SEQ,       -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4C, 0, 4,		0},
-	{HDMI_LVDS_SEL,   -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x7E, 7, 7,		0},
-	{VSP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x24, 5, 5,		1},
-	{HSP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x24, 4, 4,		1},
-	{HDMIIN_HSP,	  -1,  0, 0,    -1,  0, 0,	-1,  0, 0,	0x61, 6, 6,		4},
-	{HDMIIN_VSP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 5, 5,		4},
-	{HDMIIN_DEP,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 4, 4,		4},
-	{M1M0,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x3D, 2, 3,		0},
-	{C1C0,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x3D, 0, 1,		0},
-	{VIC,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x40, 0, 5,		0},
-	{COPY,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4B, 6, 6,		0},
-	{SCAN_EN,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6C, 0, 0,		4},
-	{HAO_SCL,		  -1,  0, 0,	-1,  0, 0,	0x6A,0, 7,	0x6B, 5, 7,		4},
-	{VAO_SCL,		  -1,  0, 0,	-1,  0, 0,	0x6B,0, 4,	0x6C, 2, 7,		4},
-
-	{I2SPOL,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 7, 7,		0},
-	{I2S_SPDIFB,      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 6, 6,		0},
-	{I2S_LENGTH,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 2, 3,		0},
-	{I2SFMT,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1E, 0, 1,		0},
-	{UCLK,            -1,  0, 0,	0x0F,4, 5,  0x10,0, 7,  0x11, 0, 7 ,    4},
-
-	{PCLK_NUM,		  -1,  0, 0,	-1,  0, 0,	0x28,  0, 7,0x29, 0, 7,		1},
-
-	{UCLKSEC,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x12, 4, 4,		1},
-	{PLL1N1,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x55, 3, 5,		4},
-	{PLL1N2,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x55, 0, 2,		4},
-	{PLL1N3,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x56, 5, 7,		4},
-	{PLL3N8,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x13, 1, 2,		1},
-	{A2,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5E, 0, 7,		0},
-	{MCLK,            -1,  0, 0,	0x0F,2, 3,  0x12,0, 7,  0x13, 0, 7,     4},
-	{PLL2N5,		  -1,  0, 0,	-1,  0, 0,  0x12,0, 1,	0x13, 7, 7,		1},
-	{PLL2N54,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 2, 2,		4},
-	{PLL2N53,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 1, 1,		4},
-	{PLL2N6,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x69, 5, 6,		4},
-	{PLL2N7,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x69, 3, 4,		4},
-	{DIVXTAL,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 3, 7,		4},
+	{BASE_FLAG,       NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  3, 6,	NOOP_INDEX,   0, 7,		0},
+
+	{HTI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0B,3, 6,	0x0D, 0, 7,		0},
+	{VTI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x11,3, 5,	0x13, 0, 7,		0},
+	{HAI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0B,0, 2,	0x0C, 0, 7,		0},
+	{VAI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x11,0, 2,	0x12, 0, 7,		0},
+	{HOI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0E,0, 2,	0x0F, 0, 7,		0},
+	{VOI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x14,0, 2,	0x15, 0, 7,		0},
+	{HWI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0E,3, 5,	0x10, 0, 7,		0},
+	{VWI,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x14,3, 5,	0x16, 0, 7,		0},
+	{RCLK,            NOOP_INDEX,  0, 0,	0x0F,0, 1,  0x14,0, 7,  0x15, 0, 7,     4},
+	{DITHER_SEL1_SPP, NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x57, 7, 7,		4},
+	{DITHER_SEL0_SPP, NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x57, 6, 6,		4},
+	{HSYNCP_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x41, 6, 6,		1},
+	{VSYNCP_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x41, 5, 5,		1},
+	{NP_INV0_SPP,     NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x58, 4, 4,		4},
+	{NP_INV1_SPP,     NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x58, 3, 3,		4},
+	{NP_INV2_SPP,     NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x58, 2, 2,		4},
+	{NP_INV3_SPP,     NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x58, 1, 1,		4},
+	{LVDS_IN_ORDER,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,	 0, 0,  NOOP_INDEX,  0, 0,  0x5F, 0, 0,		4},
+
+	{LVDS0_SEQ_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x5E, 5, 7,		4},
+	{LVDS1_SEQ_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x5E, 2, 4,		4},
+	{LVDS2_SEQ_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,	 0, 0,  0x5F, 7, 7,		4},
+	{LVDS3_SEQ_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x5F, 4, 6,		4},
+	{LVDSCLK_SEQ_SPP, NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x5F, 1, 3,		4},
+	{HSYNC_CNT_TH_SPP,NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x59, 5, 6,		4},
+	{PRBS_SET_SEL_SPP,NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x61, 1, 1,		4},
+	{LVDS0_POL_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x59, 4, 4,		4},
+    {LVDS1_POL_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x59, 3, 3,		4},
+	{LVDS2_POL_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x59, 2, 2,		4},
+	{LVDS3_POL_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x59, 1, 1,		4},
+	{LVDSCLK_POL_SPP, NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x59, 0, 0,		4},
+
+	{HTO,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1F,3, 6,	0x21, 0, 7,		0},
+	{VTO,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x25,3, 5,	0x27, 0, 7,		0},
+	{HAO,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1F,0, 2,	0x20, 0, 7,		0},
+	{VAO,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x25,0, 2,	0x26, 0, 7,		0},
+	{HOO_HDMI,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x54,0, 2,	0x55, 0, 7,		0},
+	{VOO_HDMI,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x57,0, 2,	0x58, 0, 7,		0},
+	{HWO_HDMI,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x54,3, 5,	0x56, 0, 7,		0},
+	{VWO_HDMI,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x57,3, 5,	0x59, 0, 7,		0},
+	{HPO_I,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x19, 5, 5,		0},
+	{VPO_I,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x19, 4, 4,		0},
+	{DEPO_I,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x19, 3, 3,		0},
+	{HPO_O,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E, 4, 4,		0},
+	{VPO_O,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E, 3, 3,		0},
+	{DEPO_O,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E, 5, 5,		0},
+
+	{HD_DVIB,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0A, 2, 2,		0},
+	{INTLC,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1E, 5, 5,		0},
+	{HD_LV_POL,       NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x4C, 5, 5,		0},
+	{HD_LV_SEQ,       NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x4C, 0, 4,		0},
+	{HDMI_LVDS_SEL,   NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x7E, 7, 7,		0},
+	{VSP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x24, 5, 5,		1},
+	{HSP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x24, 4, 4,		1},
+	{HDMIIN_HSP,	  NOOP_INDEX,  0, 0,    NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x61, 6, 6,		4},
+	{HDMIIN_VSP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x61, 5, 5,		4},
+	{HDMIIN_DEP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x61, 4, 4,		4},
+	{M1M0,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x3D, 2, 3,		0},
+	{C1C0,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x3D, 0, 1,		0},
+	{VIC,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x40, 0, 5,		0},
+	{COPY,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x4B, 6, 6,		0},
+	{SCAN_EN,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6C, 0, 0,		4},
+	{HAO_SCL,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6A,0, 7,	0x6B, 5, 7,		4},
+	{VAO_SCL,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6B,0, 4,	0x6C, 2, 7,		4},
+
+	{I2SPOL,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1E, 7, 7,		0},
+	{I2S_SPDIFB,      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1E, 6, 6,		0},
+	{I2S_LENGTH,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1E, 2, 3,		0},
+	{I2SFMT,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1E, 0, 1,		0},
+	{UCLK,            NOOP_INDEX,  0, 0,	0x0F,4, 5,  0x10,0, 7,  0x11, 0, 7 ,    4},
+
+	{PCLK_NUM,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x28,  0, 7,0x29, 0, 7,		1},
+
+	{UCLKSEC,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x12, 4, 4,		1},
+	{PLL1N1,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x55, 3, 5,		4},
+	{PLL1N2,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x55, 0, 2,		4},
+	{PLL1N3,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x56, 5, 7,		4},
+	{PLL3N8,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x13, 1, 2,		1},
+	{A2,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x5E, 0, 7,		0},
+	{MCLK,            NOOP_INDEX,  0, 0,	0x0F,2, 3,  0x12,0, 7,  0x13, 0, 7,     4},
+	{PLL2N5,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,  0x12,0, 1,	0x13, 7, 7,		1},
+	{PLL2N54,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6E, 2, 2,		4},
+	{PLL2N53,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6E, 1, 1,		4},
+	{PLL2N6,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x69, 5, 6,		4},
+	{PLL2N7,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x69, 3, 4,		4},
+	{DIVXTAL,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6E, 3, 7,		4},
 	{A1,			  0x5A,0, 7,	0x5B,0, 7,	0x5C,0, 7,	0x5D, 0, 7,		0},
-	{A3,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x60, 0, 7,		4},
-	{TXPLL_FFD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x67, 7, 7,		4},
-	{DRI_PLL_N1,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0C, 3, 4,		1},
-	{DRI_PLL_N3,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0C, 1, 2,		1},
-	{UCLKOD_SEL,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x61, 7, 7,		4},
-
-	{GCKSEL,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x54, 6, 6,		4},
-	{TSTEN1,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x14, 6, 6,		1},
-
-	{LNSEL,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x68, 1, 2,		0},
-	{DAT16_32B,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x74, 7, 7,		0},
-	{TRUE24,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x74, 3, 3,		0},
-	{TRUE_COM,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x74, 4, 4,		0},
-	{WRLEN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2D, 6, 7,		0},
-	{ROTATE,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2D, 4, 5,		0},
-	{HFLIP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 7, 7,		0},
-	{VFLIP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 6, 6,		0},
-	{DNSMPEN,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x25, 6, 6,		0},
-	{HADWSPP,	      -1,  0, 0,	-1,  0, 0,	0x60,0, 7,	0x61, 0, 2,		0},
-	{FLTBP2,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x32, 7, 7,		0},
-	{FLTBP1,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x32, 6, 6,		0},
-	{BLK_H,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x64, 0, 6,		0},
-	{FBA_INC,		  -1,  0, 0,	-1,  0, 0,	0x6B,0, 7,	0x6C, 0, 3,		0},
-	{SFM,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6A, 0, 0,		0},
-	{THREN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6A, 2, 2,		0},
-	{THRRL,			  -1,  0, 0,	-1,  0, 0,	0x6D,0, 7,	0x6E, 0, 2,		0},
-	{WRFAST,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x6E, 3, 3,		0},
-	{CHG_HL,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2F, 7, 7,		0},
-	{HINCA,			  -1,  0, 0,	-1,  0, 0,	0x2A,0, 7,	0x2B, 0, 2,		4},
-	{HINCB,			  -1,  0, 0,	-1,  0, 0,	0x2C,0, 7,	0x2D, 0, 2,		4},
-	{VINCA,			  -1,  0, 0,	-1,  0, 0,	0x2E,0, 7,	0x2F, 0, 2,		4},
-	{VINCB,			  -1,  0, 0,	-1,  0, 0,	0x30,0, 7,	0x31, 0, 2,		4},
-	{HDINCA,		  -1,  0, 0,	-1,  0, 0,	0x32,0, 7,	0x33, 0, 2,		4},
-	{HDINCB,		  -1,  0, 0,	-1,  0, 0,	0x34,0, 7,	0x35, 0, 2,		4},
-	{HINC,			  -1,  0, 0,	0x36,0, 4,	0x37,0, 7,	0x38, 0, 7,		4},
-	{VINC,			  -1,  0, 0,	0x39,0, 7,	0x3A,0, 7,  0x3B, 0, 7,		4},
-	{HDINC,		      -1,  0, 0,	0x3C,0, 7,	0x3D,0, 7,	0x3E, 0, 7,		4},
-	{VSMST,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x70, 6, 7,		0},
-	{MEMINIT,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 7, 7,		0},
-	{STOP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 4, 4,		0},
-
-	{HDMI_PD,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 0, 0,		0},
-	{I2S_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 6, 6,		0},
-	{SPDIF_PD,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 0, 0,		0},
-	{DRI_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 3, 3,		0},
-	{DRI_PD_SER,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x16, 0, 0,		1},
-	{DRI_PD_PLL,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x16, 3, 3,		1},
-	{DRI_PDDRI,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x08, 4, 7,		0},
-	{CEC_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 4, 4,		0},
-	{PD_DDC,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0E, 7, 7,		1},
-
-	{LVDS_PD,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 3, 3,		0},
-	{RX_PD,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x63, 4, 7,		4},
-	{RXPLL_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x64, 0, 0,		4},
-    {TXPLL_PD,		  -1,  0, 0,    -1,  0, 0,	-1,  0, 0,	0x66, 1, 1,		4},
-	{TXDRV_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x11, 4, 4,		1},
-	{TXSER_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x1A, 4, 4,		1},
-
-	{VGA_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 2, 2,		0},
-	{PDDAC,		      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x08, 1, 3,		0},
-	{DACSENCE,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x57, 1, 1,		4},
-	{GCKOFF,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 6, 6,		0},
-	{TV_BP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 5, 5,		0},
-	{PDPLL1,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 1, 1,		0},
-	{PDPLL0,	      -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x54, 4, 4,		4},
-
-	{ICEN0,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x11, 7, 7,		1},
-
-	{PD_PROM,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0F, 7, 7,		1},
-	{PDMIO,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 2, 2,		0},
-	{PDIO,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 5, 5,		0},
-	{HPD_PD,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 7, 7,		0},
-	{SCLPD,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 4, 4,		0},
-	{SDPD,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x09, 3, 3,		0},
-	{MEMPD,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x0A, 5, 5,		0},
-	{AUDDAC,          -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x5C, 2, 2,		4},
-
-	{CRYS_FREQ_SPP,	  -1,  0, 0,	-1,  0, 0,0x1C,	 0,	7,  0x1D, 0, 7,		0},
-	{I2SCK_SEC, 	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 2, 2,		1},
-	{SP_EN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x21, 7, 7,		1},
-	{HARD_SOFTB,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x58, 5, 5,		4},
-	{MULT_I2CEN,	  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x4E, 0, 0,		1},
-	{RXPLL_REFDLY,    -1,  0, 0,    -1,  0, 0,  -1,  0, 0,  0x66, 5, 7,     4},
-	{RXPLL_FBDLY,     -1,  0, 0,    -1,  0, 0,  -1,  0, 0,  0x66, 2, 4,     4},
-	{VFMT,            -1,  0, 0,    -1,  0, 0,  -1,  0, 0,  0x2B, 0, 3,     0},
-
-	{DBP,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x19, 6, 6,		0},
-	{CK_TVINV,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x07, 1, 1,		1},
-	{DISPON,		  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x08, 0, 0,		1},
-
-	{VP,			  -1,  0, 0,	-1,  0, 0,	0x39,4, 7,	0x3B, 0, 7,		0},
-	{HP,			  -1,  0, 0,	-1,  0, 0,	0x39,0, 3,	0x3A, 0, 7,		0},
-
-	{TXTEN,			  -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x2E, 0, 2,		0},
-	{ZRCTS,           -1,  0, 0,	-1,  0, 0,	-1,  0, 0,	0x24, 1, 1,		1},
+	{A3,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x60, 0, 7,		4},
+	{TXPLL_FFD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x67, 7, 7,		4},
+	{DRI_PLL_N1,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0C, 3, 4,		1},
+	{DRI_PLL_N3,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0C, 1, 2,		1},
+	{UCLKOD_SEL,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x61, 7, 7,		4},
+
+	{GCKSEL,          NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x54, 6, 6,		4},
+	{TSTEN1,          NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x14, 6, 6,		1},
+
+	{LNSEL,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x68, 1, 2,		0},
+	{DAT16_32B,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x74, 7, 7,		0},
+	{TRUE24,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x74, 3, 3,		0},
+	{TRUE_COM,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x74, 4, 4,		0},
+	{WRLEN,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2D, 6, 7,		0},
+	{ROTATE,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2D, 4, 5,		0},
+	{HFLIP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E, 7, 7,		0},
+	{VFLIP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E, 6, 6,		0},
+	{DNSMPEN,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x25, 6, 6,		0},
+	{HADWSPP,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x60,0, 7,	0x61, 0, 2,		0},
+	{FLTBP2,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x32, 7, 7,		0},
+	{FLTBP1,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x32, 6, 6,		0},
+	{BLK_H,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x64, 0, 6,		0},
+	{FBA_INC,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6B,0, 7,	0x6C, 0, 3,		0},
+	{SFM,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6A, 0, 0,		0},
+	{THREN,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6A, 2, 2,		0},
+	{THRRL,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6D,0, 7,	0x6E, 0, 2,		0},
+	{WRFAST,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x6E, 3, 3,		0},
+	{CHG_HL,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2F, 7, 7,		0},
+	{HINCA,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2A,0, 7,	0x2B, 0, 2,		4},
+	{HINCB,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2C,0, 7,	0x2D, 0, 2,		4},
+	{VINCA,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E,0, 7,	0x2F, 0, 2,		4},
+	{VINCB,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x30,0, 7,	0x31, 0, 2,		4},
+	{HDINCA,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x32,0, 7,	0x33, 0, 2,		4},
+	{HDINCB,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x34,0, 7,	0x35, 0, 2,		4},
+	{HINC,			  NOOP_INDEX,  0, 0,	0x36,0, 4,	0x37,0, 7,	0x38, 0, 7,		4},
+	{VINC,			  NOOP_INDEX,  0, 0,	0x39,0, 7,	0x3A,0, 7,  0x3B, 0, 7,		4},
+	{HDINC,		      NOOP_INDEX,  0, 0,	0x3C,0, 7,	0x3D,0, 7,	0x3E, 0, 7,		4},
+	{VSMST,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x70, 6, 7,		0},
+	{MEMINIT,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0A, 7, 7,		0},
+	{STOP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0A, 4, 4,		0},
+
+	{HDMI_PD,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x09, 0, 0,		0},
+	{I2S_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 6, 6,		0},
+	{SPDIF_PD,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 0, 0,		0},
+	{DRI_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 3, 3,		0},
+	{DRI_PD_SER,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x16, 0, 0,		1},
+	{DRI_PD_PLL,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x16, 3, 3,		1},
+	{DRI_PDDRI,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x08, 4, 7,		0},
+	{CEC_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 4, 4,		0},
+	{PD_DDC,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0E, 7, 7,		1},
+
+	{LVDS_PD,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0A, 3, 3,		0},
+	{RX_PD,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x63, 4, 7,		4},
+	{RXPLL_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x64, 0, 0,		4},
+    {TXPLL_PD,		  NOOP_INDEX,  0, 0,    NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x66, 1, 1,		4},
+	{TXDRV_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x11, 4, 4,		1},
+	{TXSER_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x1A, 4, 4,		1},
+
+	{VGA_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x09, 2, 2,		0},
+	{PDDAC,		      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x08, 1, 3,		0},
+	{DACSENCE,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x57, 1, 1,		4},
+	{GCKOFF,          NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x09, 6, 6,		0},
+	{TV_BP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x09, 5, 5,		0},
+	{PDPLL1,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 1, 1,		0},
+	{PDPLL0,	      NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x54, 4, 4,		4},
+
+	{ICEN0,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x11, 7, 7,		1},
+
+	{PD_PROM,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0F, 7, 7,		1},
+	{PDMIO,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 2, 2,		0},
+	{PDIO,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 5, 5,		0},
+	{HPD_PD,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 7, 7,		0},
+	{SCLPD,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x09, 4, 4,		0},
+	{SDPD,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x09, 3, 3,		0},
+	{MEMPD,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x0A, 5, 5,		0},
+	{AUDDAC,          NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x5C, 2, 2,		4},
+
+	{CRYS_FREQ_SPP,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,0x1C,	 0,	7,  0x1D, 0, 7,		0},
+	{I2SCK_SEC, 	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 2, 2,		1},
+	{SP_EN,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x21, 7, 7,		1},
+	{HARD_SOFTB,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x58, 5, 5,		4},
+	{MULT_I2CEN,	  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x4E, 0, 0,		1},
+	{RXPLL_REFDLY,    NOOP_INDEX,  0, 0,    NOOP_INDEX,  0, 0,  NOOP_INDEX,  0, 0,  0x66, 5, 7,     4},
+	{RXPLL_FBDLY,     NOOP_INDEX,  0, 0,    NOOP_INDEX,  0, 0,  NOOP_INDEX,  0, 0,  0x66, 2, 4,     4},
+	{VFMT,            NOOP_INDEX,  0, 0,    NOOP_INDEX,  0, 0,  NOOP_INDEX,  0, 0,  0x2B, 0, 3,     0},
+
+	{DBP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x19, 6, 6,		0},
+	{CK_TVINV,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x07, 1, 1,		1},
+	{DISPON,		  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x08, 0, 0,		1},
+
+	{VP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x39,4, 7,	0x3B, 0, 7,		0},
+	{HP,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x39,0, 3,	0x3A, 0, 7,		0},
+
+	{TXTEN,			  NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x2E, 0, 2,		0},
+	{ZRCTS,           NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	NOOP_INDEX,  0, 0,	0x24, 1, 1,		1},
 
 };
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.h
index d2e45bf..cc12975 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_reg_table.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_reg_table.h
-* @version 1.1.4
+* @version 1.2
 *-----------------------------------------------------------------------------
 */
 
@@ -115,4 +115,11 @@ typedef struct{
 
 extern MULTI_REG g_MultiRegTable[];
 
+//issue- 11/15/11- thua
+//Intel C compiler complained negative constant (-1) comparison to unsigned char for checked build verion
+//for free build, these warnings are treated as compiling error
+//solution:
+//define NOOP_REGINDEX as 2-complement of -1
+#define NOOP_INDEX 0xFF
+
 #endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_typedef.h b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_typedef.h
index 5bb9b40..35e3f91 100755
--- a/drivers/staging/emgd/emgd/pal/ch7036/ch7036_typedef.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/ch7036_typedef.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  ch7036_typedef.h
-* @version 1.1.4
+* @version 1.2
 *-----------------------------------------------------------------------------
 */
 
@@ -31,17 +31,25 @@
 
 
 
-typedef unsigned char			uint8;
-typedef unsigned short			uint16;
-typedef unsigned int			uint32;
+typedef unsigned char				uint8;
+typedef unsigned short				uint16;
+typedef unsigned int				uint32;
+
 
 
 typedef unsigned long long int 		uint64;
 
-typedef signed char				int8;
-typedef signed short			int16;
-typedef signed int				int32;
-typedef signed long long int			int64;
+typedef signed char					int8;
+typedef signed short				int16;
+typedef signed int					int32;
+
+typedef signed long long int		int64;
+
+
+
+
+
+
 
 typedef uint32					ch_bool;
 #define ch_true					1
@@ -148,6 +156,7 @@ typedef struct{
 #define CHANNEL_LVDS_HDMI 	(CHANNEL_LVDS | CHANNEL_HDMI)
 #define CHANNEL_LVDS_VGA 	(CHANNEL_LVDS | CHANNEL_VGA)
 #define CHANNEL_LVDS_DVI 	(CHANNEL_LVDS | CHANNEL_DVI)
+#define CHANNEL_AUTO_DETECT	0x10
 
 
 #define CHANNEL_LVDS_HDMI_VGA_OFF	0x0000
@@ -252,22 +261,18 @@ typedef enum hdmi{
 	OUT_HDMI_720x480P_59,
 	OUT_HDMI_720x480P_60,
 
+	OUT_HDMI_720x576P_50,
+
 	OUT_HDMI_1280x720P_59,
 	OUT_HDMI_1280x720P_60,
 
 	OUT_HDMI_1920x1080I_59,
 	OUT_HDMI_1920x1080I_60,
 
-
-
-
-
-
-
 	OUT_HDMI_1920x1080P_59,
 	OUT_HDMI_1920x1080P_60,
 
-	OUT_HDMI_720x576P_50,
+//	OUT_HDMI_720x576P_50, //2/2/12 grouped to downscaling modes < 13x7
 	OUT_HDMI_1280x720P_50,
 	OUT_HDMI_1920x1080I_50,
 
@@ -337,6 +342,7 @@ typedef enum dvi {
 	OUT_DVI_1920x1080_60,
 
 	OUT_DVI_1920x1200_60,
+
 	OUT_DVI_END,
 } DVI_OUT_MODE;
 
@@ -400,6 +406,8 @@ typedef enum crt{
 	OUT_CRT_END,
 }CRT_OUT_MODE;
 
+#define MAX_ATTR_LIST_SIZE 32
+
 
 
 
@@ -456,9 +464,9 @@ typedef enum {
 
 	SS_CRT_HPD_NOTCONNECTED,
 	SS_CRT_HPD_CONNECTED_TO_GRD,
+	SS_DISPLAY_CHOICE_NOT_ALLOWED,
 
 
 } ch7036_status_t;
 
-
 #endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/config_.h b/drivers/staging/emgd/emgd/pal/ch7036/config_.h
index ebc92eb..c0c43bb 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/config_.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/config_.h
@@ -21,7 +21,7 @@
 *
 *-----------------------------------------------------------------------------
 * @file  config_.h
-* @version 1.1.4
+* @version 1.2.3
 *-----------------------------------------------------------------------------
 */
 
@@ -34,32 +34,17 @@
 #define T_POST_SETMODE
 #define T_LVDS_CLOSE
 
-
-
-
 #define T_SET_TIMING
 
-
-
-
 #define T_PD_DISPLAY_LVDS_INT
 
-
-
-
 #define T_DEVICE_DETECTION
 #define T_RES_DEALLOC
 
-
-
-
-
-
 #define T_TEST_HW
 #define T_RESET
 
 
-
 #define T_HDMI_TIMING_TABLE
 #define T_VGA_TIMING_TABLE
 #define T_PANEL_NATIVE_DTD
@@ -67,10 +52,6 @@
 
 #define T_LH_POWER_ON_OFF
 
-
-
-
-
 #define T_CH7036_USE_LVDS_ATTR_TABLE
 
 #define T_CH7036_INIT_ATTR_TABLE
@@ -78,10 +59,15 @@
 
 #define T_CH7036_USE_FIRMWARE
 
+#define T_CH7036_EDID_DUMP
+#undef T_CH7036_EDID_DUMP
 
-#define T_LINUX
-
+#define T_SHOW_EDID_DISPLAY_ATTR
+#undef T_SHOW_EDID_DISPLAY_ATTR
 
+#define T_LINUX
+//#undef T_LINUX
 
+#define T_CONFIG_PLB
 
 #endif
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/edid7036.car b/drivers/staging/emgd/emgd/pal/ch7036/edid7036.car
new file mode 100644
index 0000000..b95f002
--- /dev/null
+++ b/drivers/staging/emgd/emgd/pal/ch7036/edid7036.car
@@ -0,0 +1,3362 @@
+unsigned char lhfm_array[]= {
+	0x02,
+	0x0D,
+	0x14,
+	0x02,
+	0x0A,
+	0xBC,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0xFF,
+	0x02,
+	0x09,
+	0x83,
+	0x75,
+	0x50,
+	0x66,
+	0xE4,
+	0xF5,
+	0x26,
+	0xF5,
+	0x27,
+	0xC2,
+	0x01,
+	0xF5,
+	0x25,
+	0xF5,
+	0x28,
+	0xFF,
+	0x12,
+	0x09,
+	0xF4,
+	0x40,
+	0x01,
+	0x22,
+	0xE5,
+	0x50,
+	0x24,
+	0x3E,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x4A,
+	0x7B,
+	0x02,
+	0x7D,
+	0x23,
+	0xE4,
+	0xFF,
+	0x12,
+	0x09,
+	0x15,
+	0x40,
+	0x01,
+	0x22,
+	0xA8,
+	0x50,
+	0xE6,
+	0x30,
+	0xE0,
+	0x03,
+	0x43,
+	0x28,
+	0x01,
+	0xE8,
+	0x04,
+	0xF8,
+	0xE6,
+	0xFF,
+	0x54,
+	0x0E,
+	0x60,
+	0x03,
+	0x43,
+	0x28,
+	0x02,
+	0xEF,
+	0x30,
+	0xE0,
+	0x03,
+	0x43,
+	0x28,
+	0x04,
+	0x75,
+	0x4B,
+	0x26,
+	0xE4,
+	0xF5,
+	0x4F,
+	0x7B,
+	0x02,
+	0xAD,
+	0x4B,
+	0xE4,
+	0xFF,
+	0x12,
+	0x09,
+	0x15,
+	0x50,
+	0x36,
+	0x05,
+	0x4B,
+	0x05,
+	0x4B,
+	0xA8,
+	0x50,
+	0xE6,
+	0xFF,
+	0xB4,
+	0x01,
+	0x08,
+	0xE8,
+	0x04,
+	0xF8,
+	0xE6,
+	0x64,
+	0x01,
+	0x60,
+	0x23,
+	0xE5,
+	0x50,
+	0x04,
+	0xF8,
+	0x74,
+	0xC0,
+	0x56,
+	0xF6,
+	0xEF,
+	0xB4,
+	0x81,
+	0x09,
+	0xE5,
+	0x50,
+	0x04,
+	0xF8,
+	0x76,
+	0x80,
+	0x43,
+	0x28,
+	0x04,
+	0xA8,
+	0x50,
+	0xE6,
+	0xB4,
+	0xA9,
+	0x08,
+	0xE8,
+	0x04,
+	0xF8,
+	0x76,
+	0x40,
+	0x43,
+	0x28,
+	0x10,
+	0x05,
+	0x4F,
+	0xE5,
+	0x4F,
+	0xC3,
+	0x94,
+	0x08,
+	0x40,
+	0xB6,
+	0x7B,
+	0x06,
+	0x7D,
+	0x38,
+	0xE4,
+	0xFF,
+	0x12,
+	0x09,
+	0x15,
+	0x40,
+	0x03,
+	0x02,
+	0x01,
+	0x30,
+	0xE5,
+	0x50,
+	0x24,
+	0x02,
+	0xF8,
+	0xE6,
+	0x54,
+	0xF0,
+	0xFF,
+	0xE5,
+	0x50,
+	0x04,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE5,
+	0x50,
+	0x24,
+	0x03,
+	0xF8,
+	0xE6,
+	0xFF,
+	0xE5,
+	0x50,
+	0x24,
+	0x02,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE5,
+	0x50,
+	0x24,
+	0x05,
+	0xF8,
+	0xE6,
+	0x54,
+	0xF0,
+	0xFF,
+	0xE5,
+	0x50,
+	0x24,
+	0x03,
+	0xF8,
+	0xA6,
+	0x07,
+	0xE4,
+	0xF5,
+	0x4F,
+	0xE4,
+	0xF5,
+	0x4C,
+	0xE5,
+	0x4F,
+	0x75,
+	0xF0,
+	0x05,
+	0xA4,
+	0x24,
+	0xBA,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x05,
+	0xF5,
+	0x83,
+	0xE5,
+	0x82,
+	0x25,
+	0x4C,
+	0xF5,
+	0x82,
+	0xE4,
+	0x35,
+	0x83,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0xFF,
+	0xE5,
+	0x50,
+	0x25,
+	0x4C,
+	0xF8,
+	0xE6,
+	0xB5,
+	0x07,
+	0x07,
+	0x05,
+	0x4C,
+	0xE5,
+	0x4C,
+	0xB4,
+	0x04,
+	0xD3,
+	0xE5,
+	0x4C,
+	0xB4,
+	0x04,
+	0x13,
+	0xE5,
+	0x4F,
+	0x75,
+	0xF0,
+	0x05,
+	0xA4,
+	0x24,
+	0xBF,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x05,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0x42,
+	0x28,
+	0x05,
+	0x4F,
+	0xE5,
+	0x4F,
+	0xB4,
+	0x03,
+	0xB1,
+	0xD2,
+	0x04,
+	0xE5,
+	0x4A,
+	0x70,
+	0x02,
+	0xC3,
+	0x22,
+	0x75,
+	0x4F,
+	0x01,
+	0xE5,
+	0x4F,
+	0xD3,
+	0x95,
+	0x4A,
+	0x40,
+	0x03,
+	0x02,
+	0x02,
+	0x61,
+	0xE5,
+	0x4F,
+	0x30,
+	0xE0,
+	0x04,
+	0x7F,
+	0x80,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x51,
+	0xAF,
+	0x4F,
+	0x12,
+	0x09,
+	0xF4,
+	0x40,
+	0x01,
+	0x22,
+	0xE5,
+	0x4F,
+	0xC3,
+	0x13,
+	0xF5,
+	0x4E,
+	0x7B,
+	0x05,
+	0xAD,
+	0x51,
+	0xFF,
+	0x12,
+	0x09,
+	0x15,
+	0x40,
+	0x01,
+	0x22,
+	0xA8,
+	0x50,
+	0xE6,
+	0x64,
+	0x02,
+	0x60,
+	0x03,
+	0x02,
+	0x02,
+	0x5C,
+	0xE8,
+	0x04,
+	0xF8,
+	0xE6,
+	0x64,
+	0x03,
+	0x60,
+	0x03,
+	0x02,
+	0x02,
+	0x5C,
+	0xE5,
+	0x50,
+	0x24,
+	0x02,
+	0xF8,
+	0xE6,
+	0xFF,
+	0xD3,
+	0x94,
+	0x04,
+	0x50,
+	0x03,
+	0x02,
+	0x02,
+	0x5C,
+	0x8F,
+	0x4B,
+	0xE5,
+	0x50,
+	0x24,
+	0x04,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x4C,
+	0x75,
+	0x4D,
+	0x04,
+	0xE5,
+	0x4C,
+	0x54,
+	0xE0,
+	0x64,
+	0x60,
+	0x70,
+	0x37,
+	0xE5,
+	0x4D,
+	0x7B,
+	0x06,
+	0x12,
+	0x09,
+	0x10,
+	0x40,
+	0x01,
+	0x22,
+	0xE5,
+	0x50,
+	0x04,
+	0xF8,
+	0xE6,
+	0x64,
+	0x03,
+	0x70,
+	0x24,
+	0xE5,
+	0x50,
+	0x24,
+	0x02,
+	0xF8,
+	0xE6,
+	0x64,
+	0x0C,
+	0x70,
+	0x1A,
+	0xE5,
+	0x50,
+	0x24,
+	0x03,
+	0xF8,
+	0xE6,
+	0x70,
+	0x12,
+	0xE5,
+	0x50,
+	0x24,
+	0x04,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x26,
+	0xE5,
+	0x50,
+	0x24,
+	0x05,
+	0xF8,
+	0xE6,
+	0xF5,
+	0x27,
+	0xD2,
+	0x01,
+	0xE5,
+	0x4C,
+	0x54,
+	0xE0,
+	0x64,
+	0x40,
+	0x70,
+	0x59,
+	0xE5,
+	0x4C,
+	0x54,
+	0x1F,
+	0xF5,
+	0x52,
+	0xE5,
+	0x4D,
+	0x25,
+	0x51,
+	0x04,
+	0xFD,
+	0xAB,
+	0x52,
+	0xAF,
+	0x4E,
+	0x12,
+	0x09,
+	0x15,
+	0x50,
+	0x64,
+	0xE4,
+	0xF5,
+	0x53,
+	0xE5,
+	0x53,
+	0xC3,
+	0x95,
+	0x52,
+	0x50,
+	0x3A,
+	0xE4,
+	0xF5,
+	0x54,
+	0xE5,
+	0x50,
+	0x25,
+	0x53,
+	0xF8,
+	0xE6,
+	0x54,
+	0x7F,
+	0xFF,
+	0xE5,
+	0x54,
+	0x25,
+	0xE0,
+	0x24,
+	0xA6,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x05,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0xB5,
+	0x07,
+	0x11,
+	0xE5,
+	0x54,
+	0x25,
+	0xE0,
+	0x24,
+	0xA7,
+	0xF5,
+	0x82,
+	0xE4,
+	0x34,
+	0x05,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0x42,
+	0x25,
+	0x05,
+	0x54,
+	0xE5,
+	0x54,
+	0xB4,
+	0x0A,
+	0xCD,
+	0x05,
+	0x53,
+	0x80,
+	0xBF,
+	0xE5,
+	0x4C,
+	0x54,
+	0x1F,
+	0x25,
+	0x4D,
+	0x04,
+	0xF5,
+	0x4D,
+	0x7B,
+	0x01,
+	0x12,
+	0x09,
+	0x10,
+	0x40,
+	0x01,
+	0x22,
+	0xA8,
+	0x50,
+	0xE6,
+	0xF5,
+	0x4C,
+	0xE5,
+	0x4D,
+	0xC3,
+	0x95,
+	0x4B,
+	0x50,
+	0x03,
+	0x02,
+	0x01,
+	0x9C,
+	0x05,
+	0x4F,
+	0x02,
+	0x01,
+	0x3B,
+	0xA2,
+	0x01,
+	0x22,
+	0xE4,
+	0xF5,
+	0xA8,
+	0xF5,
+	0xA0,
+	0x75,
+	0x90,
+	0xC0,
+	0xD2,
+	0x8A,
+	0xD2,
+	0x88,
+	0xD2,
+	0xA8,
+	0xD2,
+	0xB8,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x06,
+	0x63,
+	0xC2,
+	0x0D,
+	0xC2,
+	0x04,
+	0xC2,
+	0x07,
+	0xC2,
+	0x0F,
+	0xC2,
+	0x02,
+	0xE4,
+	0xF5,
+	0x47,
+	0xD2,
+	0x0A,
+	0xD2,
+	0x00,
+	0xD2,
+	0x09,
+	0xD2,
+	0x0C,
+	0xC2,
+	0x05,
+	0xC2,
+	0x08,
+	0xC2,
+	0x0B,
+	0x7E,
+	0x05,
+	0x7F,
+	0x7B,
+	0x12,
+	0x06,
+	0x8A,
+	0x7F,
+	0x0A,
+	0x12,
+	0x0C,
+	0xB4,
+	0x12,
+	0x07,
+	0x69,
+	0x75,
+	0x15,
+	0x19,
+	0x75,
+	0x16,
+	0x19,
+	0x75,
+	0x17,
+	0x0C,
+	0x12,
+	0x0C,
+	0x23,
+	0x7F,
+	0x0A,
+	0x12,
+	0x0C,
+	0x92,
+	0xE5,
+	0x47,
+	0x24,
+	0xFF,
+	0x92,
+	0x05,
+	0x7D,
+	0xC0,
+	0x7F,
+	0x6E,
+	0x12,
+	0x06,
+	0x75,
+	0xAF,
+	0x47,
+	0x12,
+	0x0B,
+	0xF9,
+	0xC2,
+	0x06,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x06,
+	0x4E,
+	0x75,
+	0x23,
+	0x00,
+	0x75,
+	0x24,
+	0x01,
+	0xE4,
+	0xF5,
+	0x46,
+	0x12,
+	0x06,
+	0xC6,
+	0x30,
+	0x0D,
+	0x05,
+	0x7F,
+	0xFF,
+	0x12,
+	0x08,
+	0x97,
+	0x30,
+	0x07,
+	0x30,
+	0x20,
+	0x04,
+	0x0C,
+	0x7F,
+	0x25,
+	0x12,
+	0x0C,
+	0x77,
+	0xEF,
+	0x30,
+	0xE4,
+	0x03,
+	0x12,
+	0x00,
+	0x0E,
+	0x7B,
+	0x12,
+	0x7D,
+	0x36,
+	0x7C,
+	0x00,
+	0x7F,
+	0x50,
+	0x12,
+	0x0B,
+	0x9F,
+	0x92,
+	0x10,
+	0x85,
+	0x3A,
+	0x35,
+	0x85,
+	0x25,
+	0x36,
+	0x85,
+	0x28,
+	0x37,
+	0xA2,
+	0x10,
+	0x92,
+	0x13,
+	0x7F,
+	0x0F,
+	0x12,
+	0x0A,
+	0xFF,
+	0xC2,
+	0x07,
+	0xE5,
+	0x16,
+	0x60,
+	0x03,
+	0x02,
+	0x03,
+	0xA3,
+	0x30,
+	0x02,
+	0x2D,
+	0xC2,
+	0xA8,
+	0x7F,
+	0x0A,
+	0x12,
+	0x0C,
+	0x92,
+	0xC2,
+	0x02,
+	0x30,
+	0x05,
+	0x0C,
+	0xE5,
+	0x47,
+	0x60,
+	0x04,
+	0xD2,
+	0x03,
+	0x80,
+	0x0C,
+	0xAF,
+	0x47,
+	0x80,
+	0x05,
+	0xE5,
+	0x47,
+	0x60,
+	0x04,
+	0xFF,
+	0x12,
+	0x0B,
+	0xF9,
+	0xE5,
+	0x47,
+	0x24,
+	0xFF,
+	0x92,
+	0x05,
+	0x75,
+	0x16,
+	0x19,
+	0xD2,
+	0xA8,
+	0x80,
+	0x54,
+	0x20,
+	0x0B,
+	0x1A,
+	0x30,
+	0x05,
+	0x09,
+	0x7F,
+	0x09,
+	0x12,
+	0x0C,
+	0x6F,
+	0xEF,
+	0x13,
+	0x92,
+	0x09,
+	0xD2,
+	0x0C,
+	0x7F,
+	0x08,
+	0x12,
+	0x0C,
+	0x6F,
+	0xEF,
+	0x54,
+	0x0E,
+	0x70,
+	0x02,
+	0xC2,
+	0x0C,
+	0xE5,
+	0x47,
+	0x60,
+	0x22,
+	0x7F,
+	0x09,
+	0x12,
+	0x0C,
+	0x6F,
+	0xEF,
+	0x20,
+	0xE0,
+	0x19,
+	0x7F,
+	0x0A,
+	0x12,
+	0x0C,
+	0x6F,
+	0xEF,
+	0x30,
+	0xE2,
+	0x10,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x06,
+	0x6F,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x12,
+	0x06,
+	0x4E,
+	0x80,
+	0x0E,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x06,
+	0x5A,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x12,
+	0x06,
+	0x63,
+	0x75,
+	0x16,
+	0x4B,
+	0xE5,
+	0x17,
+	0x70,
+	0x2C,
+	0x7F,
+	0x7F,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x54,
+	0x04,
+	0xF5,
+	0x49,
+	0x65,
+	0x3D,
+	0x60,
+	0x1B,
+	0x85,
+	0x3D,
+	0x49,
+	0x7F,
+	0x0A,
+	0x12,
+	0x0C,
+	0xB4,
+	0xE5,
+	0x3D,
+	0x65,
+	0x49,
+	0x60,
+	0x0D,
+	0xE5,
+	0x3D,
+	0x70,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x92,
+	0x11,
+	0x12,
+	0x0B,
+	0xCD,
+	0x75,
+	0x17,
+	0x19,
+	0x05,
+	0x24,
+	0xE5,
+	0x24,
+	0xAE,
+	0x23,
+	0x70,
+	0x02,
+	0x05,
+	0x23,
+	0x14,
+	0x4E,
+	0x60,
+	0x03,
+	0x02,
+	0x02,
+	0xDA,
+	0x75,
+	0x13,
+	0x07,
+	0x75,
+	0x14,
+	0xD0,
+	0x05,
+	0x46,
+	0xE5,
+	0x46,
+	0x20,
+	0xE0,
+	0x03,
+	0x02,
+	0x02,
+	0xDA,
+	0x02,
+	0x02,
+	0xDA,
+	0x02,
+	0x05,
+	0x4B,
+	0xEC,
+	0x5D,
+	0x04,
+	0x60,
+	0x05,
+	0xE8,
+	0x59,
+	0x04,
+	0x70,
+	0x03,
+	0x02,
+	0x05,
+	0x41,
+	0x12,
+	0x05,
+	0x0C,
+	0x58,
+	0x04,
+	0x60,
+	0xF6,
+	0xEC,
+	0x48,
+	0x60,
+	0xF2,
+	0xEC,
+	0x70,
+	0x04,
+	0xFD,
+	0xFE,
+	0xFF,
+	0x22,
+	0xC8,
+	0x60,
+	0xDB,
+	0x24,
+	0x81,
+	0xC8,
+	0x50,
+	0x09,
+	0xC3,
+	0x98,
+	0x60,
+	0x02,
+	0x50,
+	0x06,
+	0x02,
+	0x05,
+	0x48,
+	0x98,
+	0x50,
+	0xCA,
+	0xF5,
+	0x82,
+	0xE9,
+	0x29,
+	0x4B,
+	0x4A,
+	0x70,
+	0x05,
+	0xAB,
+	0x82,
+	0x02,
+	0x05,
+	0x37,
+	0x75,
+	0xF0,
+	0x00,
+	0x7C,
+	0x1A,
+	0x78,
+	0x80,
+	0xC3,
+	0xEF,
+	0x9B,
+	0xEE,
+	0x9A,
+	0xED,
+	0x99,
+	0x40,
+	0x0D,
+	0xC3,
+	0xEF,
+	0x9B,
+	0xFF,
+	0xEE,
+	0x9A,
+	0xFE,
+	0xED,
+	0x99,
+	0xFD,
+	0xE8,
+	0x42,
+	0xF0,
+	0xDC,
+	0x23,
+	0xAC,
+	0xF0,
+	0xD0,
+	0xE0,
+	0xFF,
+	0xD0,
+	0xE0,
+	0xFE,
+	0xD0,
+	0xE0,
+	0xFD,
+	0xAB,
+	0x82,
+	0x20,
+	0xE7,
+	0x10,
+	0x1B,
+	0xEB,
+	0x60,
+	0xBA,
+	0xEC,
+	0x2C,
+	0xFC,
+	0xEF,
+	0x33,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0x02,
+	0x05,
+	0x23,
+	0xE8,
+	0x03,
+	0xF8,
+	0x30,
+	0xE7,
+	0x05,
+	0xC0,
+	0xF0,
+	0x75,
+	0xF0,
+	0x00,
+	0xEF,
+	0x2F,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0x40,
+	0xB8,
+	0x30,
+	0xE7,
+	0xC2,
+	0x80,
+	0xAA,
+	0x75,
+	0xF0,
+	0x20,
+	0x80,
+	0x0E,
+	0x75,
+	0xF0,
+	0x10,
+	0x80,
+	0x05,
+	0x75,
+	0xF0,
+	0x08,
+	0x7D,
+	0x00,
+	0x7E,
+	0x00,
+	0x7F,
+	0x00,
+	0x33,
+	0x92,
+	0xD5,
+	0x30,
+	0xD5,
+	0x03,
+	0x12,
+	0x05,
+	0x56,
+	0xEC,
+	0x33,
+	0x40,
+	0x10,
+	0xEF,
+	0x33,
+	0xFF,
+	0xEE,
+	0x33,
+	0xFE,
+	0xED,
+	0x33,
+	0xFD,
+	0xEC,
+	0x33,
+	0xFC,
+	0xD5,
+	0xF0,
+	0xED,
+	0x22,
+	0xE5,
+	0xF0,
+	0x24,
+	0x7E,
+	0xA2,
+	0xD5,
+	0x13,
+	0xCC,
+	0x92,
+	0xE7,
+	0xCD,
+	0xCE,
+	0xFF,
+	0x22,
+	0xED,
+	0xD2,
+	0xE7,
+	0xCD,
+	0x33,
+	0xEC,
+	0x33,
+	0x92,
+	0xD5,
+	0x24,
+	0x81,
+	0x40,
+	0x06,
+	0xE4,
+	0xFF,
+	0xFE,
+	0xFD,
+	0xFC,
+	0x22,
+	0xFC,
+	0xE4,
+	0xCF,
+	0xCE,
+	0xCD,
+	0xCC,
+	0x24,
+	0xE0,
+	0x50,
+	0x11,
+	0x74,
+	0xFF,
+	0x80,
+	0xED,
+	0xC3,
+	0xCC,
+	0x13,
+	0xCC,
+	0xCD,
+	0x13,
+	0xCD,
+	0xCE,
+	0x13,
+	0xCE,
+	0xCF,
+	0x13,
+	0xCF,
+	0x04,
+	0x70,
+	0xF0,
+	0x30,
+	0xD5,
+	0xDE,
+	0x02,
+	0x05,
+	0x56,
+	0xE9,
+	0xD2,
+	0xE7,
+	0xC9,
+	0x33,
+	0xE8,
+	0x33,
+	0xF8,
+	0x92,
+	0xD5,
+	0xED,
+	0xD2,
+	0xE7,
+	0xCD,
+	0x33,
+	0xEC,
+	0x33,
+	0xFC,
+	0x50,
+	0x02,
+	0xB2,
+	0xD5,
+	0x22,
+	0xEC,
+	0x30,
+	0xE7,
+	0x10,
+	0x0F,
+	0xBF,
+	0x00,
+	0x0C,
+	0x0E,
+	0xBE,
+	0x00,
+	0x08,
+	0x0D,
+	0xBD,
+	0x00,
+	0x04,
+	0x0B,
+	0xEB,
+	0x60,
+	0x14,
+	0xA2,
+	0xD5,
+	0xEB,
+	0x13,
+	0xFC,
+	0xED,
+	0x92,
+	0xE7,
+	0xFD,
+	0x22,
+	0x74,
+	0xFF,
+	0xFC,
+	0xFD,
+	0xFE,
+	0xFF,
+	0x22,
+	0xE4,
+	0x80,
+	0xF8,
+	0xA2,
+	0xD5,
+	0x74,
+	0xFF,
+	0x13,
+	0xFC,
+	0x7D,
+	0x80,
+	0xE4,
+	0x80,
+	0xEF,
+	0xC3,
+	0xE4,
+	0x9F,
+	0xFF,
+	0xE4,
+	0x9E,
+	0xFE,
+	0xE4,
+	0x9D,
+	0xFD,
+	0xE4,
+	0x9C,
+	0xFC,
+	0x22,
+	0x26,
+	0x27,
+	0x42,
+	0x43,
+	0x44,
+	0x45,
+	0x46,
+	0x47,
+	0x6A,
+	0x51,
+	0x52,
+	0x53,
+	0x57,
+	0x58,
+	0x59,
+	0x5A,
+	0x07,
+	0x01,
+	0x2B,
+	0x00,
+	0x00,
+	0x01,
+	0x00,
+	0x14,
+	0x5A,
+	0x00,
+	0x20,
+	0x07,
+	0x10,
+	0x11,
+	0x0E,
+	0x80,
+	0x14,
+	0x59,
+	0xE0,
+	0x24,
+	0x59,
+	0x60,
+	0x10,
+	0x19,
+	0x04,
+	0x00,
+	0x1C,
+	0x69,
+	0x00,
+	0x1D,
+	0x78,
+	0x04,
+	0x76,
+	0x00,
+	0x04,
+	0x77,
+	0x20,
+	0x04,
+	0x75,
+	0x08,
+	0x14,
+	0x52,
+	0x10,
+	0x23,
+	0x10,
+	0x01,
+	0x13,
+	0x0F,
+	0x20,
+	0xF0,
+	0x10,
+	0x80,
+	0x1F,
+	0x40,
+	0x04,
+	0x20,
+	0x13,
+	0x10,
+	0x05,
+	0x08,
+	0x14,
+	0x04,
+	0x03,
+	0x02,
+	0x02,
+	0x02,
+	0x12,
+	0x01,
+	0x11,
+	0x01,
+	0x00,
+	0x50,
+	0x00,
+	0x40,
+	0x04,
+	0x66,
+	0x50,
+	0x00,
+	0x30,
+	0x08,
+	0x40,
+	0x60,
+	0xB0,
+	0x40,
+	0x10,
+	0x20,
+	0x09,
+	0x01,
+	0x20,
+	0x08,
+	0xF0,
+	0x20,
+	0x07,
+	0x19,
+	0x21,
+	0x0D,
+	0x80,
+	0x21,
+	0x16,
+	0x01,
+	0xF0,
+	0x10,
+	0x08,
+	0x0E,
+	0x10,
+	0x09,
+	0x04,
+	0xF0,
+	0x20,
+	0x08,
+	0x0E,
+	0x20,
+	0x09,
+	0x04,
+	0xF0,
+	0x20,
+	0x09,
+	0x5D,
+	0x20,
+	0x08,
+	0xFE,
+	0x20,
+	0x07,
+	0x1D,
+	0x20,
+	0x0A,
+	0x20,
+	0x20,
+	0x07,
+	0x02,
+	0x24,
+	0x54,
+	0x10,
+	0x21,
+	0x11,
+	0x80,
+	0x10,
+	0x0A,
+	0x04,
+	0xF0,
+	0x11,
+	0x11,
+	0x80,
+	0x10,
+	0x07,
+	0x02,
+	0x14,
+	0x54,
+	0x10,
+	0x10,
+	0x07,
+	0x1D,
+	0x10,
+	0x0A,
+	0x20,
+	0x11,
+	0x16,
+	0x01,
+	0x11,
+	0x0D,
+	0x80,
+	0x10,
+	0x08,
+	0xF0,
+	0x10,
+	0x09,
+	0x5D,
+	0x14,
+	0x52,
+	0x01,
+	0x24,
+	0x52,
+	0x01,
+	0xF0,
+	0x7B,
+	0x00,
+	0x80,
+	0x0A,
+	0x7B,
+	0x01,
+	0x80,
+	0x06,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0x7C,
+	0x00,
+	0x80,
+	0x00,
+	0x12,
+	0x06,
+	0x42,
+	0xE2,
+	0x5C,
+	0x4D,
+	0xF2,
+	0x78,
+	0x03,
+	0xEB,
+	0xF2,
+	0xD2,
+	0xAF,
+	0x22,
+	0xC2,
+	0xAF,
+	0x78,
+	0x83,
+	0xE2,
+	0xCB,
+	0xF2,
+	0x74,
+	0x80,
+	0x2F,
+	0xF8,
+	0x22,
+	0x7B,
+	0x00,
+	0x80,
+	0x0A,
+	0x7B,
+	0x01,
+	0x80,
+	0x06,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0xED,
+	0xF4,
+	0xFC,
+	0x7D,
+	0x00,
+	0x80,
+	0xD1,
+	0x7B,
+	0x00,
+	0x80,
+	0x0A,
+	0x7B,
+	0x01,
+	0x80,
+	0x06,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0x7C,
+	0xFF,
+	0x80,
+	0xBF,
+	0x7B,
+	0x03,
+	0x80,
+	0x02,
+	0x7B,
+	0x04,
+	0x12,
+	0x06,
+	0x42,
+	0xED,
+	0xF4,
+	0xFF,
+	0xE2,
+	0x5F,
+	0xF2,
+	0x4D,
+	0xF2,
+	0x5F,
+	0xF2,
+	0x80,
+	0xB1,
+	0x8E,
+	0x83,
+	0x8F,
+	0x82,
+	0xE4,
+	0x93,
+	0xA3,
+	0xFB,
+	0x54,
+	0x0F,
+	0xCB,
+	0x54,
+	0xF0,
+	0xB4,
+	0xF0,
+	0x01,
+	0x22,
+	0xFD,
+	0xE4,
+	0x93,
+	0xA3,
+	0xFF,
+	0xE4,
+	0x93,
+	0xA3,
+	0xCD,
+	0xB4,
+	0x00,
+	0x05,
+	0x12,
+	0x06,
+	0x30,
+	0x80,
+	0xE2,
+	0xB4,
+	0x10,
+	0x05,
+	0x12,
+	0x06,
+	0x5C,
+	0x80,
+	0xDA,
+	0xB4,
+	0x20,
+	0x05,
+	0x12,
+	0x06,
+	0x71,
+	0x80,
+	0xD2,
+	0xB4,
+	0x30,
+	0x05,
+	0x12,
+	0x06,
+	0x7B,
+	0x80,
+	0xCA,
+	0x80,
+	0xC8,
+	0xD2,
+	0x11,
+	0xD2,
+	0x12,
+	0x30,
+	0x06,
+	0x03,
+	0x02,
+	0x07,
+	0x66,
+	0x7F,
+	0x4F,
+	0x12,
+	0x0C,
+	0x6F,
+	0x8F,
+	0x4A,
+	0xE5,
+	0x4A,
+	0x20,
+	0xE6,
+	0x03,
+	0x02,
+	0x07,
+	0x66,
+	0xD2,
+	0x06,
+	0x53,
+	0x4A,
+	0x3F,
+	0xE5,
+	0x4A,
+	0x24,
+	0xFD,
+	0x60,
+	0x12,
+	0x24,
+	0xFD,
+	0x60,
+	0x14,
+	0x24,
+	0xE7,
+	0x60,
+	0x2E,
+	0x24,
+	0x1E,
+	0x70,
+	0x5F,
+	0xD2,
+	0x0D,
+	0xC2,
+	0x11,
+	0x80,
+	0x5E,
+	0xD2,
+	0x07,
+	0xC2,
+	0x11,
+	0x80,
+	0x58,
+	0x30,
+	0x0A,
+	0x04,
+	0x7F,
+	0x80,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x29,
+	0x7F,
+	0x25,
+	0x12,
+	0x0C,
+	0x77,
+	0xEF,
+	0x30,
+	0xE4,
+	0x03,
+	0x43,
+	0x29,
+	0x01,
+	0xC2,
+	0x0A,
+	0x75,
+	0x4A,
+	0x01,
+	0x80,
+	0x3A,
+	0x75,
+	0x4B,
+	0x05,
+	0x75,
+	0x4C,
+	0x74,
+	0xE4,
+	0xFF,
+	0xE5,
+	0x4C,
+	0x2F,
+	0xF5,
+	0x82,
+	0xE4,
+	0x35,
+	0x4B,
+	0xF5,
+	0x83,
+	0xE4,
+	0x93,
+	0xFE,
+	0x74,
+	0x29,
+	0x2F,
+	0xF8,
+	0xA6,
+	0x06,
+	0x0F,
+	0xBF,
+	0x07,
+	0xE9,
+	0x7F,
+	0x50,
+	0x12,
+	0x0C,
+	0x7B,
+	0x8F,
+	0x2C,
+	0x7F,
+	0x51,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x54,
+	0x0F,
+	0xF5,
+	0x2D,
+	0x75,
+	0x4A,
+	0x07,
+	0x80,
+	0x05,
+	0xE4,
+	0xF5,
+	0x4A,
+	0xC2,
+	0x12,
+	0x30,
+	0x11,
+	0x09,
+	0xA2,
+	0x12,
+	0x92,
+	0x13,
+	0xAF,
+	0x4A,
+	0x12,
+	0x0A,
+	0xFF,
+	0xA2,
+	0x06,
+	0x22,
+	0xC2,
+	0x96,
+	0xD2,
+	0x97,
+	0xD2,
+	0x96,
+	0x22,
+	0x22,
+	0xC2,
+	0x97,
+	0xD2,
+	0x96,
+	0x74,
+	0x28,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x97,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0x22,
+	0xC2,
+	0x97,
+	0xD2,
+	0x97,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x96,
+	0x74,
+	0x28,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0x22,
+	0xD2,
+	0x97,
+	0xD2,
+	0x96,
+	0x74,
+	0x28,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xC2,
+	0x97,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xC2,
+	0x96,
+	0x74,
+	0x1E,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0x22,
+	0xEF,
+	0x7E,
+	0x08,
+	0x33,
+	0xC0,
+	0xE0,
+	0x40,
+	0x04,
+	0xC2,
+	0x97,
+	0x80,
+	0x02,
+	0xD2,
+	0x97,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xC2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD0,
+	0xE0,
+	0xDE,
+	0xD8,
+	0xD2,
+	0x97,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xD2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xA2,
+	0x97,
+	0xE4,
+	0x92,
+	0xE0,
+	0xFE,
+	0xC2,
+	0x96,
+	0x74,
+	0x11,
+	0x00,
+	0x00,
+	0xD5,
+	0xE0,
+	0xFB,
+	0xEE,
+	0x22,
+	0x8F,
+	0x5E,
+	0x8D,
+	0x5F,
+	0x7F,
+	0x5A,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x54,
+	0x80,
+	0xF5,
+	0x62,
+	0xE5,
+	0x5E,
+	0xB4,
+	0x01,
+	0x04,
+	0x7F,
+	0x40,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x60,
+	0x43,
+	0x60,
+	0x80,
+	0xAD,
+	0x60,
+	0x7F,
+	0x0A,
+	0x12,
+	0x06,
+	0x2E,
+	0xE5,
+	0x60,
+	0x44,
+	0x20,
+	0xFD,
+	0x7F,
+	0x0A,
+	0x12,
+	0x06,
+	0x2E,
+	0xAD,
+	0x60,
+	0x7F,
+	0x0A,
+	0x12,
+	0x06,
+	0x2E,
+	0x7F,
+	0x0E,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x20,
+	0xE7,
+	0x4E,
+	0x7F,
+	0x5A,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x54,
+	0x80,
+	0x65,
+	0x62,
+	0x60,
+	0x03,
+	0x7F,
+	0xFF,
+	0x22,
+	0x7F,
+	0x0E,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x30,
+	0xE6,
+	0x03,
+	0x7F,
+	0x01,
+	0x22,
+	0x85,
+	0x60,
+	0x61,
+	0x7F,
+	0x0C,
+	0x12,
+	0x0C,
+	0x7B,
+	0x8F,
+	0x60,
+	0xE5,
+	0x61,
+	0x65,
+	0x60,
+	0x60,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0xE5,
+	0x60,
+	0x60,
+	0x04,
+	0x7E,
+	0x01,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x5F,
+	0x60,
+	0xB8,
+	0x7F,
+	0x0D,
+	0x12,
+	0x0C,
+	0x7B,
+	0xE5,
+	0x60,
+	0x14,
+	0x25,
+	0x5F,
+	0xF8,
+	0xA6,
+	0x07,
+	0x80,
+	0xA9,
+	0x7F,
+	0x00,
+	0x22,
+	0xAD,
+	0x07,
+	0x8D,
+	0x4A,
+	0xBD,
+	0xFF,
+	0x07,
+	0x7F,
+	0x50,
+	0x12,
+	0x0C,
+	0x6F,
+	0xAD,
+	0x07,
+	0xED,
+	0x54,
+	0x80,
+	0xFF,
+	0x53,
+	0x05,
+	0x7F,
+	0xED,
+	0xC4,
+	0x54,
+	0x0F,
+	0xFE,
+	0xED,
+	0x54,
+	0x0F,
+	0xC4,
+	0x54,
+	0xF0,
+	0xFD,
+	0xEF,
+	0x4E,
+	0xFF,
+	0x7B,
+	0x10,
+	0x12,
+	0x09,
+	0x15,
+	0x92,
+	0x11,
+	0xAD,
+	0x4A,
+	0x7F,
+	0x66,
+	0xE4,
+	0xF5,
+	0x4A,
+	0x30,
+	0x11,
+	0x08,
+	0xEF,
+	0x25,
+	0x4A,
+	0xF8,
+	0xE6,
+	0xFE,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0x74,
+	0x29,
+	0x25,
+	0x4A,
+	0xF8,
+	0xA6,
+	0x06,
+	0x05,
+	0x4A,
+	0xE5,
+	0x4A,
+	0xB4,
+	0x10,
+	0xE5,
+	0xED,
+	0xF4,
+	0x70,
+	0x25,
+	0xA2,
+	0x11,
+	0x92,
+	0x13,
+	0x7F,
+	0x10,
+	0x12,
+	0x0A,
+	0xFF,
+	0xC2,
+	0x0D,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x06,
+	0x4E,
+	0x30,
+	0x11,
+	0x09,
+	0x7D,
+	0x80,
+	0x7F,
+	0x50,
+	0x12,
+	0x06,
+	0x4E,
+	0x80,
+	0x07,
+	0x7D,
+	0x40,
+	0x7F,
+	0x50,
+	0x12,
+	0x06,
+	0x63,
+	0xA2,
+	0x11,
+	0x22,
+	0x25,
+	0x51,
+	0xFD,
+	0xAF,
+	0x4E,
+	0x8F,
+	0x59,
+	0x8D,
+	0x5A,
+	0x8B,
+	0x5B,
+	0x75,
+	0x5C,
+	0x03,
+	0xE5,
+	0x59,
+	0x30,
+	0xE7,
+	0x04,
+	0x7F,
+	0x01,
+	0x80,
+	0x02,
+	0x7F,
+	0x00,
+	0x8F,
+	0x5D,
+	0x53,
+	0x59,
+	0x7F,
+	0xAF,
+	0x5C,
+	0x15,
+	0x5C,
+	0xEF,
+	0x60,
+	0x4C,
+	0xE5,
+	0x5D,
+	0x70,
+	0x1D,
+	0xE5,
+	0x59,
+	0xD3,
+	0x94,
+	0x00,
+	0x40,
+	0x16,
+	0x12,
+	0x07,
+	0x70,
+	0x12,
+	0x07,
+	0x9B,
+	0x7F,
+	0x60,
+	0x12,
+	0x07,
+	0xB9,
+	0xAF,
+	0x59,
+	0x12,
+	0x07,
+	0xB9,
+	0x12,
+	0x07,
+	0x86,
+	0x12,
+	0x07,
+	0x70,
+	0xE5,
+	0x5D,
+	0x60,
+	0x0D,
+	0xE5,
+	0x5A,
+	0xFD,
+	0x7C,
+	0x00,
+	0xAB,
+	0x5B,
+	0x7F,
+	0x50,
+	0x7E,
+	0x02,
+	0x80,
+	0x0B,
+	0xE5,
+	0x5A,
+	0xFD,
+	0x7C,
+	0x00,
+	0xAB,
+	0x5B,
+	0x7F,
+	0x50,
+	0x7E,
+	0x00,
+	0x12,
+	0x0A,
+	0x61,
+	0x7D,
+	0x66,
+	0xE4,
+	0xFF,
+	0x12,
+	0x08,
+	0x07,
+	0xEF,
+	0x70,
+	0xAF,
+	0xD3,
+	0x22,
+	0xC3,
+	0x22,
+	0xC0,
+	0xE0,
+	0xC0,
+	0xD0,
+	0xC2,
+	0x8C,
+	0x75,
+	0x8A,
+	0x40,
+	0x75,
+	0x8C,
+	0x7C,
+	0xD2,
+	0x8C,
+	0x05,
+	0x18,
+	0xE5,
+	0x18,
+	0x70,
+	0x19,
+	0x05,
+	0x10,
+	0xE5,
+	0x10,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0x05,
+	0x75,
+	0x10,
+	0x00,
+	0xD2,
+	0x0E,
+	0xE5,
+	0x10,
+	0xB4,
+	0x01,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x92,
+	0x03,
+	0xE5,
+	0x11,
+	0x60,
+	0x02,
+	0x15,
+	0x11,
+	0xE5,
+	0x12,
+	0x60,
+	0x02,
+	0x15,
+	0x12,
+	0xE5,
+	0x15,
+	0x60,
+	0x02,
+	0x15,
+	0x15,
+	0xE5,
+	0x16,
+	0x60,
+	0x02,
+	0x15,
+	0x16,
+	0xE5,
+	0x17,
+	0x60,
+	0x02,
+	0x15,
+	0x17,
+	0xE5,
+	0x14,
+	0x45,
+	0x13,
+	0x60,
+	0x0A,
+	0xE5,
+	0x14,
+	0x15,
+	0x14,
+	0x70,
+	0x0C,
+	0x15,
+	0x13,
+	0x80,
+	0x08,
+	0xC2,
+	0xAF,
+	0x12,
+	0x0C,
+	0x91,
+	0x02,
+	0x00,
+	0x00,
+	0x74,
+	0x81,
+	0xB5,
+	0x81,
+	0x00,
+	0x40,
+	0x02,
+	0x80,
+	0xEF,
+	0xD0,
+	0xD0,
+	0xD0,
+	0xE0,
+	0x32,
+	0x8F,
+	0x55,
+	0x75,
+	0x58,
+	0x66,
+	0xE4,
+	0xF5,
+	0x56,
+	0xE5,
+	0x55,
+	0xC3,
+	0x13,
+	0xFF,
+	0xE5,
+	0x55,
+	0x30,
+	0xE0,
+	0x04,
+	0x7D,
+	0x80,
+	0x80,
+	0x02,
+	0x7D,
+	0x00,
+	0x7B,
+	0x40,
+	0x12,
+	0x09,
+	0x15,
+	0x40,
+	0x01,
+	0x22,
+	0xE4,
+	0xF5,
+	0x57,
+	0xE5,
+	0x58,
+	0x25,
+	0x57,
+	0xF8,
+	0xE6,
+	0x25,
+	0x56,
+	0xF5,
+	0x56,
+	0x05,
+	0x57,
+	0xE5,
+	0x57,
+	0xB4,
+	0x40,
+	0xEF,
+	0xE5,
+	0x55,
+	0xC3,
+	0x13,
+	0xFF,
+	0xE5,
+	0x55,
+	0x30,
+	0xE0,
+	0x04,
+	0x7E,
+	0x80,
+	0x80,
+	0x02,
+	0x7E,
+	0x00,
+	0xEE,
+	0x24,
+	0x40,
+	0xFD,
+	0x7B,
+	0x40,
+	0x12,
+	0x09,
+	0x15,
+	0x40,
+	0x01,
+	0x22,
+	0xE4,
+	0xF5,
+	0x57,
+	0xE5,
+	0x58,
+	0x25,
+	0x57,
+	0xF8,
+	0xE6,
+	0x25,
+	0x56,
+	0xF5,
+	0x56,
+	0x05,
+	0x57,
+	0xE5,
+	0x57,
+	0xB4,
+	0x40,
+	0xEF,
+	0xE5,
+	0x56,
+	0x70,
+	0x03,
+	0xD3,
+	0x80,
+	0x01,
+	0xC3,
+	0x22,
+	0x8E,
+	0x5E,
+	0x8F,
+	0x5F,
+	0x8C,
+	0x60,
+	0x8D,
+	0x61,
+	0x8B,
+	0x62,
+	0xE5,
+	0x5E,
+	0xF5,
+	0x63,
+	0xEF,
+	0xF5,
+	0x64,
+	0xE5,
+	0x63,
+	0x7D,
+	0x80,
+	0x7F,
+	0x5A,
+	0x30,
+	0xE1,
+	0x05,
+	0x12,
+	0x06,
+	0x6F,
+	0x80,
+	0x03,
+	0x12,
+	0x06,
+	0x5A,
+	0x53,
+	0x63,
+	0x01,
+	0xE5,
+	0x63,
+	0x70,
+	0x0B,
+	0xE5,
+	0x60,
+	0x25,
+	0x64,
+	0xF5,
+	0x64,
+	0xE4,
+	0xF5,
+	0x65,
+	0x80,
+	0x04,
+	0xE5,
+	0x60,
+	0xF5,
+	0x65,
+	0xAD,
+	0x64,
+	0x7F,
+	0x28,
+	0x12,
+	0x06,
+	0x2E,
+	0xAD,
+	0x65,
+	0x7F,
+	0x40,
+	0x12,
+	0x06,
+	0x2E,
+	0xE5,
+	0x61,
+	0xF5,
+	0x65,
+	0xAD,
+	0x65,
+	0x7F,
+	0x29,
+	0x12,
+	0x06,
+	0x2E,
+	0xAD,
+	0x62,
+	0x7F,
+	0x08,
+	0x12,
+	0x06,
+	0x2E,
+	0xAF,
+	0x63,
+	0x22,
+	0xC0,
+	0xE0,
+	0xC0,
+	0xF0,
+	0xC0,
+	0x83,
+	0xC0,
+	0x82,
+	0xC0,
+	0xD0,
+	0x75,
+	0xD0,
+	0x08,
+	0x7F,
+	0x25,
+	0x12,
+	0x0C,
+	0x77,
+	0xEF,
+	0x54,
+	0x10,
+	0xF5,
+	0x48,
+	0x7D,
+	0x40,
+	0x7F,
+	0x6E,
+	0x12,
+	0x06,
+	0x75,
+	0x30,
+	0x00,
+	0x17,
+	0xE5,
+	0x48,
+	0x65,
+	0x47,
+	0x60,
+	0x11,
+	0x85,
+	0x48,
+	0x47,
+	0xD2,
+	0x02,
+	0xD2,
+	0x0A,
+	0xE5,
+	0x16,
+	0xD3,
+	0x94,
+	0x03,
+	0x40,
+	0x03,
+	0x75,
+	0x16,
+	0x03,
+	0xD0,
+	0xD0,
+	0xD0,
+	0x82,
+	0xD0,
+	0x83,
+	0xD0,
+	0xF0,
+	0xD0,
+	0xE0,
+	0x32,
+	0x8F,
+	0x4D,
+	0xE4,
+	0xF5,
+	0x4E,
+	0xE5,
+	0x4E,
+	0xC3,
+	0x95,
+	0x4D,
+	0x50,
+	0x15,
+	0xE5,
+	0x4E,
+	0x90,
+	0x05,
+	0x64,
+	0x93,
+	0xFF,
+	0x74,
+	0x29,
+	0x25,
+	0x4E,
+	0xF8,
+	0xE6,
+	0xFD,
+	0x12,
+	0x06,
+	0x26,
+	0x05,
+	0x4E,
+	0x80,
+	0xE4,
+	0x20,
+	0x13,
+	0x03,
+	0x43,
+	0x4D,
+	0x80,
+	0xAD,
+	0x4D,
+	0x7F,
+	0x50,
+	0x12,
+	0x06,
+	0x22,
+	0x7D,
+	0x40,
+	0x7F,
+	0x4F,
+	0x12,
+	0x06,
+	0x4E,
+	0xC2,
+	0x06,
+	0x22,
+	0x20,
+	0x12,
+	0x15,
+	0x7D,
+	0x08,
+	0x7F,
+	0x0A,
+	0x12,
+	0x06,
+	0x63,
+	0x7D,
+	0xFC,
+	0x7F,
+	0x63,
+	0x12,
+	0x06,
+	0x6F,
+	0x7D,
+	0x01,
+	0x7F,
+	0x64,
+	0x12,
+	0x06,
+	0x6F,
+	0x7D,
+	0x02,
+	0x7F,
+	0x66,
+	0x12,
+	0x06,
+	0x6F,
+	0x7D,
+	0x10,
+	0x7F,
+	0x11,
+	0x12,
+	0x06,
+	0x67,
+	0x7D,
+	0x10,
+	0x7F,
+	0x1A,
+	0x12,
+	0x06,
+	0x67,
+	0x7D,
+	0x08,
+	0x7F,
+	0x16,
+	0x02,
+	0x06,
+	0x67,
+	0x20,
+	0x12,
+	0x15,
+	0x7D,
+	0x08,
+	0x7F,
+	0x0A,
+	0x12,
+	0x06,
+	0x4E,
+	0x7D,
+	0xFC,
+	0x7F,
+	0x63,
+	0x12,
+	0x06,
+	0x5A,
+	0x7D,
+	0x01,
+	0x7F,
+	0x64,
+	0x12,
+	0x06,
+	0x5A,
+	0x7D,
+	0x02,
+	0x7F,
+	0x66,
+	0x12,
+	0x06,
+	0x5A,
+	0x7D,
+	0x10,
+	0x7F,
+	0x11,
+	0x12,
+	0x06,
+	0x52,
+	0x7D,
+	0x10,
+	0x7F,
+	0x1A,
+	0x12,
+	0x06,
+	0x52,
+	0x7D,
+	0x08,
+	0x7F,
+	0x16,
+	0x02,
+	0x06,
+	0x52,
+	0x8F,
+	0x4A,
+	0x8C,
+	0x4B,
+	0x8D,
+	0x4C,
+	0x8B,
+	0x4D,
+	0xE4,
+	0xF5,
+	0x4E,
+	0xAF,
+	0x4A,
+	0x7E,
+	0x00,
+	0xAB,
+	0x4D,
+	0xAD,
+	0x4C,
+	0xAC,
+	0x4B,
+	0x12,
+	0x0A,
+	0x61,
+	0x7D,
+	0x29,
+	0xE4,
+	0xFF,
+	0x12,
+	0x08,
+	0x07,
+	0xEF,
+	0x70,
+	0x02,
+	0xD3,
+	0x22,
+	0x05,
+	0x4E,
+	0xE5,
+	0x4E,
+	0xD3,
+	0x94,
+	0x02,
+	0x40,
+	0xDE,
+	0x22,
+	0xA2,
+	0x11,
+	0x92,
+	0x0B,
+	0x30,
+	0x11,
+	0x0F,
+	0x12,
+	0x0C,
+	0x49,
+	0x7E,
+	0x05,
+	0x7F,
+	0xE0,
+	0x12,
+	0x06,
+	0x8A,
+	0xD2,
+	0x12,
+	0x02,
+	0x0B,
+	0x37,
+	0xD2,
+	0x12,
+	0x12,
+	0x0B,
+	0x6B,
+	0x20,
+	0x09,
+	0x03,
+	0x12,
+	0x0C,
+	0xD6,
+	0x20,
+	0x0C,
+	0x07,
+	0x7E,
+	0x05,
+	0x7F,
+	0xD9,
+	0x12,
+	0x06,
+	0x8A,
+	0x22,
+	0xC2,
+	0x04,
+	0xEF,
+	0x60,
+	0x1A,
+	0x7D,
+	0x80,
+	0x7F,
+	0x0E,
+	0x12,
+	0x06,
+	0x52,
+	0x7F,
+	0x64,
+	0x7E,
+	0x00,
+	0x12,
+	0x0C,
+	0xF8,
+	0x12,
+	0x00,
+	0x0E,
+	0x20,
+	0x09,
+	0x03,
+	0x12,
+	0x0C,
+	0xD6,
+	0xD2,
+	0x03,
+	0x22,
+	0x12,
+	0x0C,
+	0x49,
+	0x7D,
+	0x80,
+	0x7F,
+	0x0E,
+	0x12,
+	0x06,
+	0x67,
+	0x22,
+	0xC2,
+	0xAF,
+	0xE4,
+	0xF5,
+	0x11,
+	0xF5,
+	0x12,
+	0x75,
+	0x13,
+	0x07,
+	0x75,
+	0x14,
+	0xD0,
+	0xF5,
+	0x18,
+	0xF5,
+	0x10,
+	0xC2,
+	0x8C,
+	0x53,
+	0x89,
+	0xF0,
+	0x43,
+	0x89,
+	0x01,
+	0x75,
+	0x8A,
+	0x40,
+	0x75,
+	0x8C,
+	0x7C,
+	0xD2,
+	0xA9,
+	0xD2,
+	0x8C,
+	0xD2,
+	0xAF,
+	0x22,
+	0x7E,
+	0x05,
+	0x7F,
+	0xC9,
+	0x12,
+	0x06,
+	0x8A,
+	0x7F,
+	0x08,
+	0x12,
+	0x0C,
+	0x6F,
+	0xEF,
+	0x54,
+	0x0E,
+	0x60,
+	0x07,
+	0x7E,
+	0x05,
+	0x7F,
+	0xE0,
+	0x12,
+	0x06,
+	0x8A,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x06,
+	0x5A,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x02,
+	0x06,
+	0x63,
+	0x7D,
+	0x00,
+	0x80,
+	0x0A,
+	0x7D,
+	0x01,
+	0x80,
+	0x06,
+	0x7D,
+	0x03,
+	0x80,
+	0x02,
+	0x7D,
+	0x04,
+	0xC2,
+	0xAF,
+	0x78,
+	0x83,
+	0xE2,
+	0xCD,
+	0xF2,
+	0x74,
+	0x80,
+	0x2F,
+	0xF8,
+	0xE2,
+	0x78,
+	0x03,
+	0xFF,
+	0xED,
+	0xF2,
+	0xD2,
+	0xAF,
+	0x22,
+	0x32,
+	0x8F,
+	0x4A,
+	0x80,
+	0x18,
+	0xE5,
+	0x4C,
+	0x60,
+	0x19,
+	0x7F,
+	0x25,
+	0x12,
+	0x0C,
+	0x77,
+	0xEF,
+	0x54,
+	0x10,
+	0xF5,
+	0x4B,
+	0xB5,
+	0x47,
+	0x04,
+	0x15,
+	0x4C,
+	0x80,
+	0xEB,
+	0x85,
+	0x4B,
+	0x47,
+	0x85,
+	0x4A,
+	0x4C,
+	0x80,
+	0xE3,
+	0x22,
+	0x8F,
+	0x4A,
+	0x80,
+	0x18,
+	0xE5,
+	0x4C,
+	0x60,
+	0x19,
+	0x7F,
+	0x7F,
+	0x12,
+	0x0C,
+	0x7B,
+	0xEF,
+	0x54,
+	0x04,
+	0xF5,
+	0x4B,
+	0xB5,
+	0x3D,
+	0x04,
+	0x15,
+	0x4C,
+	0x80,
+	0xEB,
+	0x85,
+	0x4B,
+	0x3D,
+	0x85,
+	0x4A,
+	0x4C,
+	0x80,
+	0xE3,
+	0x22,
+	0x7E,
+	0x06,
+	0x7F,
+	0x00,
+	0x12,
+	0x06,
+	0x8A,
+	0x7D,
+	0x04,
+	0x7F,
+	0x0A,
+	0x30,
+	0x01,
+	0x10,
+	0x12,
+	0x06,
+	0x63,
+	0x7D,
+	0x04,
+	0x7F,
+	0x5C,
+	0x12,
+	0x06,
+	0x6F,
+	0x7D,
+	0x01,
+	0x7F,
+	0x07,
+	0x80,
+	0x00,
+	0x12,
+	0x06,
+	0x4E,
+	0x22,
+	0xAD,
+	0x07,
+	0xAC,
+	0x06,
+	0xE4,
+	0x12,
+	0x04,
+	0x9C,
+	0xE4,
+	0xFB,
+	0xFA,
+	0x79,
+	0x20,
+	0x78,
+	0x40,
+	0x12,
+	0x03,
+	0xFA,
+	0x12,
+	0x04,
+	0xD5,
+	0x8F,
+	0x11,
+	0xE5,
+	0x11,
+	0x70,
+	0xFC,
+	0x22,
+	0x78,
+	0x7F,
+	0xE4,
+	0xF6,
+	0xD8,
+	0xFD,
+	0x75,
+	0x81,
+	0xA5,
+	0x02,
+	0x02,
+	0x64
+};
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/hdcp7036.car b/drivers/staging/emgd/emgd/pal/ch7036/hdcp7036.car
deleted file mode 100755
index efd9947..0000000
--- a/drivers/staging/emgd/emgd/pal/ch7036/hdcp7036.car
+++ /dev/null
@@ -1,6782 +0,0 @@
-unsigned char lhfm_array[]= {
-	0x02,
-	0x13,
-	0xCC,
-	0x02,
-	0x16,
-	0xFE,
-	0x01,
-	0x24,
-	0x00,
-	0x00,
-	0xFF,
-	0x02,
-	0x15,
-	0x4C,
-	0xA2,
-	0x04,
-	0x82,
-	0x12,
-	0x40,
-	0x03,
-	0x02,
-	0x05,
-	0xC4,
-	0xC2,
-	0x05,
-	0xE4,
-	0xF5,
-	0x5C,
-	0x12,
-	0x1A,
-	0x6D,
-	0x50,
-	0x05,
-	0xE5,
-	0x2B,
-	0x20,
-	0xE5,
-	0x11,
-	0x12,
-	0x1A,
-	0x33,
-	0x30,
-	0x03,
-	0x02,
-	0xC3,
-	0x22,
-	0x05,
-	0x5C,
-	0xE5,
-	0x5C,
-	0xC3,
-	0x94,
-	0x32,
-	0x40,
-	0xE5,
-	0xE5,
-	0x2B,
-	0x20,
-	0xE5,
-	0x05,
-	0x7F,
-	0x10,
-	0x02,
-	0x05,
-	0xBF,
-	0x7B,
-	0x02,
-	0x7D,
-	0x41,
-	0x12,
-	0x17,
-	0x8B,
-	0x85,
-	0x2B,
-	0x59,
-	0x85,
-	0x2C,
-	0x5A,
-	0xE5,
-	0x2B,
-	0x54,
-	0x7F,
-	0xF5,
-	0x5B,
-	0xE5,
-	0x2C,
-	0x20,
-	0xE3,
-	0x0C,
-	0xE5,
-	0x2B,
-	0x20,
-	0xE7,
-	0x07,
-	0xE5,
-	0x5B,
-	0xD3,
-	0x94,
-	0x09,
-	0x40,
-	0x0C,
-	0x7D,
-	0x01,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0x7F,
-	0x20,
-	0x02,
-	0x05,
-	0xBF,
-	0x7D,
-	0x08,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0xBD,
-	0x75,
-	0x5D,
-	0x74,
-	0xE4,
-	0xF5,
-	0x58,
-	0xE5,
-	0x5D,
-	0x25,
-	0x58,
-	0xF8,
-	0xE4,
-	0xF6,
-	0x05,
-	0x58,
-	0xE5,
-	0x58,
-	0xB4,
-	0x40,
-	0xF2,
-	0xE5,
-	0x5B,
-	0x75,
-	0xF0,
-	0x05,
-	0xA4,
-	0xF5,
-	0x5C,
-	0xE5,
-	0x5B,
-	0x60,
-	0x1C,
-	0xAB,
-	0x5C,
-	0x7D,
-	0x43,
-	0x7C,
-	0x00,
-	0x7F,
-	0x3A,
-	0x7E,
-	0x00,
-	0x12,
-	0x16,
-	0xA3,
-	0xAD,
-	0x5D,
-	0xE4,
-	0xFF,
-	0x12,
-	0x12,
-	0xAC,
-	0xEF,
-	0x60,
-	0x05,
-	0x7F,
-	0x40,
-	0x02,
-	0x05,
-	0xBF,
-	0xAF,
-	0x5C,
-	0x05,
-	0x5C,
-	0xE5,
-	0x5D,
-	0x2F,
-	0xF8,
-	0xA6,
-	0x59,
-	0xAF,
-	0x5C,
-	0x05,
-	0x5C,
-	0xE5,
-	0x5D,
-	0x2F,
-	0xF8,
-	0xA6,
-	0x5A,
-	0x75,
-	0x58,
-	0x21,
-	0xAF,
-	0x58,
-	0x12,
-	0x19,
-	0x8F,
-	0xAE,
-	0x5C,
-	0x05,
-	0x5C,
-	0xE5,
-	0x5D,
-	0x2E,
-	0xF8,
-	0xA6,
-	0x07,
-	0x15,
-	0x58,
-	0xE5,
-	0x58,
-	0xD3,
-	0x94,
-	0x19,
-	0x50,
-	0xE8,
-	0xE5,
-	0x5D,
-	0x25,
-	0x5C,
-	0xF8,
-	0x76,
-	0x80,
-	0x75,
-	0x5E,
-	0x00,
-	0x85,
-	0x5B,
-	0x5F,
-	0xAE,
-	0x5E,
-	0xAF,
-	0x5F,
-	0x7C,
-	0x00,
-	0x7D,
-	0x28,
-	0x12,
-	0x0E,
-	0x74,
-	0xEF,
-	0x24,
-	0x50,
-	0xF5,
-	0x5F,
-	0xE4,
-	0x3E,
-	0xF5,
-	0x5E,
-	0xFF,
-	0xE5,
-	0x5D,
-	0x24,
-	0x3E,
-	0xF8,
-	0xA6,
-	0x07,
-	0xE5,
-	0x5D,
-	0x24,
-	0x3F,
-	0xF8,
-	0xA6,
-	0x5F,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xFD,
-	0x67,
-	0x45,
-	0x23,
-	0x01,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xFD,
-	0xEF,
-	0xCD,
-	0xAB,
-	0x89,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xFD,
-	0x98,
-	0xBA,
-	0xDC,
-	0xFE,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xFD,
-	0x10,
-	0x32,
-	0x54,
-	0x76,
-	0x78,
-	0xD4,
-	0x12,
-	0x0E,
-	0xFD,
-	0xC3,
-	0xD2,
-	0xE1,
-	0xF0,
-	0xE4,
-	0xF5,
-	0x58,
-	0xE5,
-	0x58,
-	0x54,
-	0x0F,
-	0xF5,
-	0x5D,
-	0xE5,
-	0x58,
-	0xD3,
-	0x94,
-	0x13,
-	0x50,
-	0x5C,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xD8,
-	0x12,
-	0x0E,
-	0x86,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x5B,
-	0xFF,
-	0xEE,
-	0x5A,
-	0xFE,
-	0xED,
-	0x59,
-	0xFD,
-	0xEC,
-	0x58,
-	0xFC,
-	0xC0,
-	0x04,
-	0xC0,
-	0x05,
-	0xC0,
-	0x06,
-	0xC0,
-	0x07,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x5F,
-	0xFF,
-	0xEA,
-	0x5E,
-	0xFE,
-	0xE9,
-	0x5D,
-	0xFD,
-	0xE8,
-	0x5C,
-	0xFC,
-	0xD0,
-	0x03,
-	0xD0,
-	0x02,
-	0xD0,
-	0x01,
-	0xD0,
-	0x00,
-	0xEF,
-	0x6B,
-	0xFF,
-	0xEE,
-	0x6A,
-	0xFE,
-	0xED,
-	0x69,
-	0xFD,
-	0xEC,
-	0x68,
-	0xFC,
-	0x78,
-	0xBC,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC0,
-	0x12,
-	0x0E,
-	0xFD,
-	0x5A,
-	0x82,
-	0x79,
-	0x99,
-	0x02,
-	0x02,
-	0xBB,
-	0xE5,
-	0x58,
-	0xD3,
-	0x94,
-	0x27,
-	0x50,
-	0x38,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x6F,
-	0xFF,
-	0xEA,
-	0x6E,
-	0xFE,
-	0xE9,
-	0x6D,
-	0xFD,
-	0xE8,
-	0x6C,
-	0xFC,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x6B,
-	0xFF,
-	0xEE,
-	0x6A,
-	0xFE,
-	0xED,
-	0x69,
-	0xFD,
-	0xEC,
-	0x68,
-	0xFC,
-	0x78,
-	0xBC,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC0,
-	0x12,
-	0x0E,
-	0xFD,
-	0x6E,
-	0xD9,
-	0xEB,
-	0xA1,
-	0x02,
-	0x02,
-	0xBB,
-	0xE5,
-	0x58,
-	0xD3,
-	0x94,
-	0x3B,
-	0x40,
-	0x03,
-	0x02,
-	0x02,
-	0x7F,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x5F,
-	0xFF,
-	0xEA,
-	0x5E,
-	0xFE,
-	0xE9,
-	0x5D,
-	0xFD,
-	0xE8,
-	0x5C,
-	0xFC,
-	0xC0,
-	0x04,
-	0xC0,
-	0x05,
-	0xC0,
-	0x06,
-	0xC0,
-	0x07,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x5F,
-	0xFF,
-	0xEA,
-	0x5E,
-	0xFE,
-	0xE9,
-	0x5D,
-	0xFD,
-	0xE8,
-	0x5C,
-	0xFC,
-	0xD0,
-	0x03,
-	0xD0,
-	0x02,
-	0xD0,
-	0x01,
-	0xD0,
-	0x00,
-	0xEF,
-	0x6B,
-	0xFF,
-	0xEE,
-	0x6A,
-	0xFE,
-	0xED,
-	0x69,
-	0xFD,
-	0xEC,
-	0x68,
-	0xFC,
-	0xC0,
-	0x04,
-	0xC0,
-	0x05,
-	0xC0,
-	0x06,
-	0xC0,
-	0x07,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x5F,
-	0xFF,
-	0xEA,
-	0x5E,
-	0xFE,
-	0xE9,
-	0x5D,
-	0xFD,
-	0xE8,
-	0x5C,
-	0xFC,
-	0xD0,
-	0x03,
-	0xD0,
-	0x02,
-	0xD0,
-	0x01,
-	0xD0,
-	0x00,
-	0xEB,
-	0x6F,
-	0xFF,
-	0xEA,
-	0x6E,
-	0xFE,
-	0xE9,
-	0x6D,
-	0xFD,
-	0xE8,
-	0x6C,
-	0xFC,
-	0x78,
-	0xBC,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC0,
-	0x12,
-	0x0E,
-	0xFD,
-	0x8F,
-	0x1B,
-	0xBC,
-	0xDC,
-	0x80,
-	0x3C,
-	0xE5,
-	0x58,
-	0xC3,
-	0x94,
-	0x3C,
-	0x40,
-	0x35,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x6F,
-	0xFF,
-	0xEA,
-	0x6E,
-	0xFE,
-	0xE9,
-	0x6D,
-	0xFD,
-	0xE8,
-	0x6C,
-	0xFC,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x6B,
-	0xFF,
-	0xEE,
-	0x6A,
-	0xFE,
-	0xED,
-	0x69,
-	0xFD,
-	0xEC,
-	0x68,
-	0xFC,
-	0x78,
-	0xBC,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC0,
-	0x12,
-	0x0E,
-	0xFD,
-	0xCA,
-	0x62,
-	0xC1,
-	0xD6,
-	0xE5,
-	0x58,
-	0xC3,
-	0x94,
-	0x10,
-	0x50,
-	0x03,
-	0x02,
-	0x03,
-	0x66,
-	0xE5,
-	0x5D,
-	0x24,
-	0x08,
-	0x54,
-	0x0F,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x24,
-	0x74,
-	0xF8,
-	0x12,
-	0x0E,
-	0xD8,
-	0xE5,
-	0x5D,
-	0x24,
-	0x0D,
-	0x54,
-	0x0F,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x24,
-	0x74,
-	0xF8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEB,
-	0x6F,
-	0xFF,
-	0xEA,
-	0x6E,
-	0xFE,
-	0xE9,
-	0x6D,
-	0xFD,
-	0xE8,
-	0x6C,
-	0xFC,
-	0xE5,
-	0x5D,
-	0x24,
-	0x02,
-	0x54,
-	0x0F,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x24,
-	0x74,
-	0xF8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x6B,
-	0xFF,
-	0xEE,
-	0x6A,
-	0xFE,
-	0xED,
-	0x69,
-	0xFD,
-	0xEC,
-	0x68,
-	0xFC,
-	0xE5,
-	0x5D,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x24,
-	0x74,
-	0xF8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x6B,
-	0xFF,
-	0xEE,
-	0x6A,
-	0xFE,
-	0xED,
-	0x69,
-	0xFD,
-	0xEC,
-	0x68,
-	0xFC,
-	0x78,
-	0xB4,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xB4,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0x01,
-	0x12,
-	0x0E,
-	0xC5,
-	0xC0,
-	0x04,
-	0xC0,
-	0x05,
-	0xC0,
-	0x06,
-	0xC0,
-	0x07,
-	0x78,
-	0xB4,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0x1F,
-	0x12,
-	0x0E,
-	0xB2,
-	0xD0,
-	0x03,
-	0xD0,
-	0x02,
-	0xD0,
-	0x01,
-	0xD0,
-	0x00,
-	0xEF,
-	0x4B,
-	0xFF,
-	0xEE,
-	0x4A,
-	0xFE,
-	0xED,
-	0x49,
-	0xFD,
-	0xEC,
-	0x48,
-	0xFC,
-	0xE5,
-	0x5D,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x24,
-	0x74,
-	0xF8,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0x05,
-	0x12,
-	0x0E,
-	0xC5,
-	0xC0,
-	0x04,
-	0xC0,
-	0x05,
-	0xC0,
-	0x06,
-	0xC0,
-	0x07,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0x1B,
-	0x12,
-	0x0E,
-	0xB2,
-	0xD0,
-	0x03,
-	0xD0,
-	0x02,
-	0xD0,
-	0x01,
-	0xD0,
-	0x00,
-	0xEF,
-	0x4B,
-	0xFF,
-	0xEE,
-	0x4A,
-	0xFE,
-	0xED,
-	0x49,
-	0xFD,
-	0xEC,
-	0x48,
-	0xFC,
-	0x78,
-	0xBC,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x2B,
-	0xFF,
-	0xEE,
-	0x3A,
-	0xFE,
-	0xED,
-	0x39,
-	0xFD,
-	0xEC,
-	0x38,
-	0xFC,
-	0x78,
-	0xD4,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x2B,
-	0xFF,
-	0xEE,
-	0x3A,
-	0xFE,
-	0xED,
-	0x39,
-	0xFD,
-	0xEC,
-	0x38,
-	0xFC,
-	0x78,
-	0xC0,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x2B,
-	0xFF,
-	0xEE,
-	0x3A,
-	0xFE,
-	0xED,
-	0x39,
-	0xFD,
-	0xEC,
-	0x38,
-	0xFC,
-	0xE5,
-	0x5D,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x24,
-	0x74,
-	0xF8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xEF,
-	0x2B,
-	0xFF,
-	0xEE,
-	0x3A,
-	0xFE,
-	0xED,
-	0x39,
-	0xFD,
-	0xEC,
-	0x38,
-	0xFC,
-	0x78,
-	0xB8,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xD4,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0x1E,
-	0x12,
-	0x0E,
-	0xC5,
-	0xC0,
-	0x04,
-	0xC0,
-	0x05,
-	0xC0,
-	0x06,
-	0xC0,
-	0x07,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0x02,
-	0x12,
-	0x0E,
-	0xB2,
-	0xD0,
-	0x03,
-	0xD0,
-	0x02,
-	0xD0,
-	0x01,
-	0xD0,
-	0x00,
-	0xEF,
-	0x4B,
-	0xFF,
-	0xEE,
-	0x4A,
-	0xFE,
-	0xED,
-	0x49,
-	0xFD,
-	0xEC,
-	0x48,
-	0xFC,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xB8,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xF1,
-	0x05,
-	0x58,
-	0xE5,
-	0x58,
-	0x64,
-	0x50,
-	0x60,
-	0x03,
-	0x02,
-	0x01,
-	0x43,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xD8,
-	0xEF,
-	0x24,
-	0x01,
-	0xFF,
-	0xEE,
-	0x34,
-	0x23,
-	0xFE,
-	0xED,
-	0x34,
-	0x45,
-	0xFD,
-	0xEC,
-	0x34,
-	0x67,
-	0xFC,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xD8,
-	0xEF,
-	0x24,
-	0x89,
-	0xFF,
-	0xEE,
-	0x34,
-	0xAB,
-	0xFE,
-	0xED,
-	0x34,
-	0xCD,
-	0xFD,
-	0xEC,
-	0x34,
-	0xEF,
-	0xFC,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xD8,
-	0xEF,
-	0x24,
-	0xFE,
-	0xFF,
-	0xEE,
-	0x34,
-	0xDC,
-	0xFE,
-	0xED,
-	0x34,
-	0xBA,
-	0xFD,
-	0xEC,
-	0x34,
-	0x98,
-	0xFC,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xD8,
-	0xEF,
-	0x24,
-	0x76,
-	0xFF,
-	0xEE,
-	0x34,
-	0x54,
-	0xFE,
-	0xED,
-	0x34,
-	0x32,
-	0xFD,
-	0xEC,
-	0x34,
-	0x10,
-	0xFC,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xF1,
-	0x78,
-	0xD4,
-	0x12,
-	0x0E,
-	0xD8,
-	0xEF,
-	0x24,
-	0xF0,
-	0xFF,
-	0xEE,
-	0x34,
-	0xE1,
-	0xFE,
-	0xED,
-	0x34,
-	0xD2,
-	0xFD,
-	0xEC,
-	0x34,
-	0xC3,
-	0xFC,
-	0x78,
-	0xD4,
-	0x12,
-	0x0E,
-	0xF1,
-	0x7D,
-	0x20,
-	0x12,
-	0x17,
-	0x89,
-	0x78,
-	0xB0,
-	0xA6,
-	0x2E,
-	0x08,
-	0xA6,
-	0x2D,
-	0x08,
-	0xA6,
-	0x2C,
-	0x08,
-	0xA6,
-	0x2B,
-	0x7D,
-	0x24,
-	0x12,
-	0x17,
-	0x89,
-	0x78,
-	0xAC,
-	0xA6,
-	0x2E,
-	0x08,
-	0xA6,
-	0x2D,
-	0x08,
-	0xA6,
-	0x2C,
-	0x08,
-	0xA6,
-	0x2B,
-	0x7B,
-	0x04,
-	0x7D,
-	0x28,
-	0x12,
-	0x17,
-	0x8B,
-	0x78,
-	0xA8,
-	0xA6,
-	0x2E,
-	0x08,
-	0xA6,
-	0x2D,
-	0x08,
-	0xA6,
-	0x2C,
-	0x08,
-	0xA6,
-	0x2B,
-	0x7B,
-	0x04,
-	0x7D,
-	0x2C,
-	0x12,
-	0x17,
-	0x8B,
-	0x78,
-	0xA4,
-	0xA6,
-	0x2E,
-	0x08,
-	0xA6,
-	0x2D,
-	0x08,
-	0xA6,
-	0x2C,
-	0x08,
-	0xA6,
-	0x2B,
-	0x7B,
-	0x04,
-	0x7D,
-	0x30,
-	0x12,
-	0x17,
-	0x8B,
-	0x78,
-	0xA0,
-	0xA6,
-	0x2E,
-	0x08,
-	0xA6,
-	0x2D,
-	0x08,
-	0xA6,
-	0x2C,
-	0x08,
-	0xA6,
-	0x2B,
-	0x78,
-	0xAC,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC8,
-	0x12,
-	0x0E,
-	0xE4,
-	0xC3,
-	0x12,
-	0x0E,
-	0xA1,
-	0x70,
-	0x06,
-	0x7F,
-	0x01,
-	0xC0,
-	0x07,
-	0x80,
-	0x04,
-	0x7F,
-	0x00,
-	0xC0,
-	0x07,
-	0x78,
-	0xB0,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xC4,
-	0x12,
-	0x0E,
-	0xE4,
-	0xC3,
-	0x12,
-	0x0E,
-	0xA1,
-	0x70,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xD0,
-	0xE0,
-	0x5E,
-	0xFF,
-	0xC0,
-	0x07,
-	0x78,
-	0xA8,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xCC,
-	0x12,
-	0x0E,
-	0xE4,
-	0xC3,
-	0x12,
-	0x0E,
-	0xA1,
-	0x70,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xD0,
-	0xE0,
-	0x5E,
-	0xFF,
-	0xC0,
-	0x07,
-	0x78,
-	0xA4,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xD0,
-	0x12,
-	0x0E,
-	0xE4,
-	0xC3,
-	0x12,
-	0x0E,
-	0xA1,
-	0x70,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xD0,
-	0xE0,
-	0x5E,
-	0xFF,
-	0xC0,
-	0x07,
-	0x78,
-	0xA0,
-	0x12,
-	0x0E,
-	0xD8,
-	0x78,
-	0xD4,
-	0x12,
-	0x0E,
-	0xE4,
-	0xC3,
-	0x12,
-	0x0E,
-	0xA1,
-	0x70,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xD0,
-	0xE0,
-	0x5E,
-	0x60,
-	0x04,
-	0xD2,
-	0x05,
-	0x80,
-	0x07,
-	0x7F,
-	0x40,
-	0x12,
-	0x1A,
-	0x75,
-	0xC3,
-	0x22,
-	0xD3,
-	0x22,
-	0x7D,
-	0x01,
-	0x7F,
-	0x0F,
-	0x12,
-	0x11,
-	0x9E,
-	0xD2,
-	0x1B,
-	0x12,
-	0x19,
-	0xAA,
-	0x7F,
-	0xC8,
-	0x7E,
-	0x00,
-	0x12,
-	0x1A,
-	0x37,
-	0x12,
-	0x1A,
-	0x6D,
-	0x40,
-	0x05,
-	0x7F,
-	0x04,
-	0x02,
-	0x08,
-	0x6B,
-	0x7F,
-	0x0D,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x58,
-	0xE5,
-	0x2B,
-	0x30,
-	0xE6,
-	0x0C,
-	0xD2,
-	0x12,
-	0x43,
-	0x58,
-	0x04,
-	0x7F,
-	0x02,
-	0x12,
-	0x1A,
-	0x75,
-	0x80,
-	0x05,
-	0xC2,
-	0x12,
-	0x53,
-	0x58,
-	0xFB,
-	0xAD,
-	0x58,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0x72,
-	0x7F,
-	0x0F,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x54,
-	0xEF,
-	0xF5,
-	0x58,
-	0xE5,
-	0x2B,
-	0x20,
-	0xE1,
-	0x09,
-	0x7F,
-	0x0A,
-	0x12,
-	0x19,
-	0x87,
-	0xEF,
-	0x30,
-	0xE2,
-	0x03,
-	0x43,
-	0x58,
-	0x10,
-	0xAD,
-	0x58,
-	0x7F,
-	0x0F,
-	0x12,
-	0x11,
-	0x72,
-	0xE4,
-	0xF5,
-	0x4A,
-	0x7B,
-	0x01,
-	0x7D,
-	0x15,
-	0xFC,
-	0x7F,
-	0x3A,
-	0x12,
-	0x18,
-	0xE1,
-	0x75,
-	0x59,
-	0x02,
-	0xC2,
-	0x19,
-	0xAF,
-	0x59,
-	0x15,
-	0x59,
-	0xEF,
-	0x60,
-	0x16,
-	0x7B,
-	0x05,
-	0xE4,
-	0xFD,
-	0xFC,
-	0x7F,
-	0x3A,
-	0x12,
-	0x17,
-	0x8F,
-	0x50,
-	0xED,
-	0x7F,
-	0x2B,
-	0x12,
-	0x19,
-	0x0D,
-	0x92,
-	0x19,
-	0x30,
-	0x19,
-	0xE3,
-	0x85,
-	0x2B,
-	0x44,
-	0x85,
-	0x2C,
-	0x45,
-	0x85,
-	0x2D,
-	0x46,
-	0x85,
-	0x2E,
-	0x47,
-	0x85,
-	0x2F,
-	0x48,
-	0x7F,
-	0x10,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x58,
-	0x30,
-	0x19,
-	0x09,
-	0x7D,
-	0x10,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0x9E,
-	0x80,
-	0x0C,
-	0x7D,
-	0x10,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0x7F,
-	0x08,
-	0x02,
-	0x08,
-	0x6B,
-	0x7D,
-	0x10,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0xBD,
-	0x75,
-	0x59,
-	0xFA,
-	0xAF,
-	0x59,
-	0x15,
-	0x59,
-	0xEF,
-	0x60,
-	0x09,
-	0x7F,
-	0x11,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x30,
-	0xE7,
-	0xF0,
-	0xE5,
-	0x59,
-	0x70,
-	0x05,
-	0x7F,
-	0x04,
-	0x12,
-	0x1A,
-	0x75,
-	0x7F,
-	0x12,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x51,
-	0x7F,
-	0x13,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x50,
-	0x7F,
-	0x14,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x4F,
-	0x7F,
-	0x15,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x4E,
-	0x7F,
-	0x16,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x4D,
-	0x7F,
-	0x17,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x4C,
-	0x7F,
-	0x18,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x4B,
-	0x7F,
-	0x19,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x4A,
-	0x7B,
-	0x08,
-	0x7D,
-	0x18,
-	0x7C,
-	0x00,
-	0x7F,
-	0x3A,
-	0x12,
-	0x18,
-	0xE1,
-	0x85,
-	0x3F,
-	0x4A,
-	0x85,
-	0x40,
-	0x4B,
-	0x85,
-	0x41,
-	0x4C,
-	0x85,
-	0x42,
-	0x4D,
-	0x85,
-	0x43,
-	0x4E,
-	0x7B,
-	0x05,
-	0x7D,
-	0x10,
-	0x7C,
-	0x00,
-	0x7F,
-	0x3A,
-	0x12,
-	0x18,
-	0xE1,
-	0x7D,
-	0x01,
-	0x7F,
-	0x09,
-	0x7E,
-	0x00,
-	0x12,
-	0x18,
-	0xB5,
-	0x53,
-	0x2B,
-	0xE0,
-	0xE5,
-	0x2B,
-	0x13,
-	0x13,
-	0x13,
-	0x54,
-	0x1F,
-	0xF5,
-	0x2B,
-	0x7F,
-	0x17,
-	0x12,
-	0x19,
-	0x93,
-	0x8F,
-	0x58,
-	0xE5,
-	0x2B,
-	0x42,
-	0x58,
-	0xAD,
-	0x58,
-	0x7F,
-	0x17,
-	0x12,
-	0x11,
-	0x76,
-	0xE4,
-	0xF5,
-	0x59,
-	0x74,
-	0x44,
-	0x25,
-	0x59,
-	0xF8,
-	0xE6,
-	0xF5,
-	0x5D,
-	0xE4,
-	0xF5,
-	0x5A,
-	0xE5,
-	0x5D,
-	0x7D,
-	0x80,
-	0x7F,
-	0x17,
-	0x30,
-	0xE0,
-	0x05,
-	0x12,
-	0x11,
-	0xB7,
-	0x80,
-	0x03,
-	0x12,
-	0x11,
-	0xA2,
-	0xE5,
-	0x5D,
-	0xC3,
-	0x13,
-	0xF5,
-	0x5D,
-	0xE5,
-	0x59,
-	0x75,
-	0xF0,
-	0x08,
-	0xA4,
-	0x7C,
-	0x00,
-	0x25,
-	0x5A,
-	0xFF,
-	0xEC,
-	0x35,
-	0xF0,
-	0xFE,
-	0xEF,
-	0x78,
-	0x03,
-	0xC3,
-	0x33,
-	0xCE,
-	0x33,
-	0xCE,
-	0xD8,
-	0xF9,
-	0x24,
-	0x10,
-	0xF5,
-	0x5C,
-	0xE4,
-	0x3E,
-	0xF5,
-	0x5B,
-	0x7D,
-	0x08,
-	0xAF,
-	0x5C,
-	0xFE,
-	0x12,
-	0x18,
-	0xB5,
-	0xAD,
-	0x2B,
-	0x7F,
-	0x16,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x2C,
-	0x7F,
-	0x15,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x2D,
-	0x7F,
-	0x14,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x2E,
-	0x7F,
-	0x13,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x2F,
-	0x7F,
-	0x12,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x30,
-	0x7F,
-	0x11,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x31,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x32,
-	0x7F,
-	0x0F,
-	0x12,
-	0x11,
-	0x76,
-	0xE5,
-	0x59,
-	0x70,
-	0x04,
-	0xE5,
-	0x5A,
-	0x60,
-	0x04,
-	0x7D,
-	0x20,
-	0x80,
-	0x02,
-	0x7D,
-	0x40,
-	0x7F,
-	0x17,
-	0x12,
-	0x11,
-	0xC1,
-	0x05,
-	0x5A,
-	0xE5,
-	0x5A,
-	0xD3,
-	0x94,
-	0x07,
-	0x50,
-	0x03,
-	0x02,
-	0x07,
-	0x3B,
-	0x05,
-	0x59,
-	0xE5,
-	0x59,
-	0xD3,
-	0x94,
-	0x04,
-	0x50,
-	0x03,
-	0x02,
-	0x07,
-	0x30,
-	0x7D,
-	0x08,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0x9E,
-	0x7D,
-	0x40,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0x9E,
-	0x7D,
-	0x08,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0x7D,
-	0x40,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0xB3,
-	0x7D,
-	0x08,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0x9E,
-	0x7D,
-	0x40,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0x9E,
-	0x12,
-	0x1A,
-	0x33,
-	0x30,
-	0x03,
-	0x02,
-	0xC3,
-	0x22,
-	0x12,
-	0x1A,
-	0x53,
-	0x75,
-	0x59,
-	0xFA,
-	0xAF,
-	0x59,
-	0x15,
-	0x59,
-	0xEF,
-	0x60,
-	0x09,
-	0x7F,
-	0x25,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x30,
-	0xE7,
-	0xF0,
-	0xE5,
-	0x59,
-	0x70,
-	0x05,
-	0x7F,
-	0x04,
-	0x12,
-	0x1A,
-	0x75,
-	0x7F,
-	0x23,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x2D,
-	0x7F,
-	0x24,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x2E,
-	0xE5,
-	0x2E,
-	0xB5,
-	0x2B,
-	0x04,
-	0x7F,
-	0x01,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0xE5,
-	0x2D,
-	0xB5,
-	0x2C,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xEE,
-	0x5F,
-	0x60,
-	0x0B,
-	0xD2,
-	0x04,
-	0x7D,
-	0x22,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0xBD,
-	0x80,
-	0x0E,
-	0x7D,
-	0x01,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0x7F,
-	0x80,
-	0x12,
-	0x1A,
-	0x75,
-	0xC3,
-	0x22,
-	0xD2,
-	0x05,
-	0xD3,
-	0x22,
-	0x75,
-	0x5E,
-	0x74,
-	0xE4,
-	0xF5,
-	0x28,
-	0xF5,
-	0x29,
-	0xC2,
-	0x01,
-	0xF5,
-	0x27,
-	0xF5,
-	0x2A,
-	0xFF,
-	0x12,
-	0x16,
-	0x36,
-	0x40,
-	0x01,
-	0x22,
-	0xE5,
-	0x5E,
-	0x24,
-	0x3E,
-	0xF8,
-	0xE6,
-	0xF5,
-	0x58,
-	0x7B,
-	0x02,
-	0x7D,
-	0x23,
-	0xE4,
-	0xFF,
-	0x12,
-	0x15,
-	0xC8,
-	0x40,
-	0x01,
-	0x22,
-	0xA8,
-	0x5E,
-	0xE6,
-	0x30,
-	0xE0,
-	0x03,
-	0x43,
-	0x2A,
-	0x01,
-	0xE8,
-	0x04,
-	0xF8,
-	0xE6,
-	0xFF,
-	0x54,
-	0x0E,
-	0x60,
-	0x03,
-	0x43,
-	0x2A,
-	0x02,
-	0xEF,
-	0x30,
-	0xE0,
-	0x03,
-	0x43,
-	0x2A,
-	0x04,
-	0x75,
-	0x59,
-	0x26,
-	0xE4,
-	0xF5,
-	0x5D,
-	0x7B,
-	0x02,
-	0xAD,
-	0x59,
-	0xE4,
-	0xFF,
-	0x12,
-	0x15,
-	0xC8,
-	0x50,
-	0x36,
-	0x05,
-	0x59,
-	0x05,
-	0x59,
-	0xA8,
-	0x5E,
-	0xE6,
-	0xFF,
-	0xB4,
-	0x01,
-	0x08,
-	0xE8,
-	0x04,
-	0xF8,
-	0xE6,
-	0x64,
-	0x01,
-	0x60,
-	0x23,
-	0xE5,
-	0x5E,
-	0x04,
-	0xF8,
-	0x74,
-	0xC0,
-	0x56,
-	0xF6,
-	0xEF,
-	0xB4,
-	0x81,
-	0x09,
-	0xE5,
-	0x5E,
-	0x04,
-	0xF8,
-	0x76,
-	0x80,
-	0x43,
-	0x2A,
-	0x04,
-	0xA8,
-	0x5E,
-	0xE6,
-	0xB4,
-	0xA9,
-	0x08,
-	0xE8,
-	0x04,
-	0xF8,
-	0x76,
-	0x40,
-	0x43,
-	0x2A,
-	0x10,
-	0x05,
-	0x5D,
-	0xE5,
-	0x5D,
-	0xC3,
-	0x94,
-	0x08,
-	0x40,
-	0xB6,
-	0x7B,
-	0x06,
-	0x7D,
-	0x38,
-	0xE4,
-	0xFF,
-	0x12,
-	0x15,
-	0xC8,
-	0x40,
-	0x03,
-	0x02,
-	0x09,
-	0x96,
-	0xE5,
-	0x5E,
-	0x24,
-	0x02,
-	0xF8,
-	0xE6,
-	0x54,
-	0xF0,
-	0xFF,
-	0xE5,
-	0x5E,
-	0x04,
-	0xF8,
-	0xA6,
-	0x07,
-	0xE5,
-	0x5E,
-	0x24,
-	0x03,
-	0xF8,
-	0xE6,
-	0xFF,
-	0xE5,
-	0x5E,
-	0x24,
-	0x02,
-	0xF8,
-	0xA6,
-	0x07,
-	0xE5,
-	0x5E,
-	0x24,
-	0x05,
-	0xF8,
-	0xE6,
-	0x54,
-	0xF0,
-	0xFF,
-	0xE5,
-	0x5E,
-	0x24,
-	0x03,
-	0xF8,
-	0xA6,
-	0x07,
-	0xE4,
-	0xF5,
-	0x5D,
-	0xE4,
-	0xF5,
-	0x5A,
-	0xE5,
-	0x5D,
-	0x75,
-	0xF0,
-	0x05,
-	0xA4,
-	0x24,
-	0x02,
-	0xF5,
-	0x82,
-	0xE4,
-	0x34,
-	0x11,
-	0xF5,
-	0x83,
-	0xE5,
-	0x82,
-	0x25,
-	0x5A,
-	0xF5,
-	0x82,
-	0xE4,
-	0x35,
-	0x83,
-	0xF5,
-	0x83,
-	0xE4,
-	0x93,
-	0xFF,
-	0xE5,
-	0x5E,
-	0x25,
-	0x5A,
-	0xF8,
-	0xE6,
-	0xB5,
-	0x07,
-	0x07,
-	0x05,
-	0x5A,
-	0xE5,
-	0x5A,
-	0xB4,
-	0x04,
-	0xD3,
-	0xE5,
-	0x5A,
-	0xB4,
-	0x04,
-	0x13,
-	0xE5,
-	0x5D,
-	0x75,
-	0xF0,
-	0x05,
-	0xA4,
-	0x24,
-	0x07,
-	0xF5,
-	0x82,
-	0xE4,
-	0x34,
-	0x11,
-	0xF5,
-	0x83,
-	0xE4,
-	0x93,
-	0x42,
-	0x2A,
-	0x05,
-	0x5D,
-	0xE5,
-	0x5D,
-	0xB4,
-	0x03,
-	0xB1,
-	0xD2,
-	0x08,
-	0xE5,
-	0x58,
-	0x70,
-	0x02,
-	0xC3,
-	0x22,
-	0x75,
-	0x5D,
-	0x01,
-	0xE5,
-	0x5D,
-	0xD3,
-	0x95,
-	0x58,
-	0x40,
-	0x03,
-	0x02,
-	0x0A,
-	0xC7,
-	0xE5,
-	0x5D,
-	0x30,
-	0xE0,
-	0x04,
-	0x7F,
-	0x80,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0x8F,
-	0x5F,
-	0xAF,
-	0x5D,
-	0x12,
-	0x16,
-	0x36,
-	0x40,
-	0x01,
-	0x22,
-	0xE5,
-	0x5D,
-	0xC3,
-	0x13,
-	0xF5,
-	0x5C,
-	0x7B,
-	0x05,
-	0xAD,
-	0x5F,
-	0xFF,
-	0x12,
-	0x15,
-	0xC8,
-	0x40,
-	0x01,
-	0x22,
-	0xA8,
-	0x5E,
-	0xE6,
-	0x64,
-	0x02,
-	0x60,
-	0x03,
-	0x02,
-	0x0A,
-	0xC2,
-	0xE8,
-	0x04,
-	0xF8,
-	0xE6,
-	0x64,
-	0x03,
-	0x60,
-	0x03,
-	0x02,
-	0x0A,
-	0xC2,
-	0xE5,
-	0x5E,
-	0x24,
-	0x02,
-	0xF8,
-	0xE6,
-	0xFF,
-	0xD3,
-	0x94,
-	0x04,
-	0x50,
-	0x03,
-	0x02,
-	0x0A,
-	0xC2,
-	0x8F,
-	0x59,
-	0xE5,
-	0x5E,
-	0x24,
-	0x04,
-	0xF8,
-	0xE6,
-	0xF5,
-	0x5A,
-	0x75,
-	0x5B,
-	0x04,
-	0xE5,
-	0x5A,
-	0x54,
-	0xE0,
-	0x64,
-	0x60,
-	0x70,
-	0x37,
-	0xE5,
-	0x5B,
-	0x7B,
-	0x06,
-	0x12,
-	0x15,
-	0xC3,
-	0x40,
-	0x01,
-	0x22,
-	0xE5,
-	0x5E,
-	0x04,
-	0xF8,
-	0xE6,
-	0x64,
-	0x03,
-	0x70,
-	0x24,
-	0xE5,
-	0x5E,
-	0x24,
-	0x02,
-	0xF8,
-	0xE6,
-	0x64,
-	0x0C,
-	0x70,
-	0x1A,
-	0xE5,
-	0x5E,
-	0x24,
-	0x03,
-	0xF8,
-	0xE6,
-	0x70,
-	0x12,
-	0xE5,
-	0x5E,
-	0x24,
-	0x04,
-	0xF8,
-	0xE6,
-	0xF5,
-	0x28,
-	0xE5,
-	0x5E,
-	0x24,
-	0x05,
-	0xF8,
-	0xE6,
-	0xF5,
-	0x29,
-	0xD2,
-	0x01,
-	0xE5,
-	0x5A,
-	0x54,
-	0xE0,
-	0x64,
-	0x40,
-	0x70,
-	0x59,
-	0xE5,
-	0x5A,
-	0x54,
-	0x1F,
-	0xF5,
-	0x60,
-	0xE5,
-	0x5B,
-	0x25,
-	0x5F,
-	0x04,
-	0xFD,
-	0xAB,
-	0x60,
-	0xAF,
-	0x5C,
-	0x12,
-	0x15,
-	0xC8,
-	0x50,
-	0x64,
-	0xE4,
-	0xF5,
-	0x61,
-	0xE5,
-	0x61,
-	0xC3,
-	0x95,
-	0x60,
-	0x50,
-	0x3A,
-	0xE4,
-	0xF5,
-	0x62,
-	0xE5,
-	0x5E,
-	0x25,
-	0x61,
-	0xF8,
-	0xE6,
-	0x54,
-	0x7F,
-	0xFF,
-	0xE5,
-	0x62,
-	0x25,
-	0xE0,
-	0x24,
-	0xEE,
-	0xF5,
-	0x82,
-	0xE4,
-	0x34,
-	0x10,
-	0xF5,
-	0x83,
-	0xE4,
-	0x93,
-	0xB5,
-	0x07,
-	0x11,
-	0xE5,
-	0x62,
-	0x25,
-	0xE0,
-	0x24,
-	0xEF,
-	0xF5,
-	0x82,
-	0xE4,
-	0x34,
-	0x10,
-	0xF5,
-	0x83,
-	0xE4,
-	0x93,
-	0x42,
-	0x27,
-	0x05,
-	0x62,
-	0xE5,
-	0x62,
-	0xB4,
-	0x0A,
-	0xCD,
-	0x05,
-	0x61,
-	0x80,
-	0xBF,
-	0xE5,
-	0x5A,
-	0x54,
-	0x1F,
-	0x25,
-	0x5B,
-	0x04,
-	0xF5,
-	0x5B,
-	0x7B,
-	0x01,
-	0x12,
-	0x15,
-	0xC3,
-	0x40,
-	0x01,
-	0x22,
-	0xA8,
-	0x5E,
-	0xE6,
-	0xF5,
-	0x5A,
-	0xE5,
-	0x5B,
-	0xC3,
-	0x95,
-	0x59,
-	0x50,
-	0x03,
-	0x02,
-	0x0A,
-	0x02,
-	0x05,
-	0x5D,
-	0x02,
-	0x09,
-	0xA1,
-	0xA2,
-	0x01,
-	0x22,
-	0xE4,
-	0xF5,
-	0xA8,
-	0xF5,
-	0xA0,
-	0x75,
-	0x90,
-	0xC0,
-	0xD2,
-	0x8A,
-	0xD2,
-	0x88,
-	0xD2,
-	0xA8,
-	0xD2,
-	0xB8,
-	0x7D,
-	0x40,
-	0x7F,
-	0x4F,
-	0x12,
-	0x11,
-	0xAB,
-	0xC2,
-	0x15,
-	0xC2,
-	0x08,
-	0xC2,
-	0x0B,
-	0xC2,
-	0x0E,
-	0xC2,
-	0x02,
-	0xC2,
-	0x13,
-	0xC2,
-	0x06,
-	0xC2,
-	0x17,
-	0xC2,
-	0x03,
-	0xE4,
-	0xF5,
-	0x55,
-	0xD2,
-	0x10,
-	0xD2,
-	0x00,
-	0xD2,
-	0x0F,
-	0xD2,
-	0x14,
-	0xC2,
-	0x09,
-	0xC2,
-	0x0C,
-	0xC2,
-	0x11,
-	0x7E,
-	0x10,
-	0x7F,
-	0xC9,
-	0x12,
-	0x11,
-	0xD2,
-	0x7F,
-	0x0A,
-	0x12,
-	0x19,
-	0xEF,
-	0x12,
-	0x12,
-	0x0E,
-	0x7D,
-	0x06,
-	0x7F,
-	0x0A,
-	0x7E,
-	0x00,
-	0x12,
-	0x18,
-	0xB5,
-	0xE5,
-	0x30,
-	0x25,
-	0xE0,
-	0x25,
-	0xE0,
-	0x54,
-	0xF8,
-	0xFF,
-	0xE5,
-	0x2F,
-	0xC4,
-	0x13,
-	0x54,
-	0x07,
-	0x2F,
-	0xF5,
-	0x43,
-	0xE5,
-	0x2F,
-	0x33,
-	0x33,
-	0x33,
-	0x54,
-	0xF0,
-	0xFF,
-	0xE5,
-	0x2E,
-	0xC4,
-	0x54,
-	0x0F,
-	0x2F,
-	0xF5,
-	0x42,
-	0xE5,
-	0x2E,
-	0xC4,
-	0x54,
-	0xE0,
-	0xFF,
-	0xE5,
-	0x2D,
-	0x13,
-	0x13,
-	0x13,
-	0x54,
-	0x1F,
-	0x2F,
-	0xF5,
-	0x41,
-	0xE5,
-	0x2D,
-	0xC4,
-	0x33,
-	0x54,
-	0xC0,
-	0xFF,
-	0xE5,
-	0x2C,
-	0x13,
-	0x13,
-	0x54,
-	0x3F,
-	0x2F,
-	0xF5,
-	0x40,
-	0xE5,
-	0x2C,
-	0xC4,
-	0x33,
-	0x33,
-	0x54,
-	0x80,
-	0xFF,
-	0xE5,
-	0x2B,
-	0xC3,
-	0x13,
-	0x2F,
-	0xF5,
-	0x3F,
-	0x20,
-	0x0E,
-	0x08,
-	0x7F,
-	0x3F,
-	0x12,
-	0x19,
-	0x0D,
-	0xB3,
-	0x92,
-	0x0E,
-	0x30,
-	0x0E,
-	0x05,
-	0x7F,
-	0x08,
-	0x12,
-	0x1A,
-	0x75,
-	0x75,
-	0x15,
-	0x19,
-	0x75,
-	0x16,
-	0x19,
-	0x75,
-	0x17,
-	0x0C,
-	0x12,
-	0x19,
-	0x61,
-	0x7F,
-	0x0A,
-	0x12,
-	0x19,
-	0xCD,
-	0xE5,
-	0x55,
-	0x24,
-	0xFF,
-	0x92,
-	0x09,
-	0x7D,
-	0xC0,
-	0x7F,
-	0x6E,
-	0x12,
-	0x11,
-	0xBD,
-	0xAF,
-	0x55,
-	0x12,
-	0x19,
-	0x39,
-	0xC2,
-	0x0A,
-	0x7D,
-	0x40,
-	0x7F,
-	0x4F,
-	0x12,
-	0x11,
-	0x96,
-	0x75,
-	0x25,
-	0x00,
-	0x75,
-	0x26,
-	0x01,
-	0xE4,
-	0xF5,
-	0x54,
-	0x12,
-	0x0F,
-	0x16,
-	0x30,
-	0x15,
-	0x05,
-	0x7F,
-	0xFF,
-	0x12,
-	0x14,
-	0xD3,
-	0x30,
-	0x0B,
-	0x30,
-	0x20,
-	0x08,
-	0x0C,
-	0x7F,
-	0x25,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x30,
-	0xE4,
-	0x03,
-	0x12,
-	0x08,
-	0x74,
-	0x7B,
-	0x12,
-	0x7D,
-	0x36,
-	0x7C,
-	0x00,
-	0x7F,
-	0x50,
-	0x12,
-	0x17,
-	0x8F,
-	0x92,
-	0x18,
-	0x85,
-	0x3C,
-	0x37,
-	0x85,
-	0x27,
-	0x38,
-	0x85,
-	0x2A,
-	0x39,
-	0xA2,
-	0x18,
-	0x92,
-	0x1B,
-	0x7F,
-	0x0F,
-	0x12,
-	0x17,
-	0x51,
-	0xC2,
-	0x0B,
-	0xE5,
-	0x16,
-	0x60,
-	0x03,
-	0x02,
-	0x0C,
-	0x80,
-	0x30,
-	0x03,
-	0x2F,
-	0xC2,
-	0xA8,
-	0x7F,
-	0x0A,
-	0x12,
-	0x19,
-	0xCD,
-	0xC2,
-	0x03,
-	0x30,
-	0x09,
-	0x0E,
-	0xE5,
-	0x55,
-	0x60,
-	0x06,
-	0xD2,
-	0x02,
-	0xD2,
-	0x07,
-	0x80,
-	0x0C,
-	0xAF,
-	0x55,
-	0x80,
-	0x05,
-	0xE5,
-	0x55,
-	0x60,
-	0x04,
-	0xFF,
-	0x12,
-	0x19,
-	0x39,
-	0xE5,
-	0x55,
-	0x24,
-	0xFF,
-	0x92,
-	0x09,
-	0x75,
-	0x16,
-	0x19,
-	0xD2,
-	0xA8,
-	0x80,
-	0x54,
-	0x20,
-	0x11,
-	0x1A,
-	0x30,
-	0x09,
-	0x09,
-	0x7F,
-	0x09,
-	0x12,
-	0x19,
-	0x87,
-	0xEF,
-	0x13,
-	0x92,
-	0x0F,
-	0xD2,
-	0x14,
-	0x7F,
-	0x08,
-	0x12,
-	0x19,
-	0x87,
-	0xEF,
-	0x54,
-	0x0E,
-	0x70,
-	0x02,
-	0xC2,
-	0x14,
-	0xE5,
-	0x55,
-	0x60,
-	0x22,
-	0x7F,
-	0x09,
-	0x12,
-	0x19,
-	0x87,
-	0xEF,
-	0x20,
-	0xE0,
-	0x19,
-	0x7F,
-	0x0A,
-	0x12,
-	0x19,
-	0x87,
-	0xEF,
-	0x30,
-	0xE2,
-	0x10,
-	0x7D,
-	0x04,
-	0x7F,
-	0x5C,
-	0x12,
-	0x11,
-	0xB7,
-	0x7D,
-	0x01,
-	0x7F,
-	0x07,
-	0x12,
-	0x11,
-	0x96,
-	0x80,
-	0x0E,
-	0x7D,
-	0x04,
-	0x7F,
-	0x5C,
-	0x12,
-	0x11,
-	0xA2,
-	0x7D,
-	0x01,
-	0x7F,
-	0x07,
-	0x12,
-	0x11,
-	0xAB,
-	0x75,
-	0x16,
-	0x4B,
-	0x30,
-	0x02,
-	0x30,
-	0x20,
-	0x0E,
-	0x2D,
-	0x30,
-	0x07,
-	0x2C,
-	0xC2,
-	0x07,
-	0xC2,
-	0x06,
-	0xC2,
-	0x13,
-	0xE4,
-	0xF5,
-	0x57,
-	0x74,
-	0x44,
-	0x25,
-	0x57,
-	0xF8,
-	0xE4,
-	0xF6,
-	0x05,
-	0x57,
-	0xE5,
-	0x57,
-	0xB4,
-	0x05,
-	0xF2,
-	0x12,
-	0x05,
-	0xC6,
-	0x50,
-	0x10,
-	0x12,
-	0x00,
-	0x0E,
-	0x50,
-	0x0B,
-	0x12,
-	0x18,
-	0x57,
-	0x50,
-	0x06,
-	0xC2,
-	0x02,
-	0x80,
-	0x02,
-	0xC2,
-	0x02,
-	0x30,
-	0x13,
-	0x09,
-	0x12,
-	0x14,
-	0x58,
-	0x40,
-	0x04,
-	0xD2,
-	0x02,
-	0xD2,
-	0x07,
-	0xE5,
-	0x17,
-	0x70,
-	0x2C,
-	0x7F,
-	0x7F,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x04,
-	0xF5,
-	0x57,
-	0x65,
-	0x49,
-	0x60,
-	0x1B,
-	0x85,
-	0x49,
-	0x57,
-	0x7F,
-	0x0A,
-	0x12,
-	0x19,
-	0xEF,
-	0xE5,
-	0x49,
-	0x65,
-	0x57,
-	0x60,
-	0x0D,
-	0xE5,
-	0x49,
-	0x70,
-	0x03,
-	0xD3,
-	0x80,
-	0x01,
-	0xC3,
-	0x92,
-	0x19,
-	0x12,
-	0x18,
-	0x87,
-	0x75,
-	0x17,
-	0x19,
-	0x05,
-	0x26,
-	0xE5,
-	0x26,
-	0xAE,
-	0x25,
-	0x70,
-	0x02,
-	0x05,
-	0x25,
-	0x14,
-	0x4E,
-	0x60,
-	0x03,
-	0x02,
-	0x0B,
-	0xB5,
-	0x75,
-	0x13,
-	0x07,
-	0x75,
-	0x14,
-	0xD0,
-	0x05,
-	0x54,
-	0xE5,
-	0x54,
-	0x20,
-	0xE0,
-	0x03,
-	0x02,
-	0x0B,
-	0xB5,
-	0x02,
-	0x0B,
-	0xB5,
-	0x02,
-	0x0E,
-	0x69,
-	0xEC,
-	0x5D,
-	0x04,
-	0x60,
-	0x05,
-	0xE8,
-	0x59,
-	0x04,
-	0x70,
-	0x03,
-	0x02,
-	0x0E,
-	0x5F,
-	0x12,
-	0x0E,
-	0x2A,
-	0x58,
-	0x04,
-	0x60,
-	0xF6,
-	0xEC,
-	0x48,
-	0x60,
-	0xF2,
-	0xEC,
-	0x70,
-	0x04,
-	0xFD,
-	0xFE,
-	0xFF,
-	0x22,
-	0xC8,
-	0x60,
-	0xDB,
-	0x24,
-	0x81,
-	0xC8,
-	0x50,
-	0x09,
-	0xC3,
-	0x98,
-	0x60,
-	0x02,
-	0x50,
-	0x06,
-	0x02,
-	0x0E,
-	0x66,
-	0x98,
-	0x50,
-	0xCA,
-	0xF5,
-	0x82,
-	0xE9,
-	0x29,
-	0x4B,
-	0x4A,
-	0x70,
-	0x05,
-	0xAB,
-	0x82,
-	0x02,
-	0x0E,
-	0x55,
-	0x75,
-	0xF0,
-	0x00,
-	0x7C,
-	0x1A,
-	0x78,
-	0x80,
-	0xC3,
-	0xEF,
-	0x9B,
-	0xEE,
-	0x9A,
-	0xED,
-	0x99,
-	0x40,
-	0x0D,
-	0xC3,
-	0xEF,
-	0x9B,
-	0xFF,
-	0xEE,
-	0x9A,
-	0xFE,
-	0xED,
-	0x99,
-	0xFD,
-	0xE8,
-	0x42,
-	0xF0,
-	0xDC,
-	0x23,
-	0xAC,
-	0xF0,
-	0xD0,
-	0xE0,
-	0xFF,
-	0xD0,
-	0xE0,
-	0xFE,
-	0xD0,
-	0xE0,
-	0xFD,
-	0xAB,
-	0x82,
-	0x20,
-	0xE7,
-	0x10,
-	0x1B,
-	0xEB,
-	0x60,
-	0xBA,
-	0xEC,
-	0x2C,
-	0xFC,
-	0xEF,
-	0x33,
-	0xFF,
-	0xEE,
-	0x33,
-	0xFE,
-	0xED,
-	0x33,
-	0xFD,
-	0x02,
-	0x0E,
-	0x41,
-	0xE8,
-	0x03,
-	0xF8,
-	0x30,
-	0xE7,
-	0x05,
-	0xC0,
-	0xF0,
-	0x75,
-	0xF0,
-	0x00,
-	0xEF,
-	0x2F,
-	0xFF,
-	0xEE,
-	0x33,
-	0xFE,
-	0xED,
-	0x33,
-	0xFD,
-	0x40,
-	0xB8,
-	0x30,
-	0xE7,
-	0xC2,
-	0x80,
-	0xAA,
-	0x75,
-	0xF0,
-	0x20,
-	0x80,
-	0x0E,
-	0x75,
-	0xF0,
-	0x10,
-	0x80,
-	0x05,
-	0x75,
-	0xF0,
-	0x08,
-	0x7D,
-	0x00,
-	0x7E,
-	0x00,
-	0x7F,
-	0x00,
-	0x33,
-	0x92,
-	0xD5,
-	0x30,
-	0xD5,
-	0x03,
-	0x12,
-	0x0E,
-	0x93,
-	0xEC,
-	0x33,
-	0x40,
-	0x10,
-	0xEF,
-	0x33,
-	0xFF,
-	0xEE,
-	0x33,
-	0xFE,
-	0xED,
-	0x33,
-	0xFD,
-	0xEC,
-	0x33,
-	0xFC,
-	0xD5,
-	0xF0,
-	0xED,
-	0x22,
-	0xE5,
-	0xF0,
-	0x24,
-	0x7E,
-	0xA2,
-	0xD5,
-	0x13,
-	0xCC,
-	0x92,
-	0xE7,
-	0xCD,
-	0xCE,
-	0xFF,
-	0x22,
-	0xED,
-	0xD2,
-	0xE7,
-	0xCD,
-	0x33,
-	0xEC,
-	0x33,
-	0x92,
-	0xD5,
-	0x24,
-	0x81,
-	0x40,
-	0x06,
-	0xE4,
-	0xFF,
-	0xFE,
-	0xFD,
-	0xFC,
-	0x22,
-	0xFC,
-	0xE4,
-	0xCF,
-	0xCE,
-	0xCD,
-	0xCC,
-	0x24,
-	0xE0,
-	0x50,
-	0x11,
-	0x74,
-	0xFF,
-	0x80,
-	0xED,
-	0xC3,
-	0xCC,
-	0x13,
-	0xCC,
-	0xCD,
-	0x13,
-	0xCD,
-	0xCE,
-	0x13,
-	0xCE,
-	0xCF,
-	0x13,
-	0xCF,
-	0x04,
-	0x70,
-	0xF0,
-	0x30,
-	0xD5,
-	0xDE,
-	0x02,
-	0x0E,
-	0x93,
-	0xE9,
-	0xD2,
-	0xE7,
-	0xC9,
-	0x33,
-	0xE8,
-	0x33,
-	0xF8,
-	0x92,
-	0xD5,
-	0xED,
-	0xD2,
-	0xE7,
-	0xCD,
-	0x33,
-	0xEC,
-	0x33,
-	0xFC,
-	0x50,
-	0x02,
-	0xB2,
-	0xD5,
-	0x22,
-	0xEC,
-	0x30,
-	0xE7,
-	0x10,
-	0x0F,
-	0xBF,
-	0x00,
-	0x0C,
-	0x0E,
-	0xBE,
-	0x00,
-	0x08,
-	0x0D,
-	0xBD,
-	0x00,
-	0x04,
-	0x0B,
-	0xEB,
-	0x60,
-	0x14,
-	0xA2,
-	0xD5,
-	0xEB,
-	0x13,
-	0xFC,
-	0xED,
-	0x92,
-	0xE7,
-	0xFD,
-	0x22,
-	0x74,
-	0xFF,
-	0xFC,
-	0xFD,
-	0xFE,
-	0xFF,
-	0x22,
-	0xE4,
-	0x80,
-	0xF8,
-	0xA2,
-	0xD5,
-	0x74,
-	0xFF,
-	0x13,
-	0xFC,
-	0x7D,
-	0x80,
-	0xE4,
-	0x80,
-	0xEF,
-	0xEF,
-	0x8D,
-	0xF0,
-	0xA4,
-	0xA8,
-	0xF0,
-	0xCF,
-	0x8C,
-	0xF0,
-	0xA4,
-	0x28,
-	0xCE,
-	0x8D,
-	0xF0,
-	0xA4,
-	0x2E,
-	0xFE,
-	0x22,
-	0xCF,
-	0xF4,
-	0xCF,
-	0xCE,
-	0xF4,
-	0xCE,
-	0xCD,
-	0xF4,
-	0xCD,
-	0xCC,
-	0xF4,
-	0xCC,
-	0x22,
-	0xC3,
-	0xE4,
-	0x9F,
-	0xFF,
-	0xE4,
-	0x9E,
-	0xFE,
-	0xE4,
-	0x9D,
-	0xFD,
-	0xE4,
-	0x9C,
-	0xFC,
-	0x22,
-	0xEB,
-	0x9F,
-	0xF5,
-	0xF0,
-	0xEA,
-	0x9E,
-	0x42,
-	0xF0,
-	0xE9,
-	0x9D,
-	0x42,
-	0xF0,
-	0xE8,
-	0x9C,
-	0x45,
-	0xF0,
-	0x22,
-	0xE8,
-	0x60,
-	0x0F,
-	0xEC,
-	0xC3,
-	0x13,
-	0xFC,
-	0xED,
-	0x13,
-	0xFD,
-	0xEE,
-	0x13,
-	0xFE,
-	0xEF,
-	0x13,
-	0xFF,
-	0xD8,
-	0xF1,
-	0x22,
-	0xE8,
-	0x60,
-	0x0F,
-	0xEF,
-	0xC3,
-	0x33,
-	0xFF,
-	0xEE,
-	0x33,
-	0xFE,
-	0xED,
-	0x33,
-	0xFD,
-	0xEC,
-	0x33,
-	0xFC,
-	0xD8,
-	0xF1,
-	0x22,
-	0xE6,
-	0xFC,
-	0x08,
-	0xE6,
-	0xFD,
-	0x08,
-	0xE6,
-	0xFE,
-	0x08,
-	0xE6,
-	0xFF,
-	0x22,
-	0xE6,
-	0xFB,
-	0x08,
-	0xE6,
-	0xF9,
-	0x08,
-	0xE6,
-	0xFA,
-	0x08,
-	0xE6,
-	0xCB,
-	0xF8,
-	0x22,
-	0xEC,
-	0xF6,
-	0x08,
-	0xED,
-	0xF6,
-	0x08,
-	0xEE,
-	0xF6,
-	0x08,
-	0xEF,
-	0xF6,
-	0x22,
-	0xD0,
-	0x83,
-	0xD0,
-	0x82,
-	0xE4,
-	0x93,
-	0xF6,
-	0x08,
-	0x74,
-	0x01,
-	0x93,
-	0xF6,
-	0x08,
-	0x74,
-	0x02,
-	0x93,
-	0xF6,
-	0x08,
-	0x74,
-	0x03,
-	0x93,
-	0xF6,
-	0x74,
-	0x04,
-	0x73,
-	0xD2,
-	0x19,
-	0xD2,
-	0x1A,
-	0x30,
-	0x0A,
-	0x03,
-	0x02,
-	0x10,
-	0xAF,
-	0x7F,
-	0x4F,
-	0x12,
-	0x19,
-	0x87,
-	0x8F,
-	0x58,
-	0xE5,
-	0x58,
-	0x20,
-	0xE6,
-	0x03,
-	0x02,
-	0x10,
-	0xAF,
-	0xD2,
-	0x0A,
-	0x53,
-	0x58,
-	0x3F,
-	0xE5,
-	0x58,
-	0x24,
-	0xED,
-	0x70,
-	0x03,
-	0x02,
-	0x10,
-	0x01,
-	0x24,
-	0xF4,
-	0x70,
-	0x03,
-	0x02,
-	0x10,
-	0x63,
-	0x24,
-	0x1E,
-	0xB4,
-	0x06,
-	0x00,
-	0x40,
-	0x03,
-	0x02,
-	0x10,
-	0x9E,
-	0x90,
-	0x0F,
-	0x5C,
-	0x75,
-	0xF0,
-	0x03,
-	0xA4,
-	0xC5,
-	0x83,
-	0x25,
-	0xF0,
-	0xC5,
-	0x83,
-	0x73,
-	0x02,
-	0x0F,
-	0x6E,
-	0x02,
-	0x0F,
-	0x75,
-	0x02,
-	0x0F,
-	0xDB,
-	0x02,
-	0x10,
-	0x9E,
-	0x02,
-	0x0F,
-	0xB2,
-	0x02,
-	0x0F,
-	0xE2,
-	0xD2,
-	0x15,
-	0xC2,
-	0x19,
-	0x02,
-	0x10,
-	0xA3,
-	0xE4,
-	0xF5,
-	0x59,
-	0x74,
-	0x3F,
-	0x25,
-	0x59,
-	0xF8,
-	0xE6,
-	0xFF,
-	0x74,
-	0x2B,
-	0x25,
-	0x59,
-	0xF8,
-	0xA6,
-	0x07,
-	0x05,
-	0x59,
-	0xE5,
-	0x59,
-	0xB4,
-	0x05,
-	0xEB,
-	0xE4,
-	0xF5,
-	0x59,
-	0x74,
-	0x44,
-	0x25,
-	0x59,
-	0xF8,
-	0xE6,
-	0xFF,
-	0x74,
-	0x30,
-	0x25,
-	0x59,
-	0xF8,
-	0xA6,
-	0x07,
-	0x05,
-	0x59,
-	0xE5,
-	0x59,
-	0xB4,
-	0x05,
-	0xEB,
-	0x7F,
-	0x53,
-	0x12,
-	0x19,
-	0x93,
-	0x8F,
-	0x35,
-	0x75,
-	0x58,
-	0x0B,
-	0x02,
-	0x10,
-	0xA3,
-	0x7F,
-	0x23,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x2B,
-	0x7F,
-	0x24,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x2C,
-	0x7F,
-	0x6F,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x2D,
-	0x7F,
-	0x70,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x2E,
-	0x7F,
-	0x53,
-	0x12,
-	0x19,
-	0x93,
-	0x8F,
-	0x2F,
-	0x75,
-	0x58,
-	0x05,
-	0x02,
-	0x10,
-	0xA3,
-	0xD2,
-	0x0B,
-	0xC2,
-	0x19,
-	0x02,
-	0x10,
-	0xA3,
-	0x30,
-	0x10,
-	0x04,
-	0x7F,
-	0x80,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0x8F,
-	0x2B,
-	0x7F,
-	0x25,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x30,
-	0xE4,
-	0x03,
-	0x43,
-	0x2B,
-	0x01,
-	0xC2,
-	0x10,
-	0x75,
-	0x58,
-	0x01,
-	0x02,
-	0x10,
-	0xA3,
-	0x7F,
-	0x50,
-	0x12,
-	0x19,
-	0x87,
-	0x8F,
-	0x59,
-	0xE4,
-	0xF5,
-	0x58,
-	0xE5,
-	0x59,
-	0xB4,
-	0x41,
-	0x16,
-	0x85,
-	0x8A,
-	0x2B,
-	0x85,
-	0x8C,
-	0x2C,
-	0xE5,
-	0x2B,
-	0x64,
-	0x63,
-	0xF5,
-	0x52,
-	0xE5,
-	0x2C,
-	0x65,
-	0x2B,
-	0x64,
-	0x68,
-	0xF5,
-	0x53,
-	0x80,
-	0x31,
-	0xE5,
-	0x59,
-	0x64,
-	0x42,
-	0x70,
-	0x30,
-	0x90,
-	0x10,
-	0xB2,
-	0x93,
-	0xFF,
-	0x12,
-	0x19,
-	0x8B,
-	0xEF,
-	0x65,
-	0x52,
-	0x70,
-	0x23,
-	0x90,
-	0x10,
-	0xB3,
-	0x93,
-	0xFF,
-	0x12,
-	0x19,
-	0x8B,
-	0xEF,
-	0xB5,
-	0x53,
-	0x17,
-	0xC2,
-	0x1B,
-	0x12,
-	0x19,
-	0xAA,
-	0xC2,
-	0x02,
-	0x85,
-	0x8A,
-	0x52,
-	0x85,
-	0x8C,
-	0x53,
-	0xE4,
-	0xF5,
-	0x2B,
-	0xF5,
-	0x2C,
-	0x75,
-	0x58,
-	0x02,
-	0x80,
-	0x47,
-	0x20,
-	0x13,
-	0x44,
-	0xD2,
-	0x02,
-	0x80,
-	0x40,
-	0x75,
-	0x5A,
-	0x10,
-	0x75,
-	0x5B,
-	0xC2,
-	0xE4,
-	0xF5,
-	0x59,
-	0xE5,
-	0x5B,
-	0x25,
-	0x59,
-	0xF5,
-	0x82,
-	0xE4,
-	0x35,
-	0x5A,
-	0xF5,
-	0x83,
-	0xE4,
-	0x93,
-	0xFF,
-	0x74,
-	0x2B,
-	0x25,
-	0x59,
-	0xF8,
-	0xA6,
-	0x07,
-	0x05,
-	0x59,
-	0xE5,
-	0x59,
-	0xB4,
-	0x07,
-	0xE4,
-	0x7F,
-	0x50,
-	0x12,
-	0x19,
-	0x93,
-	0x8F,
-	0x2E,
-	0x7F,
-	0x51,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x0F,
-	0xF5,
-	0x2F,
-	0x75,
-	0x58,
-	0x07,
-	0x80,
-	0x05,
-	0xE4,
-	0xF5,
-	0x58,
-	0xC2,
-	0x1A,
-	0x30,
-	0x19,
-	0x09,
-	0xA2,
-	0x1A,
-	0x92,
-	0x1B,
-	0xAF,
-	0x58,
-	0x12,
-	0x17,
-	0x51,
-	0xA2,
-	0x0A,
-	0x22,
-	0x26,
-	0x27,
-	0x42,
-	0x43,
-	0x44,
-	0x45,
-	0x46,
-	0x47,
-	0x6A,
-	0x51,
-	0x52,
-	0x53,
-	0x57,
-	0x58,
-	0x59,
-	0x5A,
-	0x07,
-	0x01,
-	0x2B,
-	0x00,
-	0x00,
-	0x03,
-	0x00,
-	0x14,
-	0x5A,
-	0x10,
-	0x20,
-	0x07,
-	0x10,
-	0x11,
-	0x0E,
-	0x80,
-	0x14,
-	0x59,
-	0xE0,
-	0x24,
-	0x59,
-	0x60,
-	0x10,
-	0x19,
-	0x04,
-	0x00,
-	0x1C,
-	0x69,
-	0x00,
-	0x1D,
-	0x78,
-	0x04,
-	0x76,
-	0x00,
-	0x04,
-	0x77,
-	0x20,
-	0x04,
-	0x75,
-	0x08,
-	0x14,
-	0x52,
-	0x10,
-	0xF0,
-	0x10,
-	0x80,
-	0x1F,
-	0x40,
-	0x04,
-	0x20,
-	0x13,
-	0x10,
-	0x05,
-	0x08,
-	0x14,
-	0x04,
-	0x03,
-	0x02,
-	0x02,
-	0x02,
-	0x12,
-	0x01,
-	0x11,
-	0x01,
-	0x00,
-	0x50,
-	0x00,
-	0x40,
-	0x04,
-	0x66,
-	0x50,
-	0x00,
-	0x30,
-	0x08,
-	0x40,
-	0x60,
-	0xB0,
-	0x40,
-	0x10,
-	0x20,
-	0x09,
-	0x01,
-	0x20,
-	0x08,
-	0xF0,
-	0x20,
-	0x07,
-	0x19,
-	0x21,
-	0x0D,
-	0x80,
-	0x21,
-	0x16,
-	0x01,
-	0xF0,
-	0x10,
-	0x08,
-	0x0E,
-	0x10,
-	0x09,
-	0x04,
-	0xF0,
-	0x20,
-	0x08,
-	0x0E,
-	0x20,
-	0x09,
-	0x04,
-	0xF0,
-	0x20,
-	0x09,
-	0x5D,
-	0x20,
-	0x08,
-	0xFE,
-	0x20,
-	0x07,
-	0x1D,
-	0x20,
-	0x0A,
-	0x20,
-	0x20,
-	0x07,
-	0x02,
-	0x24,
-	0x54,
-	0x10,
-	0x21,
-	0x11,
-	0x80,
-	0x10,
-	0x0A,
-	0x04,
-	0xF0,
-	0x11,
-	0x11,
-	0x80,
-	0x10,
-	0x07,
-	0x02,
-	0x14,
-	0x54,
-	0x10,
-	0x10,
-	0x07,
-	0x1D,
-	0x10,
-	0x0A,
-	0x20,
-	0x11,
-	0x16,
-	0x01,
-	0x11,
-	0x0D,
-	0x80,
-	0x10,
-	0x08,
-	0xF0,
-	0x10,
-	0x09,
-	0x5D,
-	0x14,
-	0x52,
-	0x01,
-	0x24,
-	0x52,
-	0x01,
-	0xF0,
-	0x7B,
-	0x00,
-	0x80,
-	0x0A,
-	0x7B,
-	0x01,
-	0x80,
-	0x06,
-	0x7B,
-	0x03,
-	0x80,
-	0x02,
-	0x7B,
-	0x04,
-	0x7C,
-	0x00,
-	0x80,
-	0x00,
-	0x12,
-	0x11,
-	0x8A,
-	0xE2,
-	0x5C,
-	0x4D,
-	0xF2,
-	0x78,
-	0x03,
-	0xEB,
-	0xF2,
-	0xD2,
-	0xAF,
-	0x22,
-	0xC2,
-	0xAF,
-	0x78,
-	0x83,
-	0xE2,
-	0xCB,
-	0xF2,
-	0x74,
-	0x80,
-	0x2F,
-	0xF8,
-	0x22,
-	0x7B,
-	0x00,
-	0x80,
-	0x0A,
-	0x7B,
-	0x01,
-	0x80,
-	0x06,
-	0x7B,
-	0x03,
-	0x80,
-	0x02,
-	0x7B,
-	0x04,
-	0xED,
-	0xF4,
-	0xFC,
-	0x7D,
-	0x00,
-	0x80,
-	0xD1,
-	0x7B,
-	0x00,
-	0x80,
-	0x0A,
-	0x7B,
-	0x01,
-	0x80,
-	0x06,
-	0x7B,
-	0x03,
-	0x80,
-	0x02,
-	0x7B,
-	0x04,
-	0x7C,
-	0xFF,
-	0x80,
-	0xBF,
-	0x7B,
-	0x03,
-	0x80,
-	0x02,
-	0x7B,
-	0x04,
-	0x12,
-	0x11,
-	0x8A,
-	0xED,
-	0xF4,
-	0xFF,
-	0xE2,
-	0x5F,
-	0xF2,
-	0x4D,
-	0xF2,
-	0x5F,
-	0xF2,
-	0x80,
-	0xB1,
-	0x8E,
-	0x83,
-	0x8F,
-	0x82,
-	0xE4,
-	0x93,
-	0xA3,
-	0xFB,
-	0x54,
-	0x0F,
-	0xCB,
-	0x54,
-	0xF0,
-	0xB4,
-	0xF0,
-	0x01,
-	0x22,
-	0xFD,
-	0xE4,
-	0x93,
-	0xA3,
-	0xFF,
-	0xE4,
-	0x93,
-	0xA3,
-	0xCD,
-	0xB4,
-	0x00,
-	0x05,
-	0x12,
-	0x11,
-	0x78,
-	0x80,
-	0xE2,
-	0xB4,
-	0x10,
-	0x05,
-	0x12,
-	0x11,
-	0xA4,
-	0x80,
-	0xDA,
-	0xB4,
-	0x20,
-	0x05,
-	0x12,
-	0x11,
-	0xB9,
-	0x80,
-	0xD2,
-	0xB4,
-	0x30,
-	0x05,
-	0x12,
-	0x11,
-	0xC3,
-	0x80,
-	0xCA,
-	0x80,
-	0xC8,
-	0xC2,
-	0x96,
-	0xD2,
-	0x97,
-	0xD2,
-	0x96,
-	0x22,
-	0x22,
-	0xC2,
-	0x97,
-	0xD2,
-	0x96,
-	0x74,
-	0x28,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xD2,
-	0x97,
-	0x74,
-	0x1E,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0x22,
-	0xC2,
-	0x97,
-	0xD2,
-	0x97,
-	0x74,
-	0x1E,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xD2,
-	0x96,
-	0x74,
-	0x28,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0x22,
-	0xD2,
-	0x97,
-	0xD2,
-	0x96,
-	0x74,
-	0x28,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xC2,
-	0x97,
-	0x74,
-	0x1E,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xC2,
-	0x96,
-	0x74,
-	0x1E,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0x22,
-	0xEF,
-	0x7E,
-	0x08,
-	0x33,
-	0xC0,
-	0xE0,
-	0x40,
-	0x04,
-	0xC2,
-	0x97,
-	0x80,
-	0x02,
-	0xD2,
-	0x97,
-	0x74,
-	0x11,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xD2,
-	0x96,
-	0x74,
-	0x11,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xC2,
-	0x96,
-	0x74,
-	0x11,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xD0,
-	0xE0,
-	0xDE,
-	0xD8,
-	0xD2,
-	0x97,
-	0x74,
-	0x11,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xD2,
-	0x96,
-	0x74,
-	0x11,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xA2,
-	0x97,
-	0xE4,
-	0x92,
-	0xE0,
-	0xFE,
-	0xC2,
-	0x96,
-	0x74,
-	0x11,
-	0x00,
-	0x00,
-	0xD5,
-	0xE0,
-	0xFB,
-	0xEE,
-	0x22,
-	0x8F,
-	0x6C,
-	0x8D,
-	0x6D,
-	0x7F,
-	0x5A,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x80,
-	0xF5,
-	0x70,
-	0xE5,
-	0x6C,
-	0xB4,
-	0x01,
-	0x04,
-	0x7F,
-	0x40,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0x8F,
-	0x6E,
-	0x43,
-	0x6E,
-	0x80,
-	0xAD,
-	0x6E,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0x76,
-	0xE5,
-	0x6E,
-	0x44,
-	0x20,
-	0xFD,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x6E,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0x76,
-	0x7F,
-	0x0E,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x20,
-	0xE7,
-	0x4E,
-	0x7F,
-	0x5A,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x80,
-	0x65,
-	0x70,
-	0x60,
-	0x03,
-	0x7F,
-	0xFF,
-	0x22,
-	0x7F,
-	0x0E,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x30,
-	0xE6,
-	0x03,
-	0x7F,
-	0x01,
-	0x22,
-	0x85,
-	0x6E,
-	0x6F,
-	0x7F,
-	0x0C,
-	0x12,
-	0x19,
-	0x93,
-	0x8F,
-	0x6E,
-	0xE5,
-	0x6F,
-	0x65,
-	0x6E,
-	0x60,
-	0x04,
-	0x7F,
-	0x01,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0xE5,
-	0x6E,
-	0x60,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xEE,
-	0x5F,
-	0x60,
-	0xB8,
-	0x7F,
-	0x0D,
-	0x12,
-	0x19,
-	0x93,
-	0xE5,
-	0x6E,
-	0x14,
-	0x25,
-	0x6D,
-	0xF8,
-	0xA6,
-	0x07,
-	0x80,
-	0xA9,
-	0x7F,
-	0x00,
-	0x22,
-	0x8F,
-	0x63,
-	0x7F,
-	0x5A,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x80,
-	0xF5,
-	0x66,
-	0xE5,
-	0x63,
-	0xB4,
-	0x01,
-	0x04,
-	0x7F,
-	0x40,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0x8F,
-	0x64,
-	0xAD,
-	0x4A,
-	0x7F,
-	0x09,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x64,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0x76,
-	0xE5,
-	0x64,
-	0x44,
-	0x20,
-	0xFD,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x64,
-	0x7F,
-	0x0A,
-	0x80,
-	0x51,
-	0x7F,
-	0x0E,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x20,
-	0xE7,
-	0x4D,
-	0x7F,
-	0x5A,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x80,
-	0x65,
-	0x66,
-	0x60,
-	0x03,
-	0x7F,
-	0xFF,
-	0x22,
-	0x7F,
-	0x0E,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x30,
-	0xE6,
-	0x03,
-	0x7F,
-	0x01,
-	0x22,
-	0x85,
-	0x64,
-	0x65,
-	0x7F,
-	0x0B,
-	0x12,
-	0x19,
-	0x93,
-	0x8F,
-	0x64,
-	0xE5,
-	0x65,
-	0x65,
-	0x64,
-	0x60,
-	0x04,
-	0x7F,
-	0x01,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0xE5,
-	0x64,
-	0x60,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xEE,
-	0x5F,
-	0x60,
-	0xB8,
-	0x74,
-	0x4A,
-	0x25,
-	0x64,
-	0xF8,
-	0xE6,
-	0xFD,
-	0x7F,
-	0x09,
-	0x12,
-	0x11,
-	0x76,
-	0x80,
-	0xAA,
-	0x7F,
-	0x00,
-	0x22,
-	0x78,
-	0x7F,
-	0xE4,
-	0xF6,
-	0xD8,
-	0xFD,
-	0x75,
-	0x81,
-	0xD7,
-	0x02,
-	0x14,
-	0x13,
-	0x02,
-	0x0A,
-	0xCA,
-	0xE4,
-	0x93,
-	0xA3,
-	0xF8,
-	0xE4,
-	0x93,
-	0xA3,
-	0x40,
-	0x03,
-	0xF6,
-	0x80,
-	0x01,
-	0xF2,
-	0x08,
-	0xDF,
-	0xF4,
-	0x80,
-	0x29,
-	0xE4,
-	0x93,
-	0xA3,
-	0xF8,
-	0x54,
-	0x07,
-	0x24,
-	0x0C,
-	0xC8,
-	0xC3,
-	0x33,
-	0xC4,
-	0x54,
-	0x0F,
-	0x44,
-	0x20,
-	0xC8,
-	0x83,
-	0x40,
-	0x04,
-	0xF4,
-	0x56,
-	0x80,
-	0x01,
-	0x46,
-	0xF6,
-	0xDF,
-	0xE4,
-	0x80,
-	0x0B,
-	0x01,
-	0x02,
-	0x04,
-	0x08,
-	0x10,
-	0x20,
-	0x40,
-	0x80,
-	0x90,
-	0x00,
-	0x06,
-	0xE4,
-	0x7E,
-	0x01,
-	0x93,
-	0x60,
-	0xBC,
-	0xA3,
-	0xFF,
-	0x54,
-	0x3F,
-	0x30,
-	0xE5,
-	0x09,
-	0x54,
-	0x1F,
-	0xFE,
-	0xE4,
-	0x93,
-	0xA3,
-	0x60,
-	0x01,
-	0x0E,
-	0xCF,
-	0x54,
-	0xC0,
-	0x25,
-	0xE0,
-	0x60,
-	0xA8,
-	0x40,
-	0xB8,
-	0xE4,
-	0x93,
-	0xA3,
-	0xFA,
-	0xE4,
-	0x93,
-	0xA3,
-	0xF8,
-	0xE4,
-	0x93,
-	0xA3,
-	0xC8,
-	0xC5,
-	0x82,
-	0xC8,
-	0xCA,
-	0xC5,
-	0x83,
-	0xCA,
-	0xF0,
-	0xA3,
-	0xC8,
-	0xC5,
-	0x82,
-	0xC8,
-	0xCA,
-	0xC5,
-	0x83,
-	0xCA,
-	0xDF,
-	0xE9,
-	0xDE,
-	0xE7,
-	0x80,
-	0xBE,
-	0x30,
-	0x16,
-	0x76,
-	0xC2,
-	0x16,
-	0xE4,
-	0xF5,
-	0x5C,
-	0xE5,
-	0x5C,
-	0x70,
-	0x6D,
-	0x7F,
-	0x23,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x58,
-	0x7F,
-	0x24,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x59,
-	0x30,
-	0x13,
-	0x06,
-	0x12,
-	0x1A,
-	0x53,
-	0x40,
-	0x03,
-	0x22,
-	0xC3,
-	0x22,
-	0x7F,
-	0x23,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x5A,
-	0x7F,
-	0x24,
-	0x12,
-	0x19,
-	0x8F,
-	0x8F,
-	0x5B,
-	0xE5,
-	0x59,
-	0xB5,
-	0x5B,
-	0x04,
-	0x7F,
-	0x01,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0xE5,
-	0x58,
-	0xB5,
-	0x5A,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xEE,
-	0x5F,
-	0x60,
-	0xBB,
-	0x75,
-	0x5C,
-	0x01,
-	0xE5,
-	0x2C,
-	0xB5,
-	0x5A,
-	0x04,
-	0x7F,
-	0x01,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0xE5,
-	0x2B,
-	0xB5,
-	0x5B,
-	0x04,
-	0x7E,
-	0x01,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xEE,
-	0x5F,
-	0x60,
-	0x05,
-	0xE4,
-	0xF5,
-	0x24,
-	0x80,
-	0x99,
-	0x05,
-	0x24,
-	0xE5,
-	0x24,
-	0xD3,
-	0x94,
-	0x02,
-	0x40,
-	0x90,
-	0x22,
-	0xD3,
-	0x22,
-	0xAD,
-	0x07,
-	0x8D,
-	0x58,
-	0xBD,
-	0xFF,
-	0x07,
-	0x7F,
-	0x50,
-	0x12,
-	0x19,
-	0x87,
-	0xAD,
-	0x07,
-	0xED,
-	0x54,
-	0x80,
-	0xFF,
-	0x53,
-	0x05,
-	0x7F,
-	0xED,
-	0xC4,
-	0x54,
-	0x0F,
-	0xFE,
-	0xED,
-	0x54,
-	0x0F,
-	0xC4,
-	0x54,
-	0xF0,
-	0xFD,
-	0xEF,
-	0x4E,
-	0xFF,
-	0x7B,
-	0x10,
-	0x12,
-	0x15,
-	0xC8,
-	0x92,
-	0x19,
-	0xAD,
-	0x58,
-	0x7F,
-	0x74,
-	0xE4,
-	0xF5,
-	0x58,
-	0x30,
-	0x19,
-	0x08,
-	0xEF,
-	0x25,
-	0x58,
-	0xF8,
-	0xE6,
-	0xFE,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0x74,
-	0x2B,
-	0x25,
-	0x58,
-	0xF8,
-	0xA6,
-	0x06,
-	0x05,
-	0x58,
-	0xE5,
-	0x58,
-	0xB4,
-	0x10,
-	0xE5,
-	0xED,
-	0xF4,
-	0x70,
-	0x25,
-	0xA2,
-	0x19,
-	0x92,
-	0x1B,
-	0x7F,
-	0x10,
-	0x12,
-	0x17,
-	0x51,
-	0xC2,
-	0x15,
-	0x7D,
-	0x40,
-	0x7F,
-	0x4F,
-	0x12,
-	0x11,
-	0x96,
-	0x30,
-	0x19,
-	0x09,
-	0x7D,
-	0x80,
-	0x7F,
-	0x50,
-	0x12,
-	0x11,
-	0x96,
-	0x80,
-	0x07,
-	0x7D,
-	0x40,
-	0x7F,
-	0x50,
-	0x12,
-	0x11,
-	0xAB,
-	0xA2,
-	0x19,
-	0x22,
-	0xC0,
-	0xE0,
-	0xC0,
-	0xD0,
-	0xC2,
-	0x8C,
-	0x75,
-	0x8A,
-	0x40,
-	0x75,
-	0x8C,
-	0x7C,
-	0xD2,
-	0x8C,
-	0x05,
-	0x18,
-	0xE5,
-	0x18,
-	0x70,
-	0x1F,
-	0x05,
-	0x10,
-	0xE5,
-	0x10,
-	0xD3,
-	0x94,
-	0x02,
-	0x40,
-	0x05,
-	0x75,
-	0x10,
-	0x00,
-	0xD2,
-	0x16,
-	0xE5,
-	0x10,
-	0xB4,
-	0x01,
-	0x03,
-	0xD3,
-	0x80,
-	0x01,
-	0xC3,
-	0x92,
-	0x07,
-	0xE5,
-	0x10,
-	0x70,
-	0x02,
-	0xD2,
-	0x06,
-	0xE5,
-	0x11,
-	0x60,
-	0x02,
-	0x15,
-	0x11,
-	0xE5,
-	0x12,
-	0x60,
-	0x02,
-	0x15,
-	0x12,
-	0xE5,
-	0x15,
-	0x60,
-	0x02,
-	0x15,
-	0x15,
-	0xE5,
-	0x16,
-	0x60,
-	0x02,
-	0x15,
-	0x16,
-	0xE5,
-	0x17,
-	0x60,
-	0x02,
-	0x15,
-	0x17,
-	0xE5,
-	0x14,
-	0x45,
-	0x13,
-	0x60,
-	0x0A,
-	0xE5,
-	0x14,
-	0x15,
-	0x14,
-	0x70,
-	0x0C,
-	0x15,
-	0x13,
-	0x80,
-	0x08,
-	0xC2,
-	0xAF,
-	0x12,
-	0x19,
-	0xA9,
-	0x02,
-	0x00,
-	0x00,
-	0x74,
-	0x81,
-	0xB5,
-	0x81,
-	0x00,
-	0x40,
-	0x02,
-	0x80,
-	0xEF,
-	0xD0,
-	0xD0,
-	0xD0,
-	0xE0,
-	0x32,
-	0x25,
-	0x5F,
-	0xFD,
-	0xAF,
-	0x5C,
-	0x8F,
-	0x67,
-	0x8D,
-	0x68,
-	0x8B,
-	0x69,
-	0x75,
-	0x6A,
-	0x03,
-	0xE5,
-	0x67,
-	0x30,
-	0xE7,
-	0x04,
-	0x7F,
-	0x01,
-	0x80,
-	0x02,
-	0x7F,
-	0x00,
-	0x8F,
-	0x6B,
-	0x53,
-	0x67,
-	0x7F,
-	0xAF,
-	0x6A,
-	0x15,
-	0x6A,
-	0xEF,
-	0x60,
-	0x4C,
-	0xE5,
-	0x6B,
-	0x70,
-	0x1D,
-	0xE5,
-	0x67,
-	0xD3,
-	0x94,
-	0x00,
-	0x40,
-	0x16,
-	0x12,
-	0x12,
-	0x15,
-	0x12,
-	0x12,
-	0x40,
-	0x7F,
-	0x60,
-	0x12,
-	0x12,
-	0x5E,
-	0xAF,
-	0x67,
-	0x12,
-	0x12,
-	0x5E,
-	0x12,
-	0x12,
-	0x2B,
-	0x12,
-	0x12,
-	0x15,
-	0xE5,
-	0x6B,
-	0x60,
-	0x0D,
-	0xE5,
-	0x68,
-	0xFD,
-	0x7C,
-	0x00,
-	0xAB,
-	0x69,
-	0x7F,
-	0x50,
-	0x7E,
-	0x02,
-	0x80,
-	0x0B,
-	0xE5,
-	0x68,
-	0xFD,
-	0x7C,
-	0x00,
-	0xAB,
-	0x69,
-	0x7F,
-	0x50,
-	0x7E,
-	0x00,
-	0x12,
-	0x16,
-	0xA3,
-	0x7D,
-	0x74,
-	0xE4,
-	0xFF,
-	0x12,
-	0x12,
-	0xAC,
-	0xEF,
-	0x70,
-	0xAF,
-	0xD3,
-	0x22,
-	0xC3,
-	0x22,
-	0x8F,
-	0x63,
-	0x75,
-	0x66,
-	0x74,
-	0xE4,
-	0xF5,
-	0x64,
-	0xE5,
-	0x63,
-	0xC3,
-	0x13,
-	0xFF,
-	0xE5,
-	0x63,
-	0x30,
-	0xE0,
-	0x04,
-	0x7D,
-	0x80,
-	0x80,
-	0x02,
-	0x7D,
-	0x00,
-	0x7B,
-	0x40,
-	0x12,
-	0x15,
-	0xC8,
-	0x40,
-	0x01,
-	0x22,
-	0xE4,
-	0xF5,
-	0x65,
-	0xE5,
-	0x66,
-	0x25,
-	0x65,
-	0xF8,
-	0xE6,
-	0x25,
-	0x64,
-	0xF5,
-	0x64,
-	0x05,
-	0x65,
-	0xE5,
-	0x65,
-	0xB4,
-	0x40,
-	0xEF,
-	0xE5,
-	0x63,
-	0xC3,
-	0x13,
-	0xFF,
-	0xE5,
-	0x63,
-	0x30,
-	0xE0,
-	0x04,
-	0x7E,
-	0x80,
-	0x80,
-	0x02,
-	0x7E,
-	0x00,
-	0xEE,
-	0x24,
-	0x40,
-	0xFD,
-	0x7B,
-	0x40,
-	0x12,
-	0x15,
-	0xC8,
-	0x40,
-	0x01,
-	0x22,
-	0xE4,
-	0xF5,
-	0x65,
-	0xE5,
-	0x66,
-	0x25,
-	0x65,
-	0xF8,
-	0xE6,
-	0x25,
-	0x64,
-	0xF5,
-	0x64,
-	0x05,
-	0x65,
-	0xE5,
-	0x65,
-	0xB4,
-	0x40,
-	0xEF,
-	0xE5,
-	0x64,
-	0x70,
-	0x03,
-	0xD3,
-	0x80,
-	0x01,
-	0xC3,
-	0x22,
-	0x8E,
-	0x6C,
-	0x8F,
-	0x6D,
-	0x8C,
-	0x6E,
-	0x8D,
-	0x6F,
-	0x8B,
-	0x70,
-	0xE5,
-	0x6C,
-	0xF5,
-	0x71,
-	0xEF,
-	0xF5,
-	0x72,
-	0xE5,
-	0x71,
-	0x7D,
-	0x80,
-	0x7F,
-	0x5A,
-	0x30,
-	0xE1,
-	0x05,
-	0x12,
-	0x11,
-	0xB7,
-	0x80,
-	0x03,
-	0x12,
-	0x11,
-	0xA2,
-	0x53,
-	0x71,
-	0x01,
-	0xE5,
-	0x71,
-	0x70,
-	0x0B,
-	0xE5,
-	0x6E,
-	0x25,
-	0x72,
-	0xF5,
-	0x72,
-	0xE4,
-	0xF5,
-	0x73,
-	0x80,
-	0x04,
-	0xE5,
-	0x6E,
-	0xF5,
-	0x73,
-	0xAD,
-	0x72,
-	0x7F,
-	0x28,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x73,
-	0x7F,
-	0x40,
-	0x12,
-	0x11,
-	0x76,
-	0xE5,
-	0x6F,
-	0xF5,
-	0x73,
-	0xAD,
-	0x73,
-	0x7F,
-	0x29,
-	0x12,
-	0x11,
-	0x76,
-	0xAD,
-	0x70,
-	0x7F,
-	0x08,
-	0x12,
-	0x11,
-	0x76,
-	0xAF,
-	0x71,
-	0x22,
-	0xC0,
-	0xE0,
-	0xC0,
-	0xF0,
-	0xC0,
-	0x83,
-	0xC0,
-	0x82,
-	0xC0,
-	0xD0,
-	0x75,
-	0xD0,
-	0x08,
-	0x7F,
-	0x25,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x54,
-	0x10,
-	0xF5,
-	0x56,
-	0x7D,
-	0x40,
-	0x7F,
-	0x6E,
-	0x12,
-	0x11,
-	0xBD,
-	0x30,
-	0x00,
-	0x27,
-	0xE5,
-	0x56,
-	0x65,
-	0x55,
-	0x60,
-	0x21,
-	0x85,
-	0x56,
-	0x55,
-	0xD2,
-	0x03,
-	0xD2,
-	0x10,
-	0xE5,
-	0x16,
-	0xD3,
-	0x94,
-	0x03,
-	0x40,
-	0x03,
-	0x75,
-	0x16,
-	0x03,
-	0xC2,
-	0x13,
-	0x7D,
-	0x01,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0x7D,
-	0x20,
-	0x7F,
-	0x0F,
-	0x12,
-	0x11,
-	0x9E,
-	0xD0,
-	0xD0,
-	0xD0,
-	0x82,
-	0xD0,
-	0x83,
-	0xD0,
-	0xF0,
-	0xD0,
-	0xE0,
-	0x32,
-	0x8F,
-	0x5C,
-	0xE4,
-	0xF5,
-	0x5D,
-	0xE5,
-	0x5D,
-	0xC3,
-	0x95,
-	0x5C,
-	0x50,
-	0x15,
-	0xE5,
-	0x5D,
-	0x90,
-	0x10,
-	0xB2,
-	0x93,
-	0xFF,
-	0x74,
-	0x2B,
-	0x25,
-	0x5D,
-	0xF8,
-	0xE6,
-	0xFD,
-	0x12,
-	0x11,
-	0x6E,
-	0x05,
-	0x5D,
-	0x80,
-	0xE4,
-	0x20,
-	0x1B,
-	0x03,
-	0x43,
-	0x5C,
-	0x80,
-	0xAD,
-	0x5C,
-	0x7F,
-	0x50,
-	0x12,
-	0x11,
-	0x6A,
-	0x7D,
-	0x40,
-	0x7F,
-	0x4F,
-	0x12,
-	0x11,
-	0x96,
-	0xC2,
-	0x0A,
-	0x22,
-	0x7B,
-	0x04,
-	0x7C,
-	0x00,
-	0x7F,
-	0x3A,
-	0x8F,
-	0x60,
-	0x8C,
-	0x61,
-	0x8D,
-	0x62,
-	0x8B,
-	0x63,
-	0xE4,
-	0xF5,
-	0x64,
-	0xAF,
-	0x60,
-	0x7E,
-	0x00,
-	0xAB,
-	0x63,
-	0xAD,
-	0x62,
-	0xAC,
-	0x61,
-	0x12,
-	0x16,
-	0xA3,
-	0x7D,
-	0x2B,
-	0xE4,
-	0xFF,
-	0x12,
-	0x12,
-	0xAC,
-	0xEF,
-	0x70,
-	0x02,
-	0xD3,
-	0x22,
-	0x05,
-	0x64,
-	0xE5,
-	0x64,
-	0xD3,
-	0x94,
-	0x02,
-	0x40,
-	0xDE,
-	0x22,
-	0x20,
-	0x1A,
-	0x15,
-	0x7D,
-	0x08,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0xAB,
-	0x7D,
-	0xFC,
-	0x7F,
-	0x63,
-	0x12,
-	0x11,
-	0xB7,
-	0x7D,
-	0x01,
-	0x7F,
-	0x64,
-	0x12,
-	0x11,
-	0xB7,
-	0x7D,
-	0x02,
-	0x7F,
-	0x66,
-	0x12,
-	0x11,
-	0xB7,
-	0x7D,
-	0x10,
-	0x7F,
-	0x11,
-	0x12,
-	0x11,
-	0xAF,
-	0x7D,
-	0x10,
-	0x7F,
-	0x1A,
-	0x12,
-	0x11,
-	0xAF,
-	0x7D,
-	0x08,
-	0x7F,
-	0x16,
-	0x02,
-	0x11,
-	0xAF,
-	0x20,
-	0x1A,
-	0x15,
-	0x7D,
-	0x08,
-	0x7F,
-	0x0A,
-	0x12,
-	0x11,
-	0x96,
-	0x7D,
-	0xFC,
-	0x7F,
-	0x63,
-	0x12,
-	0x11,
-	0xA2,
-	0x7D,
-	0x01,
-	0x7F,
-	0x64,
-	0x12,
-	0x11,
-	0xA2,
-	0x7D,
-	0x02,
-	0x7F,
-	0x66,
-	0x12,
-	0x11,
-	0xA2,
-	0x7D,
-	0x10,
-	0x7F,
-	0x11,
-	0x12,
-	0x11,
-	0x9A,
-	0x7D,
-	0x10,
-	0x7F,
-	0x1A,
-	0x12,
-	0x11,
-	0x9A,
-	0x7D,
-	0x08,
-	0x7F,
-	0x16,
-	0x02,
-	0x11,
-	0x9A,
-	0xC2,
-	0x1B,
-	0x12,
-	0x19,
-	0xAA,
-	0xE4,
-	0xFD,
-	0x7F,
-	0x53,
-	0x12,
-	0x11,
-	0x76,
-	0x7E,
-	0x11,
-	0x7F,
-	0x11,
-	0x12,
-	0x11,
-	0xD2,
-	0x7F,
-	0x08,
-	0x12,
-	0x19,
-	0x87,
-	0xEF,
-	0x54,
-	0x0E,
-	0x60,
-	0x07,
-	0x7E,
-	0x11,
-	0x7F,
-	0x28,
-	0x12,
-	0x11,
-	0xD2,
-	0x7D,
-	0x04,
-	0x7F,
-	0x5C,
-	0x12,
-	0x11,
-	0xA2,
-	0x7D,
-	0x01,
-	0x7F,
-	0x07,
-	0x02,
-	0x11,
-	0xAB,
-	0xA2,
-	0x05,
-	0x82,
-	0x04,
-	0x50,
-	0x1E,
-	0x7D,
-	0x80,
-	0x7F,
-	0x0D,
-	0x12,
-	0x11,
-	0xBD,
-	0x7D,
-	0x20,
-	0x7F,
-	0x0F,
-	0x12,
-	0x11,
-	0xB3,
-	0x7F,
-	0x01,
-	0x12,
-	0x1A,
-	0x75,
-	0x7D,
-	0xFC,
-	0x7F,
-	0x53,
-	0x12,
-	0x11,
-	0xA2,
-	0xD2,
-	0x13,
-	0x80,
-	0x09,
-	0x7D,
-	0x01,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0xC2,
-	0x13,
-	0xA2,
-	0x13,
-	0x22,
-	0xA2,
-	0x19,
-	0x92,
-	0x11,
-	0x30,
-	0x19,
-	0x0F,
-	0x12,
-	0x18,
-	0x25,
-	0x7E,
-	0x11,
-	0x7F,
-	0x28,
-	0x12,
-	0x11,
-	0xD2,
-	0xD2,
-	0x1A,
-	0x02,
-	0x17,
-	0xBD,
-	0xD2,
-	0x1A,
-	0x12,
-	0x17,
-	0xF1,
-	0x20,
-	0x0F,
-	0x03,
-	0x12,
-	0x1A,
-	0x11,
-	0x20,
-	0x14,
-	0x07,
-	0x7E,
-	0x11,
-	0x7F,
-	0x21,
-	0x12,
-	0x11,
-	0xD2,
-	0xD2,
-	0x02,
-	0x22,
-	0x8E,
-	0x5E,
-	0x8F,
-	0x5F,
-	0x8D,
-	0x60,
-	0xE4,
-	0xF5,
-	0x61,
-	0xAB,
-	0x60,
-	0xAD,
-	0x5F,
-	0xAC,
-	0x5E,
-	0x7F,
-	0x52,
-	0x7E,
-	0x00,
-	0x12,
-	0x16,
-	0xA3,
-	0x7D,
-	0x2B,
-	0xE4,
-	0xFF,
-	0x12,
-	0x12,
-	0xAC,
-	0xEF,
-	0x70,
-	0x02,
-	0xD3,
-	0x22,
-	0x05,
-	0x61,
-	0xE5,
-	0x61,
-	0xD3,
-	0x94,
-	0x02,
-	0x40,
-	0xDE,
-	0x22,
-	0x8F,
-	0x5E,
-	0x8C,
-	0x5F,
-	0x8D,
-	0x60,
-	0x8B,
-	0x61,
-	0xE4,
-	0xF5,
-	0x62,
-	0xAF,
-	0x5E,
-	0x7E,
-	0x00,
-	0xAB,
-	0x61,
-	0xAD,
-	0x60,
-	0xAC,
-	0x5F,
-	0x12,
-	0x16,
-	0xA3,
-	0xE4,
-	0xFF,
-	0x12,
-	0x13,
-	0x3C,
-	0xEF,
-	0x70,
-	0x02,
-	0xD3,
-	0x22,
-	0x05,
-	0x62,
-	0xE5,
-	0x62,
-	0xD3,
-	0x94,
-	0x02,
-	0x40,
-	0xE0,
-	0x22,
-	0xE4,
-	0xFE,
-	0xFD,
-	0xEF,
-	0x2D,
-	0xF8,
-	0xE6,
-	0xF5,
-	0x5E,
-	0xE4,
-	0xF5,
-	0x5F,
-	0xE5,
-	0x5E,
-	0x30,
-	0xE7,
-	0x01,
-	0x0E,
-	0xE5,
-	0x5E,
-	0x25,
-	0xE0,
-	0xF5,
-	0x5E,
-	0x05,
-	0x5F,
-	0xE5,
-	0x5F,
-	0xB4,
-	0x08,
-	0xED,
-	0x0D,
-	0xBD,
-	0x05,
-	0xE0,
-	0xEE,
-	0xB4,
-	0x14,
-	0x03,
-	0xD3,
-	0x80,
-	0x01,
-	0xC3,
-	0x22,
-	0xC2,
-	0x08,
-	0xEF,
-	0x60,
-	0x18,
-	0x7D,
-	0x80,
-	0x7F,
-	0x0E,
-	0x12,
-	0x11,
-	0x9A,
-	0x12,
-	0x1A,
-	0x33,
-	0x12,
-	0x08,
-	0x74,
-	0x20,
-	0x0F,
-	0x03,
-	0x12,
-	0x1A,
-	0x11,
-	0xD2,
-	0x02,
-	0xD2,
-	0x07,
-	0x22,
-	0x12,
-	0x18,
-	0x25,
-	0x7D,
-	0x80,
-	0x7F,
-	0x0E,
-	0x12,
-	0x11,
-	0xAF,
-	0x22,
-	0xC2,
-	0xAF,
-	0xE4,
-	0xF5,
-	0x11,
-	0xF5,
-	0x12,
-	0x75,
-	0x13,
-	0x07,
-	0x75,
-	0x14,
-	0xD0,
-	0xF5,
-	0x18,
-	0xF5,
-	0x10,
-	0xC2,
-	0x8C,
-	0x53,
-	0x89,
-	0xF0,
-	0x43,
-	0x89,
-	0x01,
-	0x75,
-	0x8A,
-	0x40,
-	0x75,
-	0x8C,
-	0x7C,
-	0xD2,
-	0xA9,
-	0xD2,
-	0x8C,
-	0xD2,
-	0xAF,
-	0x22,
-	0x7D,
-	0x00,
-	0x80,
-	0x0A,
-	0x7D,
-	0x01,
-	0x80,
-	0x06,
-	0x7D,
-	0x03,
-	0x80,
-	0x02,
-	0x7D,
-	0x04,
-	0xC2,
-	0xAF,
-	0x78,
-	0x83,
-	0xE2,
-	0xCD,
-	0xF2,
-	0x74,
-	0x80,
-	0x2F,
-	0xF8,
-	0xE2,
-	0x78,
-	0x03,
-	0xFF,
-	0xED,
-	0xF2,
-	0xD2,
-	0xAF,
-	0x22,
-	0x32,
-	0x7D,
-	0x01,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0xB3,
-	0x7D,
-	0x20,
-	0x7F,
-	0x0F,
-	0x12,
-	0x11,
-	0x9E,
-	0x30,
-	0x1B,
-	0x04,
-	0x7F,
-	0x42,
-	0x80,
-	0x02,
-	0x7F,
-	0x40,
-	0x8F,
-	0x5E,
-	0xAD,
-	0x5E,
-	0x7F,
-	0x10,
-	0x12,
-	0x11,
-	0x72,
-	0xC2,
-	0x13,
-	0x22,
-	0x8F,
-	0x58,
-	0x80,
-	0x18,
-	0xE5,
-	0x5A,
-	0x60,
-	0x19,
-	0x7F,
-	0x25,
-	0x12,
-	0x19,
-	0x8F,
-	0xEF,
-	0x54,
-	0x10,
-	0xF5,
-	0x59,
-	0xB5,
-	0x55,
-	0x04,
-	0x15,
-	0x5A,
-	0x80,
-	0xEB,
-	0x85,
-	0x59,
-	0x55,
-	0x85,
-	0x58,
-	0x5A,
-	0x80,
-	0xE3,
-	0x22,
-	0x8F,
-	0x58,
-	0x80,
-	0x18,
-	0xE5,
-	0x5A,
-	0x60,
-	0x19,
-	0x7F,
-	0x7F,
-	0x12,
-	0x19,
-	0x93,
-	0xEF,
-	0x54,
-	0x04,
-	0xF5,
-	0x59,
-	0xB5,
-	0x49,
-	0x04,
-	0x15,
-	0x5A,
-	0x80,
-	0xEB,
-	0x85,
-	0x59,
-	0x49,
-	0x85,
-	0x58,
-	0x5A,
-	0x80,
-	0xE3,
-	0x22,
-	0x7E,
-	0x11,
-	0x7F,
-	0x48,
-	0x12,
-	0x11,
-	0xD2,
-	0x7D,
-	0x04,
-	0x7F,
-	0x0A,
-	0x30,
-	0x01,
-	0x10,
-	0x12,
-	0x11,
-	0xAB,
-	0x7D,
-	0x04,
-	0x7F,
-	0x5C,
-	0x12,
-	0x11,
-	0xB7,
-	0x7D,
-	0x01,
-	0x7F,
-	0x07,
-	0x80,
-	0x00,
-	0x12,
-	0x11,
-	0x96,
-	0x22,
-	0x7F,
-	0x64,
-	0x7E,
-	0x00,
-	0xAD,
-	0x07,
-	0xAC,
-	0x06,
-	0xE4,
-	0x12,
-	0x0D,
-	0xBA,
-	0xE4,
-	0xFB,
-	0xFA,
-	0x79,
-	0x20,
-	0x78,
-	0x40,
-	0x12,
-	0x0D,
-	0x18,
-	0x12,
-	0x0D,
-	0xF3,
-	0x8F,
-	0x11,
-	0xE5,
-	0x11,
-	0x70,
-	0xFC,
-	0x22,
-	0x7B,
-	0x02,
-	0x7D,
-	0x08,
-	0x12,
-	0x17,
-	0x8B,
-	0x92,
-	0x1A,
-	0xAD,
-	0x2C,
-	0x7F,
-	0x6F,
-	0x12,
-	0x11,
-	0x72,
-	0xAD,
-	0x2B,
-	0x7F,
-	0x70,
-	0x12,
-	0x11,
-	0x72,
-	0xA2,
-	0x1A,
-	0x22,
-	0x7B,
-	0x01,
-	0x7D,
-	0x40,
-	0x12,
-	0x17,
-	0x8B,
-	0x22,
-	0xAD,
-	0x07,
-	0x7F,
-	0x53,
-	0x02,
-	0x11,
-	0xB7
-};
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.c b/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.c
index db8b198..d5636c5 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.c
+++ b/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.c
@@ -1,7 +1,7 @@
 /* -*- pse-c -*-
  *-----------------------------------------------------------------------------
  * Filename: lvds.c
- * $Revision: 1.2 $
+ * $Revision: 1.3 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -30,7 +30,8 @@
  *  This is written according to the port interface defined in pd.h.
  *-----------------------------------------------------------------------------
  */
-#include <linux/kernel.h>
+
+#pragma optimize ("",off)
 
 #include <config.h>
 #include <igd_pd.h>
@@ -39,6 +40,17 @@
 
 #include "lvds.h"
 
+
+#ifdef T_LINUX
+	#include <linux/kernel.h>
+
+	#define PD_DEBUG printk
+	#define PD_ERROR printk
+#else
+	#define CONFIG_PLB
+//	#define CONFIG_TNC
+#endif
+
 /* One space between the #define and the backslash,else compilers complain */
 #define PTR_OFFSET_UCHAR(ptr,offset)   (*((unsigned char *)ptr + offset))
 #define PTR_OFFSET_USHORT(ptr, offset) (*(unsigned short *)((unsigned char *)ptr + offset))
@@ -198,6 +210,7 @@ static void internal_lvds_get_dclk(internal_lvds_context_t *pd_context, pd_dvo_i
  *
  *----------------------------------------------------------------------------
  */
+#ifdef T_LINUX //thua- 9/16/11
 
 int PD_MODULE_INIT(internal_lvds_init, (void *handle))
 {
@@ -205,6 +218,8 @@ int PD_MODULE_INIT(internal_lvds_init, (void *handle))
 	return pd_register(handle, &internal_lvds_driver);
 }
 
+#endif
+
 /*----------------------------------------------------------------------------
  *
  * Function: PD_MODULE_EXIT(internal_lvds_exit, (void))
@@ -220,11 +235,12 @@ int PD_MODULE_INIT(internal_lvds_init, (void *handle))
  *
  *----------------------------------------------------------------------------
  */
-
+#ifdef T_LINUX //thua- 9/16/11
 int PD_MODULE_EXIT(internal_lvds_exit, (void))
 {
 	return PD_SUCCESS;
 }
+#endif
 
 /*----------------------------------------------------------------------------
  *
@@ -359,7 +375,8 @@ int internal_lvds_open(pd_callback_t *callback, void **context)
 
 	/* Initialize number of attributes */
 	/* +1 is to include the end attribute */
-	internal_lvds_context.num_attrs = (unsigned char)chipset_attr_index + 1;
+	internal_lvds_context.num_attrs = (unsigned char)chipset_attr_index;
+//	internal_lvds_context.num_attrs = (unsigned char)chipset_attr_index + 1;
 
 #if 0
 	/* Add chipset specific attrbutes.
@@ -749,12 +766,14 @@ int internal_lvds_set_attrs (void *context, unsigned long num, pd_attr_t *list)
 
 	PD_DEBUG("internal_lvds_set_attrs()\n");
 	for (i = 0; i < num; i++, list++) {
-
 		/* do nothing if the attribute has not been changed */
 		if (!(list->flags & PD_ATTR_FLAG_VALUE_CHANGED)) {
 			continue;
 		}
 
+		//thua- need to reset flag to 'not changed' - 9/19/11
+//		list->flags &= ~PD_ATTR_FLAG_VALUE_CHANGED;
+
 		/* attributes can't be changed after init has been completed */
 		if (list->flags & PD_ATTR_FLAG_USER_INVISIBLE &&
 			pd_context->init_done) {
@@ -994,6 +1013,8 @@ int internal_lvds_get_timing_list (void *context, pd_timing_t *in_list,
 
 	PD_DEBUG("internal_lvds_get_timing_list()\n");
 
+	PD_DEBUG ("NUHAIRI : context = %lu,  pd_context = %lu, &internal_lvds_info = %lu\n",context,  pd_context, &internal_lvds_info);
+
 	internal_lvds_get_dclk( pd_context, &internal_lvds_info );
 
 	PD_DEBUG("chipset = 0x%x", pd_context->chipset);
@@ -1497,7 +1518,8 @@ static void internal_lvds_get_dclk(internal_lvds_context_t *pd_context, pd_dvo_i
 		internal_lvds_info->min_dclk = LVDS_MIN_DCLK;
 		internal_lvds_info->max_dclk = LVDS_MAX_DCLK;
 	}
-	/* This #define is the result of code size reduction effort. */
+	PD_DEBUG("internal_lvds_dclk: #1\n");
+/* This #define is the result of code size reduction effort. */
 #ifdef CONFIG_CTG
 	/* Set dclk for GM965 */
 	if(pd_context->chipset==PCI_DEVICE_ID_VGA_CTG){
@@ -1556,8 +1578,10 @@ static void internal_lvds_get_dclk(internal_lvds_context_t *pd_context, pd_dvo_i
 		} else {
 			internal_lvds_info->max_dclk = LVDS_TNC_SINGLE_MAX_DCLK;
 		}
-
+		PD_DEBUG("internal_lvds_dclk: #2\n");
 	}
 #endif
-
+	PD_DEBUG("internal_lvds_dclk: at the end\n");
 }
+
+#pragma optimize ("",on)
diff --git a/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.h b/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.h
index 4f6c6d10..6d552f5 100644
--- a/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.h
+++ b/drivers/staging/emgd/emgd/pal/ch7036/lvds/lvds.h
@@ -1,7 +1,7 @@
 /* -*- pse-c -*-
  *-----------------------------------------------------------------------------
  * Filename: lvds.h
- * $Revision: 1.2 $
+ * $Revision: 1.3 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -33,7 +33,10 @@
 #define _PD_LVDS_H
 
 #include <pd.h>
+
+#ifdef T_LINUX
 #include <pci.h>
+#endif
 
 /* Values received from DPG hardware engineer. These are for single channel.  */
 
diff --git a/drivers/staging/emgd/emgd/pal/sdvo/sdvo_port.c b/drivers/staging/emgd/emgd/pal/sdvo/sdvo_port.c
index 10335d7..7651199 100644
--- a/drivers/staging/emgd/emgd/pal/sdvo/sdvo_port.c
+++ b/drivers/staging/emgd/emgd/pal/sdvo/sdvo_port.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: sdvo_port.c
- * $Revision: 1.30 $
+ * $Revision: 1.31 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -35,6 +35,12 @@
 
 #include "sdvo_port.h"
 
+#define PFIT_CONTROL		0x61230  /* Panel Fitting Control Register Address*/
+#define PFIT_PIPEB_ENABLED	0xA0000000
+#define CH7308_VENDOR_ID	2
+#define CH7308_DEVICE_ID	0x41
+#define CH7308_REVISION_ID	1
+
 /* .......................................................................... */
 
 int sdvo_open(pd_callback_t *p_callback, void **p_context);
@@ -2452,6 +2458,33 @@ int sdvo_set_mode(void *p_context, pd_timing_t *p_mode, unsigned long flags)
 
 	}
 #endif
+	/*
+	 * Disable panel fitting for CH7308 card on Pipe B if enabled, because it
+	 * handles its own upscaling
+	 */
+	if ((p_ctx->dev_cap.vendor_id == CH7308_VENDOR_ID) &&
+			(p_ctx->dev_cap.device_id == CH7308_DEVICE_ID) &&
+			(p_ctx->dev_cap.revision_id == CH7308_REVISION_ID)) {
+		pd_reg_t reg_list[2];
+
+		reg_list[0].reg = PFIT_CONTROL;
+		reg_list[1].reg = PD_REG_LIST_END;
+
+		/*Read the current value of the panel fitting control register*/
+		p_ctx->p_callback->read_regs(p_ctx->p_callback->callback_context,
+				reg_list, PD_REG_MIO);
+
+		PD_DEBUG("PFIT_CONTROL 0x%lx = 0x%lx", PFIT_CONTROL,reg_list[0].value);
+
+		if((reg_list[0].value & PFIT_PIPEB_ENABLED) == PFIT_PIPEB_ENABLED ){
+			/* Disable panel fitting */
+			reg_list[0].value = 0x0;
+			p_ctx->p_callback->write_regs(p_ctx->p_callback->callback_context,
+					reg_list, PD_REG_MIO);
+			PD_DEBUG(" Value 0x%lx written to PFIT_CONTROL 0x%lx",
+					reg_list[0].value,PFIT_CONTROL);
+		}
+	}
 
 	status = sdvo_set_input_timings(p_ctx, &dtd_in);
 	if ((status != SS_SUCCESS) && (status != SS_NOT_SUPPORTED)) {
diff --git a/drivers/staging/emgd/emgd/video/msvdx/msvdx.c b/drivers/staging/emgd/emgd/video/msvdx/msvdx.c
index 35a1300..961adc5 100644
--- a/drivers/staging/emgd/emgd/video/msvdx/msvdx.c
+++ b/drivers/staging/emgd/emgd/video/msvdx/msvdx.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: msvdx.c
- * $Revision: 1.26 $
+ * $Revision: 1.27 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -405,12 +405,12 @@ int send_to_mtx(igd_context_t *context, unsigned long *msg)
 	/* Send an interrupt to the MTX to let it know about the message */
 	EMGD_WRITE32(1, mmio + PSB_MSVDX_MTX_KICK);
 
-	/* Read MSVDX Register several times in case idle signal assert */		
+	/* Read MSVDX Register several times in case idle signal assert */
 	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
 	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
 	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
 	EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_STATUS);
-	
+
 
 #if 0
 	DEBUG_DUMP(context); /* For lots of additional debugging info */
@@ -564,7 +564,7 @@ int msvdx_poll_mtx_irq(igd_context_t *context)
 			return 0;
 		} else if (status & MSVDX_MTX_IRQ_MASK) {
 			/* Clear all interrupt bits */
-			EMGD_WRITE32(0xffff, mmio + PSB_MSVDX_INTERRUPT_CLEAR);
+			EMGD_WRITE32(0xffffffff, mmio + PSB_MSVDX_INTERRUPT_CLEAR);
 			EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_CLEAR);
 
 			msvdx_mtx_interrupt_plb(context);
@@ -685,7 +685,7 @@ IMG_BOOL msvdx_mtx_isr(IMG_VOID *pvData)
 	} else if (msvdx_stat & MSVDX_MTX_IRQ_MASK) {
 		/* Read the firmware to host messages */
 
-        EMGD_WRITE32(0xffff, mmio + PSB_MSVDX_INTERRUPT_CLEAR);
+        EMGD_WRITE32(0xffffffff, mmio + PSB_MSVDX_INTERRUPT_CLEAR);
 		EMGD_READ32(mmio + PSB_MSVDX_INTERRUPT_CLEAR);
 		msvdx_mtx_interrupt_plb(context);
 		//return 0;
diff --git a/drivers/staging/emgd/emgd/video/overlay/plb/ovl_plb.c b/drivers/staging/emgd/emgd/video/overlay/plb/ovl_plb.c
index 56a50fa..39d4a36 100644
--- a/drivers/staging/emgd/emgd/video/overlay/plb/ovl_plb.c
+++ b/drivers/staging/emgd/emgd/video/overlay/plb/ovl_plb.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: ovl_plb.c
- * $Revision: 1.27 $
+ * $Revision: 1.30 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1908,7 +1908,7 @@ static unsigned int ovl_send_instr_plb(
 
 	} else {
 
-		if(ovl_context->fb_blend_ovl) {
+		if (ovl_context->fb_blend_ovl) {
 			tmp = EMGD_READ32(mmio +  PLANE(display)->plane_reg);
 			if((tmp & 0x3c000000) == 0x1c000000) {
 				tmp = tmp & 0xc3FFFFFF;
diff --git a/drivers/staging/emgd/emgd/video/overlay/tnc/ovl2_tnc.c b/drivers/staging/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
index 4239d7c..1c577c4 100644
--- a/drivers/staging/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
+++ b/drivers/staging/emgd/emgd/video/overlay/tnc/ovl2_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: ovl2_tnc.c
- * $Revision: 1.20 $
+ * $Revision: 1.21 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -266,7 +266,8 @@ unsigned int ovl2_send_instr_tnc(
 {
 	unsigned char *mmio = MMIO(display);
 	unsigned long tmp;
-
+	inter_module_dispatch_t *md;
+	platform_context_tnc_t * platform;
 
 
 	EMGD_TRACE_ENTER;
@@ -320,12 +321,16 @@ unsigned int ovl2_send_instr_tnc(
 	 * the ISR bit never changed
 	 */
 
-	ovl_context->sync2 = 0;
+	md = &display->context->mod_dispatch;
+	platform = (platform_context_tnc_t *)display->context->
+					platform_context;
+	if(md && md->set_flip_pending){
+		OS_PTHREAD_MUTEX_LOCK(&platform->flip_mutex);
+		md->set_flip_pending(MMIO(display), 0x71024);
+		OS_PTHREAD_MUTEX_UNLOCK(&platform->flip_mutex);
+	}
 
-	display->context->dispatch.sync(display,
-		IGD_PRIORITY_NORMAL,
-		&ovl_context->sync2,
-		IGD_SYNC_NONBLOCK);
+	ovl_context->sync2 = WAIT_FOR_FLIP;
 
 	EMGD_TRACE_EXIT;
 	return IGD_SUCCESS;
@@ -384,17 +389,6 @@ int query_ovl2_tnc(igd_display_h display_h,
 			return TRUE;
 		}
 
-		/* Wait for vblank */
-		/* Check to see if the plane C flip is pending.  If is is pending
-		 * return FALSE (Flip not done). */
-		if(display->context->dispatch.sync(
-			display,
-			IGD_PRIORITY_NORMAL,
-			&ovl_context->sync2,
-			IGD_SYNC_NONBLOCK)) {
-			EMGD_DEBUG("Overlay Sync Check - Flip not done");
-			return FALSE;
-		}
 		/* According to the PBL B-spec, there doesnt seem to exist any bit
 		 * for Sprite C Flip-Pending status. Testing 0x20AC in code during
 		 * virt queue's REG write shows nothing changed for Bit8. Thus, we
@@ -418,7 +412,7 @@ int query_ovl2_tnc(igd_display_h display_h,
 
 		/* Now that we know the last flip is done and the register update is
 		 * complete, set the sync to 0 and return TRUE (Flip done). */
-		ovl_context->sync2 = 0;
+		ovl_context->sync2 = FLIP_DONE;
 		break;
 	case IGD_OVL_QUERY_WAIT_LAST_FLIP_DONE:
 		/* Wait for 200 milliseconds for the last flip to complete.  If not
diff --git a/drivers/staging/emgd/emgd/video/overlay/tnc/ovl_tnc.c b/drivers/staging/emgd/emgd/video/overlay/tnc/ovl_tnc.c
index 5f8958b..116489c 100644
--- a/drivers/staging/emgd/emgd/video/overlay/tnc/ovl_tnc.c
+++ b/drivers/staging/emgd/emgd/video/overlay/tnc/ovl_tnc.c
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: ovl_tnc.c
- * $Revision: 1.27 $
+ * $Revision: 1.30 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -1951,7 +1951,7 @@ static unsigned int ovl_send_instr_tnc(
 
 	} else {
 
-		if(ovl_context->fb_blend_ovl) {
+		if (ovl_context->fb_blend_ovl) {
 			tmp = EMGD_READ32(mmio +  PLANE(display)->plane_reg);
 			if((tmp & 0x3c000000) == 0x1c000000) {
 				tmp = tmp & 0xc3FFFFFF;
diff --git a/drivers/staging/emgd/include/emgd_drm.h b/drivers/staging/emgd/include/emgd_drm.h
index c696071..fbb024c 100644
--- a/drivers/staging/emgd/include/emgd_drm.h
+++ b/drivers/staging/emgd/include/emgd_drm.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: emgd_drm.h
- * $Revision: 1.60 $
+ * $Revision: 1.63 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -70,7 +70,8 @@ enum {
 #define PVR2D_CREATE_FLIPCHAIN_OEMDISPLAY   (1UL << 4)
 #define PVR2D_CREATE_FLIPCHAIN_OEMGENERAL   (1UL << 5)
 #define PVR2D_CREATE_FLIPCHAIN_OEMFLIPCHAIN (1UL << 6)
-
+#define PVR2D_CREATE_FLIPCHAIN_CI (1UL << 7)
+#define PVR2D_CREATE_FLIPCHAIN_CI_V4L2_MAP (1UL << 8)
 /* Different command */
 #define CMD_VIDEO_STATE           1
 #define CMD_VIDEO_INITIALIZE      2
@@ -229,6 +230,7 @@ typedef struct _kdrm_get_attrs {
 	int extended; /* (DOWN/UP) - true if there are/to get extended attributes */
 } emgd_drm_get_attrs_t;
 
+#define IGD_GET_DISPLAY_NO_3DD_REINIT 	0x1
 
 typedef struct _kdrm_get_display {
 	int rtn; /* (UP) - return value of HAL procedure */
@@ -537,11 +539,16 @@ typedef struct _kdrm_set_surface {
 	unsigned long flags; /* (DOWN) */
 } emgd_drm_set_surface_t;
 
-#define CLONE_PRIMARY 0
-#define CLONE_SECONDARY 1
-#define CLONE 0
-#define DIH   1
+#define PRIMARY_DISPLAY 		0
+#define SECONDARY_DISPLAY 		1
+#define CLONE_PRIMARY 			PRIMARY_DISPLAY
+#define CLONE_SECONDARY 		SECONDARY_DISPLAY
+#define CLONE 				0
+#define DIH   				1
 
+#define DUAL_SCREEN_MAX_DISPLAY 	2
+#define MAX_FFB_SURF_VEXT 		DUAL_SCREEN_MAX_DISPLAY
+#define MAX_FFB_SURF_DIH 		1
 
 typedef struct _kdrm_dihclone_set_surface {
 	int rtn; /* (UP) - return value of HAL procedure */
@@ -698,6 +705,7 @@ typedef struct _kdrm_bc_ts {
 #define DRM_IGD_QUERY_2D_CAPS_HWHINT 0x35
 #define DRM_IGD_DIHCLONE_SET_SURFACE 0x36
 #define DRM_IGD_SET_OVERLAY_DISPLAY  0x37
+#define DRM_IGD_WAIT_VBLANK			 0x40
 
 /*
  * The EMGD DRM includes the PVR DRM, and as such, includes the following PVR
@@ -859,6 +867,9 @@ typedef struct _kdrm_bc_ts {
 #define DRM_IOCTL_IGD_DIHCLONE_SET_SURFACE	DRM_IOWR(DRM_IGD_DIHCLONE_SET_SURFACE + BASE,\
 		emgd_drm_dihclone_set_surface_t)
 
+#define DRM_IOCTL_IGD_WAIT_VBLANK			DRM_IOWR(DRM_IGD_WAIT_VBLANK + BASE,\
+		emgd_drm_driver_set_sync_refresh_t)
+
 
 /* From pvr_bridge.h */
 #define DRM_IOCTL_IGD_RESERVED_1       DRM_IOW(DRM_IGD_RESERVED_1 + BASE, \
diff --git a/drivers/staging/emgd/include/igd.h b/drivers/staging/emgd/include/igd.h
index 51084ee..2c81c51 100644
--- a/drivers/staging/emgd/include/igd.h
+++ b/drivers/staging/emgd/include/igd.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd.h
- * $Revision: 1.21 $
+ * $Revision: 1.22 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -743,6 +743,17 @@ typedef struct _igd_dispatch {
 		unsigned int type,
 		unsigned long *flags);
 
+
+	int (*gmm_map_ci)(unsigned long *gtt_offset,
+			unsigned long ci_param,	/*virtaddr or v4l2_offset*/
+			unsigned long *virt_addr,
+			unsigned int map_method,
+			unsigned long size);
+
+
+	int (*gmm_unmap_ci)(unsigned long virt_addr);
+
+
 	/*!
 	 * This function maps an existing list of pages into the GTT.
 	 *
diff --git a/drivers/staging/emgd/include/igd_gmm.h b/drivers/staging/emgd/include/igd_gmm.h
index db2b2a8..b262a14 100644
--- a/drivers/staging/emgd/include/igd_gmm.h
+++ b/drivers/staging/emgd/include/igd_gmm.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_gmm.h
- * $Revision: 1.12 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -104,8 +104,8 @@
 #define IGD_SURFACE_FENCED    0x00004000
 #define IGD_SURFACE_SYS_MEM   0x00008000
 #define IGD_SURFACE_PHYS_PTR  0x00010000
-
-
+#define IGD_SURFACE_CI		0x00020000
+#define IGD_SURFACE_CI_V4L2_MAP	0x00040000		/*will be set when map_method=0 without WA*/
 /*
  * Mipmap flags are only valid on mipmap surfaces.
  * Planes flags are only valid on volume surfaces.
diff --git a/drivers/staging/emgd/include/igd_mode.h b/drivers/staging/emgd/include/igd_mode.h
index 4a8a68f..6fc61a7 100644
--- a/drivers/staging/emgd/include/igd_mode.h
+++ b/drivers/staging/emgd/include/igd_mode.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_mode.h
- * $Revision: 1.15 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -522,6 +522,14 @@ typedef void* igd_driver_h;
 #define IGD_FB_FLAGS_MASK                       0xf0000000
 /* @} */
 
+/*
+ * Right now, these flags are only used by igd_alter_displays when calling into
+ * the 3rd party dc code to indicate which flip-chains to
+ * disable.
+ */
+#define IGD_DISPLAY_PRIMARY                     0x1
+#define IGD_DISPLAY_SECONDARY 					0x2
+#define IGD_DISPLAY_ALL                         (IGD_DISPLAY_PRIMARY | IGD_DISPLAY_SECONDARY)
 
 /*!
  * @brief Framebuffer related mode setting data.
@@ -894,6 +902,14 @@ typedef struct _igd_port_info {
 
 
 
+typedef struct _kdrm_driver_set_sync_refresh {
+        igd_display_h   display_handle;
+        unsigned int    start_line;
+        unsigned int    bottom_line;
+} emgd_drm_driver_set_sync_refresh_t;
+
+
+
 /*!
  * @name Alloc Display Flags (deprecated)
  *
diff --git a/drivers/staging/emgd/include/igd_ovl.h b/drivers/staging/emgd/include/igd_ovl.h
index 4e0491f..0c4ac4c 100644
--- a/drivers/staging/emgd/include/igd_ovl.h
+++ b/drivers/staging/emgd/include/igd_ovl.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_ovl.h
- * $Revision: 1.14 $
+ * $Revision: 1.17 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -321,3 +321,6 @@ typedef struct _ovl_um_context {
 
 
 #endif /*_IGD_OVL_H*/
+
+#define WAIT_FOR_FLIP 1
+#define FLIP_DONE 0
diff --git a/drivers/staging/emgd/include/igd_pd.h b/drivers/staging/emgd/include/igd_pd.h
index 51164d0..2c36267 100644
--- a/drivers/staging/emgd/include/igd_pd.h
+++ b/drivers/staging/emgd/include/igd_pd.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_pd.h
- * $Revision: 1.12 $
+ * $Revision: 1.13 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -262,6 +262,7 @@
 
 #define PD_ATTR_ID_LOAD_FIRMWARE		0x65
 #define PD_ATTR_ID_REFRESH			0x66
+#define PD_ATTR_ID_DWNSCAL_BYPASS		0x57 //1.2.5.pd: new pd attributes to handle the downscalling quality issue
 
 
 //************ end of ch7036 defined port driver attribute ********** //
diff --git a/drivers/staging/emgd/include/igd_render.h b/drivers/staging/emgd/include/igd_render.h
index ee2f099..c492918 100644
--- a/drivers/staging/emgd/include/igd_render.h
+++ b/drivers/staging/emgd/include/igd_render.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_render.h
- * $Revision: 1.17 $
+ * $Revision: 1.18 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -341,6 +341,8 @@ typedef int (*_igd_get_surface_fn_t)(
 #define IGD_BUFFER_ASYNC     0x4
 /* Issue a Wait for last flip only, do not flip again */
 #define IGD_BUFFER_WAIT      0x8
+/* Do not pan */
+#define IGD_BUFFER_NO_PAN		 0x10
 
 /* ------ WARNING!!!! Read Before Changing ------ */
 /*    Command should always be 32 Bit on all platforms including 64 bit */
diff --git a/drivers/staging/emgd/include/igd_version.h b/drivers/staging/emgd/include/igd_version.h
index b96a3d5..a0482a5 100644
--- a/drivers/staging/emgd/include/igd_version.h
+++ b/drivers/staging/emgd/include/igd_version.h
@@ -1,7 +1,7 @@
 /*
  *-----------------------------------------------------------------------------
  * Filename: igd_version.h
- * $Revision: 1.192 $
+ * $Revision: 1.217 $
  *-----------------------------------------------------------------------------
  * Copyright (c) 2002-2010, Intel Corporation.
  *
@@ -35,7 +35,7 @@
 
 #define IGD_MAJOR_NUM  1
 #define IGD_MINOR_NUM  14
-#define IGD_BUILD_NUM  2348
+#define IGD_BUILD_NUM  2443
 
 #define IGD_PCF_VERSION   0x00000400
 #endif
diff --git a/drivers/staging/emgd/pvr/include4/servicesext.h b/drivers/staging/emgd/pvr/include4/servicesext.h
index 9c00725..0f3dc1d 100644
--- a/drivers/staging/emgd/pvr/include4/servicesext.h
+++ b/drivers/staging/emgd/pvr/include4/servicesext.h
@@ -506,6 +506,7 @@ typedef struct DISPLAY_SURF_ATTRIBUTES_TAG
 	PVRSRV_PIXEL_FORMAT		pixelformat;
 
 	DISPLAY_DIMS			sDims;
+	IMG_UINT32			ui32Reseved;
 } DISPLAY_SURF_ATTRIBUTES;
 
 
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
index 211fb60..55a791e 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.c
@@ -50,7 +50,15 @@
 
 #include "pvrmodule.h"
 #include "emgd_bc.h"
-
+/*
+** Device Name Space is for device name, steam tag and device state.
+** Format
+** [Name]...[Video ID][Device Status]
+** From Device Name Space tail,
+** Device Status - one Byte
+** Video ID - four Byte
+** Device Name - variation according to device name set.
+*/
 #define TSBUFFERCLASS_DEVICE_NAME "BC Texture Stream Device"
 
 unsigned int bc_video_id[BUFCLASS_DEVICE_MAX_ID];
@@ -270,9 +278,11 @@ emgd_error_t bc_ts_init(IMG_UINT32 id) {
         if (!(*pfnGetPVRJTable)(&psDevInfo->sPVRJTable)){
             return (EMGD_ERROR_INIT_FAILURE);
         }
-
-        strncpy(psDevInfo->sBufferInfo.szDeviceName,
-                    TSBUFFERCLASS_DEVICE_NAME, MAX_BUFFER_DEVICE_NAME_SIZE);
+		if (TSBUFFERCLASS_DEV_NAME_LEN < 0) {
+			EMGD_ERROR("BufferClass Device Name Space is too small!");
+			return EMGD_ERROR_INIT_FAILURE;
+		}
+        strncpy(psDevInfo->sBufferInfo.szDeviceName, TSBUFFERCLASS_DEVICE_NAME, TSBUFFERCLASS_DEV_NAME_LEN);
 		/* Initialize BC JTable */
         psDevInfo->sBCJTable.ui32TableSize = sizeof (PVRSRV_BC_SRV2BUFFER_KMJTABLE);
 
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h
index 1e333c3..7d5b5e3 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc.h
@@ -63,6 +63,18 @@ extern "C"
 
 #define BUFCLASS_DEVICE_MAX_ID	6
 #define BUFCLASS_BUFFER_MAX		64
+/*
+** Device Name Space is for device name, steam tag and device state.
+** Format
+** [Name]...[Video ID][Device Status]
+** From Device Name Space tail,
+** Device Status - one Byte
+** Video ID - four Byte
+** Device Name - variation according to device name set.
+*/
+#define TSBUFFERCLASS_DEV_NAME_LEN (MAX_BUFFER_DEVICE_NAME_SIZE - sizeof(IMG_UINT32) - sizeof(IMG_CHAR) - 1)
+#define TSBUFFERCLASS_VIDEOID_OFFSET (MAX_BUFFER_DEVICE_NAME_SIZE - sizeof(IMG_UINT32) - sizeof(IMG_CHAR))
+#define TSBUFFERCLASS_DEVSTATUS_OFFSET (MAX_BUFFER_DEVICE_NAME_SIZE - sizeof(IMG_CHAR))
 
     typedef void *BCE_HANDLE;
 
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
index a79e276..ca987b9 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_bufferclass/emgd_bc_linux.c
@@ -77,6 +77,11 @@ extern void* gp_bc_Anchor[BUFCLASS_DEVICE_MAX_ID];
 #define MAX_STREAM_TAG 0xFFFFFFF0
 unsigned long bc_stream_tag = 0;
 
+typedef enum _BC_DEVICE_STATE {
+	BC_DEV_READY = 0xF0,
+	BC_DEV_NOT_READY,
+} BC_Dev_Status;
+
 #if 0
 MODULE_SUPPORTED_DEVICE (DEVNAME);
 
@@ -111,6 +116,12 @@ unsigned long g_ulMemCurrent = 0;
 */
 static int flg_bc_ts_init = 0;
 
+/*
+** Function: Set device state
+** state: 0 - enable; 1 - disable
+*/
+void emgd_bc_ts_set_state(BC_DEVINFO *psDevInfo, const IMG_CHAR state);
+
 int emgd_bc_ts_init(void){
     int i, j;
 #if 0
@@ -562,9 +573,6 @@ int BC_DestroyBuffers(void *psDevInfo) {
     DevInfo->sBufferInfo.ui32ByteStride = 0;
     DevInfo->sBufferInfo.ui32Flags = 0;
     DevInfo->sBufferInfo.ui32BufferCount = 0;
-	memset(DevInfo->sBufferInfo.szDeviceName + strlen(DevInfo->sBufferInfo.szDeviceName),
-			0,
-			MAX_BUFFER_DEVICE_NAME_SIZE - strlen(DevInfo->sBufferInfo.szDeviceName));
 
 	EMGD_TRACE_EXIT;
 
@@ -603,11 +611,12 @@ static __inline int emgd_bc_ts_bridge_init(struct drm_device *drv, void* arg, st
 			} else {
 				bc_stream_tag++;
 			}
-			if ((strlen(psDevInfo->sBufferInfo.szDeviceName) + sizeof(bc_stream_tag)) <= (MAX_BUFFER_DEVICE_NAME_SIZE - 1)) {
-			memcpy(psDevInfo->sBufferInfo.szDeviceName + strlen(psDevInfo->sBufferInfo.szDeviceName) + 1, &bc_stream_tag, sizeof(bc_stream_tag));
-			} else {
-				EMGD_ERROR("Failed to Add stream tag");
-			}
+
+			*(IMG_UINT32 *)(psDevInfo->sBufferInfo.szDeviceName + TSBUFFERCLASS_VIDEOID_OFFSET) = bc_stream_tag;
+
+			/* Disable device*/
+			emgd_bc_ts_set_state(psDevInfo, 0);
+
 			EMGD_DEBUG("Grab a Device - 0x%lx , ID %lu, idx - %d\n",
 				(unsigned long)psDevInfo,
 				psBridge->dev_id,
@@ -642,6 +651,10 @@ static __inline int emgd_bc_ts_bridge_uninit(struct drm_device *drv, void* arg,
 	}
 
 	psDevInfo = (BC_DEVINFO *)GetAnchorPtr(psBridge->dev_id);
+
+	/* To disable buffer class device*/
+	emgd_bc_ts_set_state(psDevInfo, 0);
+
 	if (EMGD_OK == BC_DestroyBuffers((void *)psDevInfo)) {
 		EMGD_DEBUG("Free Device -  %lu", psBridge->dev_id);
 		bc_video_id_usage[i] = 0,
@@ -722,6 +735,8 @@ static __inline int emgd_bc_ts_bridge_release_buffers(struct drm_device *drv, vo
 	}
 
 	if (NULL != psDevInfo && 1 == bc_video_id_usage[psDevInfo->sBufferInfo.ui32BufferDeviceID]) {
+		emgd_bc_ts_set_state(psDevInfo, 0);
+
    		if (EMGD_OK == BC_DestroyBuffers((void *)psDevInfo)) {
 			psBridge->rtn = 0;
 			err = EMGD_OK;
@@ -763,6 +778,20 @@ static __inline int emgd_bc_ts_bridge_set_buffer_info(struct drm_device *drv, vo
 		EMGD_ERROR("input device id is invalid");
 		return err;
 	}
+	/*  To Set Buffer Class Device State */
+	if (0xFF == psBridge->buf_id && BUFCLASS_BUFFER_MAX < psBridge->buf_id) {
+			/* 0xFF - Indicates Buffer Class Device is ready. 0xF0 - not ready */
+		if (BC_DEV_READY == psBridge->buf_tag && 0 < devinfo->sBufferInfo.ui32BufferCount) {
+			emgd_bc_ts_set_state(devinfo, 1);
+			EMGD_DEBUG("dev_id %lu Enable to be Ready!\n", psBridge->dev_id);
+			goto SUCCESS_OK;
+		}
+		if (BC_DEV_NOT_READY == psBridge->buf_tag) {
+			emgd_bc_ts_set_state(devinfo, 0);
+			EMGD_DEBUG("dev_id %lu Disabled!\n", psBridge->dev_id);
+			goto SUCCESS_OK;
+		}
+	}
 
    	if (psBridge->buf_id >= devinfo->sBufferInfo.ui32BufferCount) {
         EMGD_ERROR("Invalid buf_id");
@@ -785,6 +814,7 @@ static __inline int emgd_bc_ts_bridge_set_buffer_info(struct drm_device *drv, vo
 		bcBuf->psSysAddr[0].uiAddr = psBridge->phyaddr;
 	}
 
+SUCCESS_OK:
 	psBridge->rtn = 0;
 
 	EMGD_TRACE_EXIT;
@@ -960,3 +990,10 @@ int emgd_bc_ts_get_buffer_index(struct drm_device *dev, void *arg, struct drm_fi
 
 	return 0;
 }
+
+void emgd_bc_ts_set_state(BC_DEVINFO *psDevInfo, const IMG_CHAR state)
+{
+	if (NULL != psDevInfo) {
+		psDevInfo->sBufferInfo.szDeviceName[TSBUFFERCLASS_DEVSTATUS_OFFSET] = state;
+	}
+}
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
index eb9462b..a3ed126 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.c
@@ -539,7 +539,14 @@ static PVRSRV_ERROR GetDCBufferAddr(IMG_HANDLE device_h,
 	 * Other than cursor, memory allocations are not contiguous pages
 	 */
 	if (is_contiguous) {
-		*is_contiguous = IMG_FALSE;
+		if(system_buffer->is_contiguous == IMG_TRUE)
+		{	*is_contiguous = IMG_TRUE;
+
+		}
+		else{
+			*is_contiguous = IMG_FALSE;
+
+		}
 	}
 
 	EMGD_TRACE_EXIT;
@@ -647,7 +654,7 @@ static void free_swap_chain(emgddc_swapchain_t *swap_chain,
 	igd_context_t *context)
 {
 	emgddc_buffer_t *buffers;
-	int i;
+	int i=0;
 
 	/*
 	 * Free and unmap the buffers.  Must ensure that the HAL is running before
@@ -656,16 +663,22 @@ static void free_swap_chain(emgddc_swapchain_t *swap_chain,
 	 */
 	if (swap_chain->devinfo->priv->hal_running) {
 		buffers = swap_chain->buffers;
-		for (i = 0 ; i < swap_chain->buffer_count ; i++) {
-			if (!buffers[i].is_fb) {
-				if (buffers[i].virt_addr) {
-					context->dispatch.gmm_unmap(buffers[i].virt_addr);
-				}
-				if (buffers[i].offset) {
-					context->dispatch.gmm_free(buffers[i].offset);
+
+		if(!buffers[i].is_contiguous){
+			for (i = 0 ; i < swap_chain->buffer_count ; i++) {
+				if (!buffers[i].is_fb) {
+					if (buffers[i].virt_addr) {
+						context->dispatch.gmm_unmap(buffers[i].virt_addr);
+					}
+					if (buffers[i].offset) {
+						context->dispatch.gmm_free(buffers[i].offset);
+					}
 				}
 			}
 		}
+		else{
+			context->dispatch.gmm_unmap_ci((unsigned long)buffers[0].virt_addr);
+		}
 	}
 
 	if (swap_chain->flip_queue) {
@@ -739,10 +752,18 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 	igd_dispatch_t *dispatch;
 	int flipable;
 
+	IMG_UINT32 ci_offset=0;
+
+
 	EMGD_TRACE_ENTER;
 	EMGD_DEBUG("device_h = 0x%p, buffer_count = %lu", device_h, buffer_count);
 	EMGD_DEBUG("flags = 0x%08lx, oem_flags = 0x%08lx", flags, oem_flags);
 
+	if(flags & PVR2D_CREATE_FLIPCHAIN_CI)
+	{
+		ci_offset = src_surf_attrib->ui32Reseved;
+
+	}
 
 	/*
 	 * Check the parameters and dependencies:
@@ -768,8 +789,10 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 	/* Is this is an OEM call (I.E. allocating a buffer)? */
 	if ((oem_flags & (PVR2D_CREATE_FLIPCHAIN_OEMDISPLAY |
 				PVR2D_CREATE_FLIPCHAIN_OEMGENERAL |
-				PVR2D_CREATE_FLIPCHAIN_OEMOVERLAY))) {
+				PVR2D_CREATE_FLIPCHAIN_OEMOVERLAY |
+				PVR2D_CREATE_FLIPCHAIN_CI))) {
 		flipable = 0;
+
 	} else {
 		/*
 		 * If this is suppose to be an actual flip-able swap chain, then
@@ -779,6 +802,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 			return PVRSRV_ERROR_TOO_FEW_BUFFERS;
 		}
 		flipable = 1;
+
 	}
 
 	devinfo = (emgddc_devinfo_t *) device_h;
@@ -893,6 +917,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 	 */
 	for (; i < buffer_count ; i++) {
 		unsigned long offset;
+		unsigned long virt_addr;
 		unsigned int width = 0;
 		unsigned int height = 0;
 		unsigned int pitch = 0;
@@ -900,6 +925,7 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 		unsigned long pf;
 		unsigned long flags = IGD_SURFACE_RENDER;
 		int ret;
+		unsigned int map_method=1;	/*1: gtt map by va driver*/
 
 		if (!(oem_flags & PVR2D_CREATE_FLIPCHAIN_OEMGENERAL)) {
 			flags |= IGD_SURFACE_DISPLAY;
@@ -917,15 +943,41 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 		height = dst_surf_attrib->sDims.ui32Height;
 		pitch = dst_surf_attrib->sDims.ui32ByteStride;
 		flags |= IGD_MIN_PITCH;
-		ret = dispatch->gmm_alloc_surface(&offset,
-			pf,
-			&width, &height,
-			&pitch, &size,
-			IGD_GMM_ALLOC_TYPE_NORMAL, &flags);
-		if (0 != ret) {
-			free_swap_chain(swap_chain, context);
-			EMGD_ERROR_EXIT("gmm_alloc_surface() failed (%d)", ret);
-			return PVRSRV_ERROR_OUT_OF_MEMORY;
+
+		if(oem_flags & PVR2D_CREATE_FLIPCHAIN_CI){
+			if(oem_flags & PVR2D_CREATE_FLIPCHAIN_CI_V4L2_MAP)
+				map_method = 0;
+
+
+			size=height*pitch;
+			ret = dispatch->gmm_map_ci(&offset,
+				ci_offset,
+				&virt_addr,
+				map_method,
+				size);
+
+
+			if (0 != ret) {
+				free_swap_chain(swap_chain, context);
+				EMGD_ERROR_EXIT("gmm_alloc_surface() failed (%d)", ret);
+				return PVRSRV_ERROR_OUT_OF_MEMORY;
+			}
+			buffers[i].is_contiguous = IMG_TRUE;
+
+		}
+		else{
+
+			ret = dispatch->gmm_alloc_surface(&offset,
+				pf,
+				&width, &height,
+				&pitch, &size,
+				IGD_GMM_ALLOC_TYPE_NORMAL, &flags);
+			if (0 != ret) {
+				free_swap_chain(swap_chain, context);
+				EMGD_ERROR_EXIT("gmm_alloc_surface() failed (%d)", ret);
+				return PVRSRV_ERROR_OUT_OF_MEMORY;
+			}
+			buffers[i].is_contiguous = IMG_FALSE;
 		}
 
 		dst_surf_attrib->sDims.ui32ByteStride = pitch;
@@ -936,8 +988,15 @@ static PVRSRV_ERROR CreateDCSwapChain(IMG_HANDLE device_h,
 		buffers[i].height = height;
 		buffers[i].pitch = pitch;
 		buffers[i].size = (size + (PAGE_SIZE - 1)) & PAGE_MASK;
+
 		buffers[i].offset = offset;
-		buffers[i].virt_addr = dispatch->gmm_map(offset);
+
+		if(oem_flags & PVR2D_CREATE_FLIPCHAIN_CI){
+
+				buffers[i].virt_addr = (IMG_CPU_VIRTADDR)virt_addr;
+		}
+		else
+			buffers[i].virt_addr = dispatch->gmm_map(offset);
 		buffers[i].sync_data = sync_data[i];
 		buffers[i].is_fb = 0;
 	} /* for */
@@ -2106,8 +2165,8 @@ static emgd_error_t emgddc_init_devinfo(struct drm_device *dev,
 	cmd_proc_list[DC_FLIP_COMMAND] = emgddc_process_flip;
 
 	/* FIXME:  Not sure what these are for: */
-	sync_count_list[DC_FLIP_COMMAND][0] = 0; 
-	sync_count_list[DC_FLIP_COMMAND][1] = 2; 
+	sync_count_list[DC_FLIP_COMMAND][0] = 0;
+	sync_count_list[DC_FLIP_COMMAND][1] = 2;
 
 	if (pvr_jtable->pfnPVRSRVRegisterCmdProcList(devinfo->device_id,
 		&cmd_proc_list[0],
@@ -2152,8 +2211,6 @@ static emgd_error_t init_display(emgddc_devinfo_t *devinfo,
 	int mode_flags = IGD_QUERY_LIVE_MODES;
 	emgddc_buffer_t *buffer = &(devinfo->system_buffer);
 	int i = 1, j, ret;
-	emgddc_swapchain_t *swap_chain;
-	unsigned long lock_flags;
 
 	EMGD_TRACE_ENTER;
 
@@ -2163,25 +2220,6 @@ static emgd_error_t init_display(emgddc_devinfo_t *devinfo,
 	EMGD_DEBUG(" display=0x%p", display);
 	EMGD_DEBUG(" port_number=%u", port_number);
 
-
-	/* Mode changes invalidate flip-able swap chains.  We can't destroy them
-	 * behind the back of PVR services, but we can and should ignore all
-	 * pending and future buffer flips for existing swap chains.
-	 *
-	 * Note: new swap chains will be valid, and be able to perform flips.
-	 */
-	/* Obtain the lock, to hold-off future interrupt handling for a bit */
-	spin_lock_irqsave(&devinfo->swap_chain_lock, lock_flags);
-	swap_chain = devinfo->flipable_swapchains;
-	while (swap_chain != NULL) {
-		swap_chain->valid = EMGD_FALSE;
-		flush_flip_queue(swap_chain);
-		swap_chain = swap_chain->next;
-	}
-	/* Now that we've invalidated pending flips, release the lock */
-	spin_unlock_irqrestore(&devinfo->swap_chain_lock, lock_flags);
-
-
 	/* Clear the following lists, in case we are re-initializing: */
 	OS_MEMSET(devinfo->display_format_list, 0,
 			sizeof(devinfo->display_format_list));
@@ -2346,6 +2384,84 @@ static emgd_error_t init_display(emgddc_devinfo_t *devinfo,
 
 } /* init_display() */
 
+/**
+ * Loops through the avaiable displays, invalidating the  associated flip-chains
+ * This function is called from igd_alter_displays so as to resolve any race
+ * conditions that may occur due to performing a flip during a mode-set.
+ *
+ * @param display     (IN) The display whose flipchains are to be invalidated.
+ */
+static int emgddc_invalidate_flip_chains(int display) {
+
+	emgddc_devinfo_t * devinfo;
+	emgddc_swapchain_t *swap_chain;
+	unsigned long lock_flags;
+	igd_surface_t surf;
+	igd_display_h display_handle;
+	igd_context_t *context;
+	int i;
+	int ret;
+
+	EMGD_TRACE_ENTER;
+	EMGD_DEBUG("Parameters:");
+	EMGD_DEBUG("display=0x%1x",display);
+
+	for (i = 0; i < MAX_DISPLAYS; i++) {
+		if (display & (1 << i)) {
+			devinfo = global_devinfo[i];
+
+			if (devinfo == NULL) {
+				EMGD_DEBUG("Skipping NULL display at index %d", i);
+				continue;
+			}
+
+
+			/* Mode changes invalidate flip-able swap chains.  We can't destroy
+			 * them behind the back of PVR services, but we can and should
+			 * ignore all pending and future buffer flips for existing swap
+			 * chains.
+			 * Note: new swap chains will be valid, and be able to perform flips.
+			 */
+			/* Obtain the lock, to hold-off future interrupt handling for a bit */
+			spin_lock_irqsave(&devinfo->swap_chain_lock, lock_flags);
+			swap_chain = devinfo->flipable_swapchains;
+			while (swap_chain != NULL) {
+				swap_chain->valid = EMGD_FALSE;
+
+				flush_flip_queue(swap_chain);
+				swap_chain = swap_chain->next;
+			}
+			/* Now that we've invalidated pending flips, release the lock */
+			spin_unlock_irqrestore(&devinfo->swap_chain_lock, lock_flags);
+
+			/* Reset the frame-buffer information to point to the system
+			 * buffer */
+			context = devinfo->priv->context;
+			display_handle = (devinfo->which_devinfo == 1)?
+								devinfo->priv->secondary:devinfo->priv->primary;
+
+			surf.offset = devinfo->system_buffer.offset;
+			surf.pitch = devinfo->system_buffer.pitch;
+			surf.width = devinfo->system_buffer.width;
+			surf.height = devinfo->system_buffer.height;
+			surf.pixel_format = devinfo->system_buffer.pixel_format;
+			surf.flags = IGD_SURFACE_RENDER | IGD_SURFACE_DISPLAY;
+
+			ret = context->dispatch.set_surface(display_handle,
+					IGD_PRIORITY_NORMAL, IGD_BUFFER_DISPLAY, &surf, NULL, 0);
+
+			if (ret) {
+				EMGD_ERROR("set_surface() returned %d for display at index %d",
+						ret, i);
+			}
+		}
+	}
+
+	EMGD_TRACE_EXIT;
+
+	return 0;
+}
+
 
 /**
  * [Re-]Initializes the 3DD's display/device-specific values for both devinfo
@@ -2476,6 +2592,10 @@ emgd_error_t emgddc_init(struct drm_device *dev)
 	 * initialized):
 	 */
 	priv->reinit_3dd = emgddc_reinit_3dd;
+
+	/* Used inside igd_alter_displays */
+	priv->invalidate_flip_chains = emgddc_invalidate_flip_chains;
+
 	ret = emgddc_reinit_3dd(dev);
 	if (ret != EMGD_OK) {
 		emgddc_free_all_devinfos();
diff --git a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h
index 81b6254..8ea6d33 100644
--- a/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h
+++ b/drivers/staging/emgd/pvr/services4/3rdparty/emgd_displayclass/emgd_dc.h
@@ -106,6 +106,8 @@ typedef struct _emgddc_buffer
 	/** The PVR sync data for this buffer */
 	PVRSRV_SYNC_DATA *sync_data;
 
+	unsigned long is_contiguous;
+
 	/**
 	 * The PVR next buffer in the swap chain (the last buffer points to the
 	 * first buffer
diff --git a/drivers/staging/emgd/pvr/services4/include/sgxinfo.h b/drivers/staging/emgd/pvr/services4/include/sgxinfo.h
index 22c5399..2e85b61 100644
--- a/drivers/staging/emgd/pvr/services4/include/sgxinfo.h
+++ b/drivers/staging/emgd/pvr/services4/include/sgxinfo.h
@@ -240,6 +240,10 @@ typedef struct _PVRSRV_TRANSFER_SGX_KICK_
 #if defined(PDUMP)
 	IMG_UINT32		ui32CCBDumpWOff;
 #endif
+
+	IMG_HANDLE		display;
+	IMG_UINT32		headline;
+	IMG_UINT32		footline;
 } PVRSRV_TRANSFER_SGX_KICK, *PPVRSRV_TRANSFER_SGX_KICK;
 
 #if defined(SGX_FEATURE_2D_HARDWARE)
diff --git a/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c b/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c
index b6d7a8b..2867a08 100644
--- a/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c
+++ b/drivers/staging/emgd/pvr/services4/srvkm/common/deviceclass.c
@@ -26,6 +26,8 @@
 #include "pvr_bridge_km.h"
 
 #include "lists.h"
+#include "emgd_drm.h"
+
 DECLARE_LIST_ANY_VA(PVRSRV_DEVICE_NODE);
 DECLARE_LIST_FOR_EACH_VA(PVRSRV_DEVICE_NODE);
 DECLARE_LIST_INSERT(PVRSRV_DEVICE_NODE);
@@ -857,16 +859,18 @@ static PVRSRV_ERROR DestroyDCSwapChain(PVRSRV_DC_SWAPCHAIN *psSwapChain)
 		}
 	}
 
-    do
-    {
-        eError = PVRSRVDestroyCommandQueueKM(psSwapChain->psQueue);
-    } while (eError != PVRSRV_OK && (timeout-- > 0));
-	if (eError != PVRSRV_OK)
+	if (psSwapChain->psQueue)
 	{
-		PVR_DPF((PVR_DBG_ERROR,"DestroyDCSwapChainCallBack: Failed to destroy command queue"));
+		do
+		{
+			eError = PVRSRVDestroyCommandQueueKM(psSwapChain->psQueue);
+		} while (eError != PVRSRV_OK && (timeout-- > 0));
+		if (eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"DestroyDCSwapChainCallBack: Failed to destroy command queue"));
+		}
 	}
 
-
 	eError = psDCInfo->psFuncTable->pfnDestroyDCSwapChain(psDCInfo->hExtDevice,
 															psSwapChain->hExtSwapChain);
 
@@ -1043,22 +1047,28 @@ PVRSRV_ERROR PVRSRVCreateDCSwapChainKM (PVRSRV_PER_PROCESS_DATA	*psPerProc,
 
 	OSMemSet (psSwapChain, 0, sizeof(PVRSRV_DC_SWAPCHAIN));
 
-    // try few times to get the lock
-    do
-    {
-        eError = PVRSRVCreateCommandQueueKM(1024, &psQueue);
-    } while (eError != PVRSRV_OK && (timeout-- > 0));
-
-	if(eError != PVRSRV_OK)
+	if (ui32OEMFlags & (PVR2D_CREATE_FLIPCHAIN_OEMDISPLAY |
+				PVR2D_CREATE_FLIPCHAIN_OEMGENERAL |
+				PVR2D_CREATE_FLIPCHAIN_OEMOVERLAY))
 	{
-		PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Failed to create CmdQueue"));
-		goto ErrorExit;
+		psQueue = NULL;
 	}
+	else
+	{
+		do
+		{
+			eError = PVRSRVCreateCommandQueueKM(1024, &psQueue);
+		} while (eError != PVRSRV_OK && (timeout-- > 0));
 
+		if(eError != PVRSRV_OK)
+		{
+			PVR_DPF((PVR_DBG_ERROR,"PVRSRVCreateDCSwapChainKM: Failed to create CmdQueue"));
+			goto ErrorExit;
+		}
+	}
 
 	psSwapChain->psQueue = psQueue;
 
-
 	for(i=0; i<ui32BufferCount; i++)
 	{
 		eError = PVRSRVAllocSyncInfoKM(IMG_NULL,
@@ -1361,6 +1371,11 @@ PVRSRV_ERROR PVRSRVSwapToDCBufferKM(IMG_HANDLE	hDeviceKM,
 
 	psQueue = psBuffer->psSwapChain->psQueue;
 
+	if (!psQueue)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCBufferKM: Non-flippable swap chain"));
+		goto Exit;
+	}
 
 	apsSrcSync[0] = psBuffer->sDeviceClassBuffer.psKernelSyncInfo;
 
@@ -1506,6 +1521,12 @@ PVRSRV_ERROR PVRSRVSwapToDCSystemKM(IMG_HANDLE	hDeviceKM,
 
 	psQueue = psSwapChain->psQueue;
 
+	if (!psQueue)
+	{
+		PVR_DPF((PVR_DBG_ERROR,"PVRSRVSwapToDCSystemKM: Non-flippable swap chain"));
+		goto Exit;
+	}
+
 #if defined(SUPPORT_CUSTOM_SWAP_OPERATIONS)
 
 	if(psDCInfo->psFuncTable->pfnQuerySwapCommandID != IMG_NULL)
diff --git a/drivers/staging/emgd/pvr/services4/srvkm/devices/sgx/sgxtransfer.c b/drivers/staging/emgd/pvr/services4/srvkm/devices/sgx/sgxtransfer.c
index 9fd93da..9899f92 100644
--- a/drivers/staging/emgd/pvr/services4/srvkm/devices/sgx/sgxtransfer.c
+++ b/drivers/staging/emgd/pvr/services4/srvkm/devices/sgx/sgxtransfer.c
@@ -39,6 +39,8 @@
 #include "pvr_debug.h"
 #include "sgxutils.h"
 
+int do_wait_vblank(void *display, int headline, int footline);
+
 IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle, PVRSRV_TRANSFER_SGX_KICK *psKick)
 {
 	PVRSRV_KERNEL_MEM_INFO  *psCCBMemInfo = (PVRSRV_KERNEL_MEM_INFO *)psKick->hCCBMemInfo;
@@ -208,6 +210,8 @@ IMG_EXPORT PVRSRV_ERROR SGXSubmitTransferKM(IMG_HANDLE hDevHandle, PVRSRV_TRANSF
 
 	sCommand.ui32Data[1] = psKick->sHWTransferContextDevVAddr.uiAddr;
 
+	if (psKick->display)
+		do_wait_vblank(psKick->display, psKick->headline, psKick->footline);
 	eError = SGXScheduleCCBCommandKM(hDevHandle, SGXMKIF_CMD_TRANSFER, &sCommand, KERNEL_ID, psKick->ui32PDumpFlags);
 
 	if (eError == PVRSRV_ERROR_RETRY)
diff --git a/drivers/staging/emgd/pvr/services4/srvkm/env/linux/event.c b/drivers/staging/emgd/pvr/services4/srvkm/env/linux/event.c
index db7d5f3..85493c1 100644
--- a/drivers/staging/emgd/pvr/services4/srvkm/env/linux/event.c
+++ b/drivers/staging/emgd/pvr/services4/srvkm/env/linux/event.c
@@ -211,6 +211,7 @@ PVRSRV_ERROR LinuxEventObjectSignal(IMG_HANDLE hOSEventObjectList)
 	struct list_head *psListEntry, *psListEntryTemp, *psList;
 	psList = &psLinuxEventObjectList->sList;
 
+	read_lock(&psLinuxEventObjectList->sLock);
 	list_for_each_safe(psListEntry, psListEntryTemp, psList)
 	{
 
@@ -219,6 +220,7 @@ PVRSRV_ERROR LinuxEventObjectSignal(IMG_HANDLE hOSEventObjectList)
 		atomic_inc(&psLinuxEventObject->sTimeStamp);
 	 	wake_up_interruptible(&psLinuxEventObject->sWait);
 	}
+	read_unlock(&psLinuxEventObjectList->sLock);
 
 	return 	PVRSRV_OK;
 
-- 
1.7.4.1

